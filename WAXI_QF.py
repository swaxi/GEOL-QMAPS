# -*- coding: utf-8 -*-
"""
/***************************************************************************
 WAXI_QF
                                 A QGIS plugin
 Supoprt QField usage by WAXI Team
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-05-31
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Mark Jessell UWA
        email                : mark.jessell@uwa.edu.au
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""



from qgis.gui import QgsMessageBar
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QThread, pyqtSignal, QUrl
from qgis.PyQt.QtGui import QIcon, QColor,QBrush, QDesktopServices, QFont, QStandardItemModel, QStandardItem
from qgis.PyQt import QtWidgets 
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QDialog, QProgressBar, QApplication, QMainWindow, QDockWidget,QVBoxLayout, QHBoxLayout, QTabWidget, QLabel, QSizePolicy, QTableWidget, QTableWidgetItem, QPushButton, QTableWidget, QWidget, QComboBox, QGroupBox, QStyledItemDelegate, QListView,QButtonGroup
from qgis.core import Qgis, QgsProject, QgsVectorLayer, QgsPoint, QgsRectangle, QgsGeometry, QgsField, QgsFeature, QgsExpression, QgsCoordinateTransform, QgsCoordinateReferenceSystem, QgsApplication, QgsLayerTreeGroup, QgsLayerTreeLayer,QgsDefaultValue
from qgis.PyQt.QtCore import QVariant, QUrl
from qgis.utils import plugins, iface
from qgis.utils import qgsfunction

import warnings; warnings.filterwarnings("ignore", category=UserWarning, module="\\*")
import fiona
import geopandas as gpd
from osgeo import ogr
import os
import subprocess
import sys
import numpy as np
import shutil
import json
from xml.etree import ElementTree as ET #ADD 

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .WAXI_QF_dialog import WAXI_QFDialog
import os.path
from qgis.core import QgsRectangle, Qgis
from qgis.core.additions.edit import edit
import processing
from qgis.core import (
QgsGeometry,
QgsWkbTypes,
QgsProject,
QgsVectorLayer,
QgsVectorFileWriter,
QgsApplication,
QgsFeature,
QgsVectorDataProvider,
QgsField
)

from scipy.spatial.distance import cdist


# Libraries for manipulating Excel files 
from pandas import *

# Library for list copies
from copy import copy 

#import warnings
#warnings.simplefilter(action='ignore', category=FutureWarning)


# Library for check the input file nature
from pathlib import Path


# Importation des bibliothèques situées dans le dossier du plugin 
plugin_directory = os.path.dirname(__file__)
biblio_python_directory = os.path.join(plugin_directory, 'biblio_Python')
sys.path.append(biblio_python_directory)

class WAXI_QF:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'WAXI_QF_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&WAXI_QF')

        
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        




        ## Python library integration
        def install_library(library_name):
            try:
                subprocess.call(["python", "-m", "pip", "install", library_name])
                print(f"Successfully installed {library_name}")
            except subprocess.CalledProcessError as e:
                print(f"Error installing {library_name}: {e}")


        
        # Library Xlswriter
        try:
            import xlsxwriter
            
        except:
            self.install_library("xlsxwriter")
        
        
        # Library Openpyxl
        try:
            import openpyxl

        except:
            self.install_library("openpyxl")


        # Library FuzzyWuzzy
        try:
            import fuzzywuzzy

        except:
            self.install_library("fuzzywuzzy")
        
        # Library Geopandas
        try :    
            import geopandas 
            
        except :
            self.install_library("geopandas")
            
        # Library Fiona
        try : 
            import fiona 
            
        except :
            self.install_library("fiona")
            
     

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('WAXI_QF', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
    
        icon_path = os.path.dirname(os.path.realpath(__file__))+'/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'WAXI QF'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True



    ###############################################################################
    ####################         Page 1 : Import data            ##################
    ###############################################################################

    """
    Author: Eliott Betend
    For : WAXI Project (Stage 4) - CET 
    Condition : version de QGIS > 3.22
    """
    
    ###############################################################################
    ################# Step 0 : Check the input file nature ########################
    ###############################################################################
    
    def test_input_file_nature(chemin):
        chemin = Path(chemin)
        
        if chemin.exists():
            
           # Retrieve the file extension to determine its nature
            extension = chemin.suffix.lower()
    
            # Tests the nature of the file based on its extension
            
            if extension == ".shp" or extension == ".gpkg":
                return("Fichier Shapefile ou Geopackage")
                
            else:
                return("Fichier non compatible")
        else:
            return("Le fichier n'existe pas !")


    
    ###############################################################################
    ######## Step 1 : Check layer coordinates + Create geometry column ############
    ###############################################################################
        
    def convert_coordinates_WGS84(self, couche) :
        
        # Selection of all entities in the layer
        couche.selectAll()
    
        # Creation of a new 'Geometry' column in the layer's attribute table
        couche.startEditing()
        couche.addAttribute(QgsField("Geometry", QVariant.String))
        
        # Recuperation of CRS (Coordinate Reference System)
        crs = couche.crs()
        
        # Conversion of coordinates to WGS84
        for feature in couche.selectedFeatures():
            geometrie = feature.geometry()
    
            transformation = QgsCoordinateTransform(crs, QgsProject.instance().crs(), QgsProject.instance())
            geometrie.transform(transformation)
    
            feature["Geometry"] = geometrie.asWkt()
            couche.updateFeature(feature)
    
        # Save changes
        couche.commitChanges()
        couche.removeSelection()
    
        # Refreshing the view in QGIS
        QgsProject.instance().reloadAllLayers()
    
    
    
    
    ###############################################################################
    # Step 2 : Export the layer in Excel format + Fill Table1 with Columns pairs ##
    ###############################################################################
    
   
    def export_layer_fill_Table1 (self,couche):
        
        from openpyxl import Workbook
        from fuzzywuzzy import fuzz

        ## Two files used : 
            
        # File 1: INPUT file
        
        # Adding field names as column names to the Excel sheet
        noms_des_champs = [field.name() for field in couche.fields()]
        
        data_list = []
        
        for feature in couche.getFeatures():
            ligne = {field.name(): feature[field.name()] if feature[field.name()] is not None else "" for field in couche.fields()}
            data_list.append(ligne)
        
        # DataFrame creation from dictionary list
        input_file = DataFrame(data_list, columns=noms_des_champs)
        input_file = input_file.astype(str)
        

        # File 2: WAXI project columns
        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_files_WAXI_columns = os.path.join(os.path.dirname(WAXI_projet_path), "99. COMMAND FILES - PLUGIN/columns_reference_WAXI4.xlsx")
        
        column_reference = read_excel(emplacement_files_WAXI_columns)
     
        
        # Extraction of column names in file 1 
        list_column_input = input_file.columns.tolist()
        
        
        # Extraction of column names in file 2
        list_column_reference = column_reference.columns.tolist()
    
    
        ## Creation of column pairs (input,reference) : 
        
        # Create an empty list of column name pairs (input,reference) :
        list_couples_column=[]
        list_score=[]
        
        list_trio_columns=[]
        for k in range (0,len(list_column_input)):
            list_trio_columns.append([list_column_input[k],'NULL',0])
        
    
        # Pair creation based on similarity score 
        for k in range (0,len(list_column_input)):
            
            # Initialize similarity score and new name 
            best_column = 'NULL'
            score = 0
            
            if list_column_input[k] == 'NULL' or list_column_input[k] == ' ':
                
                list_trio_columns[k][1] = 'NULL'
                list_trio_columns[k][2] = 0
            
            for column in list_column_reference:
                
                sum_score=0
                
                # 1st part of score: comparison with column name        
                sum_score += fuzz.token_set_ratio(list_column_input[k],column)*3
                
                # 2nd part of the score: comparison with keywords associated with the column name       
                contenu_column=column_reference[column]
                for elt2 in contenu_column : 
                    sum_score += fuzz.token_set_ratio(list_column_input[k],elt2)
         
                if sum_score>score :
                    score=sum_score
                    best_column=column
                
            # Addition of the name that matched the most
            list_trio_columns[k][1] = best_column
            
            # Addition of the match score 
            list_trio_columns[k][2] = score
        
        
        
        ## Modification - Columns assigned to the same output column : 
            
        list_trio_columns_trie = list_trio_columns
        
        # We go through all the elements of list_trio_columns :  
        for place1 in range (len(list_trio_columns)-1):
            
            test = list_trio_columns[place1][1]
            
            # We compare the chosen element with all the other elements in the list to see if it is duplicated : 
            for place2 in range (len(list_trio_columns)-1):
                
                # We check that we're not taking the same element  :
                if place1 != place2:
                    
                    if test != 'NULL':
        
                        # If the chosen element has the same name as another element, we compare their similarity scores : 
                        if test == list_trio_columns[place2][1]:    
                            if list_trio_columns[place1][2] > list_trio_columns[place2][2]:
                               list_trio_columns_trie[place2][1] = 'NULL'
                               list_trio_columns_trie[place2][2] = 0
                               
                            elif list_trio_columns[place1][2] < list_trio_columns[place2][2] : 
                               list_trio_columns_trie[place1][1] = 'NULL'
                               list_trio_columns_trie[place1][2] = 0
                            
                            else : 
                                if abs(len(list_trio_columns[place1][0]) - len(list_trio_columns[place1][1])) < abs(len(list_trio_columns[place2][0]) - len(list_trio_columns[place1][1])):
                                    list_trio_columns_trie[place2][1] = 'NULL'
                                    list_trio_columns_trie[place2][2] = 0
                                
                                else : 
                                    list_trio_columns_trie[place1][1] = 'NULL'
                                    list_trio_columns_trie[place1][2] = 0
                           
                                    
    
        
        ###    Remplissage 1 : COLUMNS NAME ## input = list_trio_columns_trie     ### 


        # Setting the number of columns in the QTableWidget
        self.dlg.tableWidget1.setColumnCount(3)
        
        # Headers in the QTableWidget
        column_names1 = ["OLD Name*", 'NEW Name**', 'Check']
        self.dlg.tableWidget1.setHorizontalHeaderLabels(column_names1)
          
        current_row_count=1
       
        for k, (old, new, score) in enumerate(list_trio_columns_trie): 
                      
            if old != 'Geometry' :
                
                # Add a new row 
                self.dlg.tableWidget1.setRowCount(current_row_count)
                
                # Filling the 2 columns
                self.dlg.tableWidget1.setItem(k, 0, QTableWidgetItem(str(old)))
                self.dlg.tableWidget1.setItem(k, 1, QTableWidgetItem(str(new)))
                
                
                ### Creation of a color scale according to score : red for the lowest scores and green for the highest
                
                # Score between 0 and 100 normalized (total score of 800 for column comparison)
                score_normalized = (score/8)/100
            
            
                # Linear interpolation between red and green
                teinte = int(score_normalized * 120)
                saturation = 140
                value = 250
            
                # Color calculation using HSV color space
                color = QColor.fromHsv(teinte, saturation, value)
                
                for column in range(2):
                   item = self.dlg.tableWidget1.item(k, column)
                   if item:
                       item.setBackground(color)
                
                # Legend for color scale
                score_ranges = [0, 20, 40, 60, 80, 100]
                legend_colors = [QColor.fromHsv(12, 140, 250), QColor.fromHsv(36, 140, 250), QColor.fromHsv(60, 140, 250), QColor.fromHsv(84, 140, 250), QColor.fromHsv(108, 140, 250)]
                
                # Creation of a widget for the legend
                legendbox_layout = QVBoxLayout(self.dlg.legendbox_3)

                for i in range(len(score_ranges) - 1):
                    range_label = f"{score_ranges[i]} - {score_ranges[i + 1]}"
                    color_label = QLabel()
                    color_label.setStyleSheet(f"background-color: {legend_colors[i].name()}; border: 2px solid black;")
                    legendbox_layout.addWidget(color_label)
                    legendbox_layout.addWidget(QLabel(range_label))
                
                # Forbid editing of first 2 columns
                item1 = self.dlg.tableWidget1.item(k, 0)
                item2 = self.dlg.tableWidget1.item(k, 1)
                item1.setFlags(item1.flags() & ~Qt.ItemIsEditable)
                item2.setFlags(item2.flags() & ~Qt.ItemIsEditable)
                  

        
                # Add a column with 2 "Delete" and "Modify" buttons for each row
        
                # Creation of a widget containing the 2 buttons       
                button_widget = QWidget(self.dlg)
                
                btn_modifier = QPushButton("Edit", button_widget)
                btn_modifier.clicked.connect(lambda state, row=k: self.button_edit1(row))
                btn_modifier.setMinimumHeight(17)
      
                btn_supprimer = QPushButton("Delete", button_widget)
                btn_supprimer.clicked.connect(lambda state, row=k: self.button_delete1(row))
                btn_supprimer.setMinimumHeight(17)

                layout = QHBoxLayout(button_widget)
                layout.addWidget(btn_modifier)
                layout.addWidget(btn_supprimer)
                button_widget.setLayout(layout)
            
                self.dlg.tableWidget1.setCellWidget(k, 2, button_widget)
                
                
                # Cells size 
                
                self.dlg.tableWidget1.setRowHeight(k, 28) 
            
                self.dlg.tableWidget1.setColumnWidth(0, 160) 
                self.dlg.tableWidget1.setColumnWidth(1, 160) 
                self.dlg.tableWidget1.setColumnWidth(2, 160)   
                
                current_row_count+=1
                
                
            # Initialize cell editing status + actions performed in table
            self.row_edit_status = [False] * len(list_trio_columns_trie)
            self.table1States = []
            self.table1States.append(self.getTableState1())
        
        
        return input_file
 
             
    # Retrieve the status of all tableWidget1 cells
    def getTableState1(self):
        
        state = []
        for row in range(self.dlg.tableWidget1.rowCount()):
            row_state = []
            for col in range(2):
                item = self.dlg.tableWidget1.item(row, col)
                
                # Text
                if isinstance(item, QTableWidgetItem):
                    cell_text = item.text()
                    cell_color = item.background().color().name() if item.background().style() != Qt.NoBrush else None
                
                # ComboBox
                elif isinstance(item, QWidget):
                    combo_box = self.dlg.tableWidget1.cellWidget(row, col)
                    if isinstance(combo_box, QComboBox):
                        cell_text = combo_box.currentText()
                    else:
                        cell_text = ""
                    cell_color = item.background().color().name() if item.background().style() != Qt.NoBrush else None
                else:
                    cell_text = ""
                    cell_color = None

                cell_state = {'text': cell_text, 'color': cell_color}
                row_state.append(cell_state)
            state.append(row_state)
                
        return state


    # Delete row  
    def button_delete1(self, row):
        
        # Saving the previous state of the displayboard
        self.table1States.append(self.getTableState1())
        
        for col in range(2):
            item = self.dlg.tableWidget1.item(row, col)
            if item is not None:
                item.setText("-")
        
        combo_box_item = self.dlg.tableWidget1.cellWidget(row, 1)
        
        if isinstance(combo_box_item, QComboBox):
            combo_box_item.hide()
            combo_box_item.setCurrentText('-')
            self.dlg.tableWidget1.setCellWidget(row, 1, combo_box_item)
        
        # Prohibit editing of these cells
        item1 = self.dlg.tableWidget1.item(row, 0)
        item2 = self.dlg.tableWidget1.item(row, 1)
        item1.setFlags(item1.flags() & ~Qt.ItemIsEditable)
        item2.setFlags(item2.flags() & ~Qt.ItemIsEditable)
        
        self.dlg.tableWidget1.repaint()          
     
        
     
    
    # Modify row if column name didn't match
    def button_edit1(self, row):
        

        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_files_WAXI_columns = os.path.join(os.path.dirname(WAXI_projet_path), "99. COMMAND FILES - PLUGIN/columns_reference_WAXI4.xlsx")
        
        column_reference = read_excel(emplacement_files_WAXI_columns)
        list_column_reference = column_reference.columns.tolist()
        
        # CASE 1 : If the line has already been deleted
        if self.dlg.tableWidget1.item(row, 0).text() == "-" and self.dlg.tableWidget1.item(row, 1).text() == "-":
            return
                
        
        # CASE 2 : If the button is clicked for the 1st time
        if not self.row_edit_status[row]:
            
           
            self.table1States.append(self.getTableState1())
            
            current_text = self.dlg.tableWidget1.item(row, 1).text()
         
            combo_box = QComboBox()
            combo_box.addItems(list_column_reference)
            self.dlg.tableWidget1.setCellWidget(row, 1, combo_box)
            combo_box.setCurrentText(current_text)
            
           
            item = self.dlg.tableWidget1.item(row, 1)
            item.setFlags(item.flags() | Qt.ItemIsEditable)
            self.row_edit_status[row] = True
                  
       
        # CASE 3 : f the button is clicked for the 2nd time  
        else:
            combo_box = self.dlg.tableWidget1.cellWidget(row, 1)
            item = self.dlg.tableWidget1.item(row, 1)
            
            # ComboBox
            if isinstance(combo_box, QComboBox):
                selected_text = combo_box.currentText()
                self.dlg.tableWidget1.removeCellWidget(row, 1)
            
            # Text
            else:
                selected_text = item.text()    
            
            item.setText(selected_text)
            
            table_state = self.getTableState1()
            cell_state = table_state[row][1]
            original_color = QColor(cell_state['color'])
            item.setBackground(original_color)
            
            item.setFlags(item.flags() & ~Qt.ItemIsEditable)
            self.row_edit_status[row] = False
                
        self.dlg.tableWidget1.repaint()
    
        

    # Come Back 
    def Go_Back_table1(self):
        
        if self.table1States:
            previousState = self.table1States.pop()
            for row, row_state in enumerate(previousState):
                for col, cell in enumerate(row_state):
                    # texte de la cellule 
                    cell_text = cell['text']
                    item = self.dlg.tableWidget1.item(row, col)
                    item.setText(cell_text)
                    
                    # couleur de la cellule 
                    cell_color = cell['color']
                    if cell_color:
                        item.setBackground(QColor(cell_color))
                     
        else:
            self.iface.messageBar().pushMessage("No previous action !", level=Qgis.Warning, duration=45) 

    

    # Content retrieval of QTableWidget 1 : COLUMNS NAMES CHECK  ## 
    def recup_contenu_1(self): 
        
        list_columns_check_OK = []
        new_values_count = {}

        for row in range(self.dlg.tableWidget1.rowCount()):
            old = self.dlg.tableWidget1.item(row, 0).text()
            
            if old != '-': 
                
                if isinstance(self.dlg.tableWidget1.cellWidget(row, 1), QComboBox):
                    new = self.dlg.tableWidget1.cellWidget(row, 1).currentText()
                else:
                    new = self.dlg.tableWidget1.item(row, 1).text()
    
                if new != 'NULL':
                    if new in new_values_count:
                        self.iface.messageBar().pushMessage("Erreur: La valeur '{}' est en double !".format(new), level=Qgis.Warning, duration=45) 
                        return
                    
                    new_values_count[new] = 1
                    
                    list_columns_check_OK.append([old, new])
    
        list_columns_check_OK.append(['Geometry', 'Geometry'])
        
        return list_columns_check_OK
        

        
    ###############################################################################
    ##########    Step 4 : Creation of a DataFrame sorted and checked      ########
    ###############################################################################   
     
    def DataFrame_columns_check (self, input_file, list_columns_check, name_input_file): 
        
       # Sort list_columns_check to remove unrecognized peers (NULL) :
        list_columns_check2 = []
        list_new=[]
        for k in range (len(list_columns_check)):
            if list_columns_check[k][1] not in list_new :
                if list_columns_check[k][1] !='NULL' :
                    list_columns_check2.append(list_columns_check[k])
                    list_new = list_columns_check[k][1]
            else : 
                self.iface.messageBar().pushMessage("Two or more of your old columns have been assigned to the same new column name, this is not possible !", level=Qgis.Warning, duration=45) 
                
        # Creation of a DataFrame = OUTPUT file 
        fichier_output = DataFrame()
        list_columns_check3=[]
        
        # Add all the values
        for k in range(len(list_columns_check2)):
            try : 
                nom_colonne_input = list_columns_check2[k][0]
                nom_colonne_output = list_columns_check2[k][1]
                
                fichier_output[nom_colonne_output] = input_file[nom_colonne_input]
                list_columns_check3.append(nom_colonne_output)
                
            except KeyError:
                pass
                
            
        # Add a column to specify Geographic Coordinates Reference System
        fichier_output['CRS']= 'WSG84_EPSG:4326'
        list_columns_check3.append('CRS')
        
        
        # Add a column to specify INPUT file name  
        fichier_output['Source'] = name_input_file.split('.')[0] 
        list_columns_check3.append('Source')
        
        # Add a column for RAW DATA
        fichier_output['Existing databases - raw data'] = None
        list_columns_check3.append('Existing databases - raw data')
        
        for index, row in input_file.iterrows():
            ligne_raw_data = []
            
            for column, value in row.items():
                if str(column) != "Geometry":
                    ligne_raw_data.append(f"{column} : {value} ; ")
            fichier_output.at[index, 'Existing databases - raw data'] = ''.join(ligne_raw_data)
    
    
        return fichier_output, list_columns_check3
    
    
    
    
    ###############################################################################
    ###########    Step 5 : Fill Table2 with Lithologies pairs     ################
    ###############################################################################  
    
    
    def fill_Table2 (self, fichier_output):
        
        from openpyxl import Workbook
        from fuzzywuzzy import fuzz
        
        # List of input lithologies 
        list_lithology_input = fichier_output['Litho'].tolist()

        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_99_CSV_files = os.path.join(os.path.dirname(WAXI_projet_path), "0. FIELD DATA/99. CSV FILES/")
        
        
        # Reference list of lithologies
        if os.path.exists(emplacement_99_CSV_files):
            fichier_reference = read_csv(emplacement_99_CSV_files +'Lithologies.csv', sep=';')
            list_lithology_reference = list(fichier_reference['Valeur'])
        
        else:
            self.iface.messageBar().pushMessage("Layer not found: "+ emplacement_99_CSV_files, level=Qgis.Warning, duration=45) 
   
    
        # Empty list of lithology name pairs (input value, reference value)
        list_trio=[]
        for k in range (0,len(list_lithology_input)):
            list_trio.append([list_lithology_input[k],'NULL',0])
        
        
        # Identification with Fuzzywuzzy :  
        for k in range (0,len(list_lithology_input)) : 
            
            # Initialize similarity score and new name 
            score=0
            new_rock_name = 'NULL'
            
            if list_lithology_input[k] == 'NULL' or list_lithology_input[k] == ' ':
                
                list_trio[k][1] = 'NULL'
                list_trio[k][2] = 0
            
            else : 
            
                ## Condition 1 : prefix leuco, micro and meta to be deleted in front of names
                
                if list_lithology_input[k].startswith("Micro"):
                    # prefix 'micro-'
                    list_lithology_input[k] =  list_lithology_input[k][5:]
             
                
                if list_lithology_input[k][0] == "L" and list_lithology_input[k][1] == "e" and list_lithology_input[k][2] == "u" and list_lithology_input[k][3] == "c" and list_lithology_input[k][4] == "o" : 
                    # prefix 'leuco-'
                    list_lithology_input[k] =  list_lithology_input[k][5:]
                
                
                if list_lithology_input[k][0] == "M" and list_lithology_input[k][1] == "e" and list_lithology_input[k][2] == "t" and list_lithology_input[k][3] == "a" : 
                    # prefix 'meta-'
                    list_lithology_input[k] =  list_lithology_input[k][4:]
                
                
                if list_lithology_input[k][0] == "M" and list_lithology_input[k][1] == "é" and list_lithology_input[k][2] == "t" and list_lithology_input[k][3] == "a" : 
                    # prefix 'méta'
                    list_lithology_input[k] =  list_lithology_input[k][4:]
                   
                    
                 ## Condition 2 : often used words "pegmatite" or "granitoid" replace them with "granite"
                if list_lithology_input[k] == "pegmatite" or list_lithology_input[k] == "granitoid" :
                    list_lithology_input[k] = "granite"
        
        
                for rock_reference in list_lithology_reference :
                
                    new_score = fuzz.token_set_ratio(list_lithology_input[k], rock_reference)
                    
                    # If the 2 words don't begin with the same letter : -15 penalty on the score
                    if list_lithology_input[k][0].lower() != rock_reference[0].lower():
                        new_score  = new_score-15
                   
                    if new_score > score :  
                        score = new_score
                        new_rock_name = rock_reference
           
                # Add the name that matched the most
                list_trio[k][1] = new_rock_name
                
                # Add match score
                list_trio[k][2] = score
            
       
        # Creation of a lithology checklist for the user 
        
        list_old = []
        list_new = []
        list_score=[]
        list_trio_unique=[]
        list_old_unique = []
        for m in range (len(list_trio)):
            list_old.append(list_trio[m][0])
            list_new.append(list_trio[m][1])
            list_score.append(list_trio[m][2])
        
        for m in range (len(list_trio)):
            if list_old[m] not in list_old_unique: 
                list_old_unique.append(list_old[m])
                list_trio_unique.append([list_old[m],list_new[m],list_score[m]])

        



        ###    Filling 2 : LITHOLOGIES NAME ## input = list_couple     ### 
          
        # Setting the number of columns in the QTableWidget
        self.dlg.tableWidget2.setColumnCount(3)
        
        # Headers of the QTableWidget
        column_names2 = ["OLD Name*", 'NEW Name**', 'Check']
        self.dlg.tableWidget2.setHorizontalHeaderLabels(column_names2)
        
        # Re-organizing the list by descending score 
        list_trio_unique = sorted(list_trio_unique, key=lambda x: x[2], reverse=False)
        current_row_count=1
       
        for k, (old, new, score) in enumerate(list_trio_unique): 
                      
            # Add a new row
            self.dlg.tableWidget2.setRowCount(current_row_count)
            
            # Filling the 2 columns
            self.dlg.tableWidget2.setItem(k, 0, QTableWidgetItem(str(old)))
            self.dlg.tableWidget2.setItem(k, 1, QTableWidgetItem(str(new)))
            
            
            ### Creation of a color scale according to score: red for the lowest scores and green for the highest
            
            # Score between 0 and 100 normalized
            score_normalized = score / 100
        
            # Linear interpolation between red and green
            teinte = int(score_normalized * 120)
            saturation = 140
            value = 250
        
            # Color calculation using HSV color space
            color = QColor.fromHsv(teinte, saturation, value)
            
            for column in range(2):
               item = self.dlg.tableWidget2.item(k, column)
               if item:
                   item.setBackground(color)
            
            # Legend for color scale
            score_ranges = [0, 20, 40, 60, 80, 100]
            legend_colors = [QColor.fromHsv(12, 140, 250), QColor.fromHsv(36, 140, 250), QColor.fromHsv(60, 140, 250), QColor.fromHsv(84, 140, 250), QColor.fromHsv(108, 140, 250)]
            
            # Creation of a widget for the caption
            legendbox_layout = QVBoxLayout(self.dlg.legendbox)

            for i in range(len(score_ranges) - 1):
                range_label = f"{score_ranges[i]} - {score_ranges[i + 1]}"
                color_label = QLabel()
                color_label.setStyleSheet(f"background-color: {legend_colors[i].name()}; border: 2px solid black;")
                legendbox_layout.addWidget(color_label)
                legendbox_layout.addWidget(QLabel(range_label))
            
            # Forbid editing of first 2 columns
            item1 = self.dlg.tableWidget2.item(k, 0)
            item2 = self.dlg.tableWidget2.item(k, 1)
            item1.setFlags(item1.flags() & ~Qt.ItemIsEditable)
            item2.setFlags(item2.flags() & ~Qt.ItemIsEditable)
              
    
            # Add a column with "Delete" and "Modify" buttons for each row
      
            button_widget = QWidget(self.dlg)
            
            btn_modifier = QPushButton("Edit", button_widget)
            btn_modifier.clicked.connect(lambda state, row=k: self.button_edit2(row))
            btn_modifier.setMinimumHeight(17)
      
            btn_supprimer = QPushButton("Delete", button_widget)
            btn_supprimer.clicked.connect(lambda state, row=k: self.button_delete2(row))
            btn_supprimer.setMinimumHeight(17)
            
            layout = QHBoxLayout(button_widget)
            layout.addWidget(btn_modifier)
            layout.addWidget(btn_supprimer)
            button_widget.setLayout(layout)
        
            self.dlg.tableWidget2.setCellWidget(k, 2, button_widget)
            
            # Cells size
            
            self.dlg.tableWidget2.setRowHeight(k, 28) 
        
            self.dlg.tableWidget2.setColumnWidth(0, 150) 
            self.dlg.tableWidget2.setColumnWidth(1, 150) 
            self.dlg.tableWidget2.setColumnWidth(2, 150)   
            
            current_row_count+=1
            
            
        # Initialize cell editing status + actions performed in table 
        self.row_edit_status = [False] * len(list_trio_unique)
        self.table2States = []
        self.table2States.append(self.getTableState2())
    
 

        
    # Retrieve the status of all tableWidget2 cells
    def getTableState2(self):
        state2 = []
        for row in range(self.dlg.tableWidget2.rowCount()):
            row_state = []
            for col in range(2):
                item = self.dlg.tableWidget2.item(row, col)
                
                # Text
                if isinstance(item, QTableWidgetItem):
                    cell_text = item.text()
                    cell_color = item.background().color().name() if item.background().style() != Qt.NoBrush else None
                
                # ComboBox
                elif isinstance(item, QWidget):
                    combo_box = self.dlg.tableWidget2.cellWidget(row, col)
                    if isinstance(combo_box, QComboBox):
                        cell_text = combo_box.currentText()
                    else:
                        cell_text = ""
                    cell_color = item.background().color().name() if item.background().style() != Qt.NoBrush else None
                else:
                    cell_text = ""
                    cell_color = None

                cell_state = {'text': cell_text, 'color': cell_color}
                row_state.append(cell_state)
            state2.append(row_state)
        return state2

   
    # Delete row
    def button_delete2(self, row):
        
        self.table2States.append(self.getTableState2())
        
        for col in range(2):
            item = self.dlg.tableWidget2.item(row, col)
            if item is not None:
                item.setText("-")
        
        combo_box_item = self.dlg.tableWidget2.cellWidget(row, 1)
        
        if isinstance(combo_box_item, QComboBox):
            combo_box_text = combo_box_item.currentText()          
            combo_box_item.hide()
            combo_box_item.setCurrentText('-')
            self.dlg.tableWidget2.setCellWidget(row, 1, combo_box_item)
             

        item1 = self.dlg.tableWidget2.item(row, 0)
        item2 = self.dlg.tableWidget2.item(row, 1)
        item1.setFlags(item1.flags() & ~Qt.ItemIsEditable)
        item2.setFlags(item2.flags() & ~Qt.ItemIsEditable)
        
        self.dlg.tableWidget2.repaint()


   

    # Modify row 
    def button_edit2(self, row):

        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_99_CSV_files = os.path.join(os.path.dirname(WAXI_projet_path), "0. FIELD DATA/99. CSV FILES/")
        
        # List Litho Metamorphic lithologies_PT
        if os.path.exists(emplacement_99_CSV_files):
            fichier_reference = read_csv(emplacement_99_CSV_files +'Metamorphic lithologies.csv', sep=';')
            list_litho_metamorphic = list(fichier_reference['Valeur'])
            list_litho_metamorphic.sort()
        else:
            self.iface.messageBar().pushMessage("Layer not found: "+ emplacement_99_CSV_files, level=Qgis.Warning, duration=45) 
        
        # List Litho Igneous intrusive lithologies_PT
        if os.path.exists(emplacement_99_CSV_files):
            fichier_reference1 = read_csv(emplacement_99_CSV_files +'Plutonic lithologies.csv', sep=';')
            list_litho_plutonic = list(fichier_reference1['Valeur'])
            list_litho_plutonic.sort()
            
        # List Litho Igneous extrusive lithologies_PT
        if os.path.exists(emplacement_99_CSV_files):
            fichier_reference2 = read_csv(emplacement_99_CSV_files +'Volcanic lithologies.csv', sep=';')
            list_litho_volcanic = list(fichier_reference2['Valeur'])
            list_litho_volcanic.sort()
        
        # List Litho Volcanoclastic lithologies_PT
        if os.path.exists(emplacement_99_CSV_files):
            fichier_reference3 = read_csv(emplacement_99_CSV_files +'Volcanoclastic lithologies.csv', sep=';')
            list_litho_volcanoclastic = list(fichier_reference3['Valeur'])
            list_litho_volcanoclastic.sort()
        
        # List Litho Sedimentary lithologies_PT
        if os.path.exists(emplacement_99_CSV_files):
            fichier_reference4 = read_csv(emplacement_99_CSV_files +'Sedimentary lithologies.csv', sep=';')
            list_litho_sedimentary = list(fichier_reference4['Valeur'])
            list_litho_sedimentary.sort()
        
        # List Litho Supergene lithologies_PT
        if os.path.exists(emplacement_99_CSV_files):
            fichier_reference5 = read_csv(emplacement_99_CSV_files +'Supergene lithologies.csv', sep=';')
            list_litho_supergene = list(fichier_reference5['Valeur'])
            list_litho_supergene.sort()
        
        
        # CASE 1 : If the line has already been deleted
        if self.dlg.tableWidget2.item(row, 0).text() == "-" and self.dlg.tableWidget2.item(row, 1).text() == "-":
            return
           
        
        # CASE 2 : If the button is clicked for the 1st time
        if not self.row_edit_status[row]:
            
            self.table2States.append(self.getTableState2())
            
            current_text = self.dlg.tableWidget2.item(row, 1).text()
            
            rock_types = {"      ---Plutonic---      ": list_litho_plutonic,"      ---Volcanic---      ":list_litho_volcanic, 
                          "      ---Sedimentary---      ": list_litho_sedimentary, "      ---Metamorphic---      ": list_litho_metamorphic,
                          "       ---Supergene---      ":list_litho_supergene, "      ---Volcanoclastic---      ":list_litho_volcanoclastic}
            
            combo_box = QComboBox()
            delegate = QStyledItemDelegate(combo_box)
            combo_box.setItemDelegate(delegate)
            
            for rock_type, rock_names in rock_types.items():
                combo_box.addItem(rock_type)
                combo_box.setItemData(combo_box.count() - 1, QFont("Bookman Old Style", 10, QFont.Bold), Qt.FontRole)
                combo_box.setItemData(combo_box.count() - 1, False,  Qt.UserRole)
                
                for rock_name in rock_names:
                    combo_box.addItem(rock_name)
            
            # Deactivation of rock type selection
            elements_combobox = [combo_box.itemText(i) for i in range(combo_box.count())]
            for i in range(len(elements_combobox)):
                list_type = ["      ---Plutonic---      ","      ---Volcanic---      ","      ---Sedimentary---      ", "      ---Metamorphic---      ","       ---Supergene---      ", "      ---Volcanoclastic---      " ]
                if elements_combobox[i] in list_type :
                    combo_box.model().item(i).setEnabled(False)
                
                    
            self.dlg.tableWidget2.setCellWidget(row, 1, combo_box)
            combo_box.setCurrentText(current_text)
            
            item = self.dlg.tableWidget2.item(row, 1)
            item.setFlags(item.flags() | Qt.ItemIsEditable)
            self.row_edit_status[row] = True
    
 
        # CASE 3 : If the button is clicked for the 2nd time 
        else:   
            
            combo_box = self.dlg.tableWidget2.cellWidget(row, 1)
            item = self.dlg.tableWidget2.item(row, 1)
            
            # ComboBox
            if isinstance(combo_box, QComboBox):
                selected_text = combo_box.currentText()
                self.dlg.tableWidget2.removeCellWidget(row, 1)
            
            # Text
            else:
                selected_text = item.text()    
            
            item.setText(selected_text)
            
            table_state = self.getTableState2()
            cell_state = table_state[row][1]
            original_color = QColor(cell_state['color'])
            item.setBackground(original_color)
            
            item.setFlags(item.flags() & ~Qt.ItemIsEditable)
            self.row_edit_status[row] = False
                
        self.dlg.tableWidget2.repaint()
    
    
    # Come back 
    def Go_Back_table2(self):
        
        if self.table2States:
            previousState = self.table2States.pop()
            for row, row_state in enumerate(previousState):
                for col, cell in enumerate(row_state):
                 
                    cell_text = cell['text']
                    item = self.dlg.tableWidget2.item(row, col)
                    item.setText(cell_text)
                    
                    cell_color = cell['color']
                    if cell_color:
                        item.setBackground(QColor(cell_color))
                        
        else:
            self.iface.messageBar().pushMessage("No previous action !", level=Qgis.Warning, duration=45) 

    
    ## Retrieving QTableWidget 2 content : LITHOLOGIES NAMES CHECK  ## 
    
    def recup_contenu_2(self): 
        
        list_lithologies_unique_check_OK = []
        
        for row in range(self.dlg.tableWidget2.rowCount()):
            old = self.dlg.tableWidget2.item(row, 0).text()
            
            if old != '-': 
                if isinstance(self.dlg.tableWidget2.cellWidget(row, 1), QComboBox):
                    new = self.dlg.tableWidget2.cellWidget(row, 1).currentText()
                else:
                    new = self.dlg.tableWidget2.item(row, 1).text()
        
                list_lithologies_unique_check_OK.append([old, new])
        
        
        return list_lithologies_unique_check_OK
        
    
    ###############################################################################
    ###        Step 7 : Lithologies sorting in differents Excel sheets          ###
    ###############################################################################     
      
 
    def lithologies_sorting (self,fichier_output, list_columns_check3, list_lithologies_unique_check_OK, name_input_file):  
        
        from openpyxl import Workbook
        from fuzzywuzzy import fuzz
        
        # Add lithologies to Excel file
        
        list_old = []
        for k in range (len(list_lithologies_unique_check_OK)):
            list_old.append(list_lithologies_unique_check_OK[k][0])
            
        
        fichier_output = fichier_output[fichier_output['Litho'].isin(list_old)]
        fichier_output = fichier_output.reset_index(drop=True)
        
        # We browse the column containing the old lithos in file_output
        for m in range (1,len(fichier_output['Litho'])):

            # We browse the list of unique (old, new) pairs verified by the user
            for k in range (len(list_lithologies_unique_check_OK)):
   
                if fichier_output['Litho'].iloc[m] == list_lithologies_unique_check_OK[k][0]:
                    fichier_output['Litho'].iloc[m] = list_lithologies_unique_check_OK[k][1]

     
        ### Sorting lithologies ### 
        
        # Lists of reference rocks from the WAXI4 QGIS project
        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_99_CSV_files = os.path.join(os.path.dirname(WAXI_projet_path), "0. FIELD DATA/99. CSV FILES/")
        
        litho_local = list((read_csv(emplacement_99_CSV_files +'Local lithologies.csv', sep=';'))['Valeur'])
        litho_supergene = list((read_csv(emplacement_99_CSV_files +'Supergene lithologies.csv', sep=';'))['Valeur'])
        litho_sedimentary = list((read_csv(emplacement_99_CSV_files +'Sedimentary lithologies.csv', sep=';'))['Valeur'])
        litho_volcanoclastic = list((read_csv(emplacement_99_CSV_files +'Volcanoclastic lithologies.csv', sep=';'))['Valeur'])
        litho_igneous_extrusive = list((read_csv(emplacement_99_CSV_files +'Volcanic lithologies.csv', sep=';'))['Valeur'])
        litho_igneous_intrusive = list((read_csv(emplacement_99_CSV_files +'Plutonic lithologies.csv', sep=';'))['Valeur'])
        litho_metamorphic = list((read_csv(emplacement_99_CSV_files +'Metamorphic lithologies.csv', sep=';'))['Valeur'])
        
        
        ### Creation of the output Workbook ###
        
        fichier_output_lithology = Workbook()
        project = QgsProject.instance()
        
        worksheets_lithology = ["Local lithologies_PT","Supergene lithologies_PT", "Sedimentary lithologies_PT",
                                "Volcanoclastic lithologies_PT","Igneous extrusive lithologies_PT", "Igneous intrusive lithologies_PT",
                                "Metamorphic lithologies_PT"]
        
        for k in range (len(worksheets_lithology)):

            # Retrieving the reference layer in QGIS
            layer = project.mapLayersByName(worksheets_lithology[k])[0]
    
            # Retrieve field names from the attribute table for this layer
            header = [str(field.name()) for field in layer.fields()]
        
            # Creation of the worksheet 
            name_worksheet1 = worksheets_lithology[k] +'_'+ name_input_file
            litho_output = fichier_output_lithology.create_sheet(name_worksheet1.split('.')[0]) 
            litho_output.append(header)
    
        
        for k in range(0,len(fichier_output['Litho'])):
            
            r = fichier_output['Litho'][k]
            
            # litho_local : 
            if r in litho_local and r != 'Unknown' :
                
                header_local=[col[0].value for col in fichier_output_lithology[("Local lithologies_PT_"+ name_input_file).split('.')[0]].iter_cols(min_row=1, max_row=1)]
                ligne = []
                
                for col_reference in (header_local):
                    if col_reference not in list_columns_check3 :
                        ligne.append('')
                    else:
                        ligne.append(fichier_output[col_reference][k])
                
                fichier_output_lithology[("Local lithologies_PT_"+ name_input_file).split('.')[0]].append(ligne)
                                
                
            # litho_supergene : 
            elif r in litho_supergene and r != 'Unknown' :
                
                header_supergene=[col[0].value for col in fichier_output_lithology[("Supergene lithologies_PT_"+ name_input_file).split('.')[0]].iter_cols(min_row=1, max_row=1)]
                ligne = []
          
                for col_reference in (header_supergene):
                    if col_reference not in list_columns_check3 : 
                        ligne.append('')
                    else:
                        ligne.append(fichier_output[col_reference][k])
    
                fichier_output_lithology[("Supergene lithologies_PT_"+ name_input_file).split('.')[0]].append(ligne)
                
                
            # litho_sedimentary : 
            elif r in litho_sedimentary and r != 'Unknown' :
                
                header_sedimentary=[col[0].value for col in fichier_output_lithology[("Sedimentary lithologies_PT_"+ name_input_file).split('.')[0]].iter_cols(min_row=1, max_row=1)]
                ligne = []
        
                for col_reference in (header_sedimentary):
                     if col_reference not in list_columns_check3 : 
                         ligne.append('')
                     else:
                         ligne.append(fichier_output[col_reference][k])
                
                fichier_output_lithology[("Sedimentary lithologies_PT_"+ name_input_file).split('.')[0]].append(ligne)
            
            
        
            # litho_volcanoclastic : 
            elif r in litho_volcanoclastic and r != 'Unknown' :
                
                header_volcanoclastic=[col[0].value for col in fichier_output_lithology[("Volcanoclastic lithologies_PT_"+ name_input_file).split('.')[0]].iter_cols(min_row=1, max_row=1)]
                ligne = [] 
        
                for col_reference in (header_volcanoclastic):
                    if col_reference not in list_columns_check3 :
                        ligne.append('')
                    else:
                        ligne.append(fichier_output[col_reference][k])
                
                fichier_output_lithology[("Volcanoclastic lithologies_PT_"+ name_input_file).split('.')[0]].append(ligne)
                    
                
            # litho_volcanic : 
            elif r in litho_igneous_extrusive and r != 'Unknown' :
                
                header_volcanic=[col[0].value for col in fichier_output_lithology[("Igneous extrusive lithologies_PT_"+ name_input_file).split('.')[0]].iter_cols(min_row=1, max_row=1)]
                ligne = [] 
        
                for col_reference in (header_volcanic):
                    if col_reference not in list_columns_check3 :
                        ligne.append('')
                    else:
                        ligne.append(fichier_output[col_reference][k])
                
                fichier_output_lithology[("Igneous extrusive lithologies_PT_"+ name_input_file).split('.')[0]].append(ligne)
    
                
            # litho_plutonic : 
            elif r in litho_igneous_intrusive and r != 'Unknown' :
                
                header_plutonic=[col[0].value for col in fichier_output_lithology[("Igneous intrusive lithologies_PT_"+ name_input_file).split('.')[0]].iter_cols(min_row=1, max_row=1)]
                ligne = []
        
                for col_reference in (header_plutonic):
                    if col_reference not in list_columns_check3 :
                        ligne.append('')
                    else:
                        ligne.append(fichier_output[col_reference][k])
                
                fichier_output_lithology[("Igneous intrusive lithologies_PT_"+ name_input_file).split('.')[0]].append(ligne)
    
    
            # litho_metamorphic : 
            elif r in litho_metamorphic and r != 'Unknown' :
               
                header_metamorphic =[col[0].value for col in fichier_output_lithology[("Metamorphic lithologies_PT_"+ name_input_file).split('.')[0]].iter_cols(min_row=1, max_row=1)]
                ligne = []     
                
                for col_reference in (header_metamorphic):
                    if col_reference not in list_columns_check3 :
                        ligne.append('')
                    else:
                        ligne.append(fichier_output[col_reference][k])
                        
                fichier_output_lithology[("Metamorphic lithologies_PT_"+ name_input_file).split('.')[0]].append(ligne)
                     
        
        return fichier_output_lithology
    
     
    
    ###############################################################################
    ###########    Step 8 : Fill Table3 with Structure pairs       ################
    ###############################################################################  
    
    
    def fill_Table3 (self, fichier_output):
        
        from openpyxl import Workbook
        from fuzzywuzzy import fuzz
        
        # List of input structures
        list_structure_input = fichier_output['Structure_type'].tolist()
           
        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_files_WAXI_columns = os.path.join(os.path.dirname(WAXI_projet_path), "99. COMMAND FILES - PLUGIN/columns_types_structures_WAXI4.xlsx")
        
        Dataframe = read_excel(emplacement_files_WAXI_columns)
        list_structure_reference = Dataframe.columns.tolist()
        
        
        # Empty list of structure name pairs (input value, reference value)    

        list_trio_struct=[]
        for k in range (0,len(list_structure_input)):
            list_trio_struct.append([list_structure_input[k],'NULL',0])
        
        
        # Structure_type column modified to conform
        for k in range(0,len(list_structure_input)):
            
            type_structure = list_structure_input[k]
            
            if type_structure == 'NULL' or type_structure == ' ':
                
                list_trio_struct[k][1] = 'NULL'
                list_trio_struct[k][2] = 0
            
            else : 
                score = 0
                structure = 'NULL'
                    
                # Go through all the boxes in the Excel file to determine the type of structures
                for index, row in Dataframe.iloc[1:].iterrows():
                    for colonne, valeur in row.items():
                        
                        new_score = fuzz.token_set_ratio(type_structure, valeur)
                        
                        if new_score > score : 
                            score = new_score
                            structure = colonne
                    
                    
                if score<50 and ('vein' in type_structure or 'veins' in type_structure) : 
                    list_trio_struct[k][1] = 'Veins_PT'
                    list_trio_struct[k][2] = 90
                    
                else :     
                    list_trio_struct[k][1] = structure 
                    list_trio_struct[k][2] = score
            
       
        # Create a structure checklist for the user  
        
        list_old2 = []
        list_new2 = []
        list_score2=[]
        list_trio_unique2=[]
        list_old_unique2 = []
        for m in range (len(list_trio_struct)):
            list_old2.append(list_trio_struct[m][0])
            list_new2.append(list_trio_struct[m][1])
            list_score2.append(list_trio_struct[m][2])
        
        for m in range (len(list_trio_struct)):
            if list_old2[m] not in list_old_unique2: 
                list_old_unique2.append(list_old2[m])
                list_trio_unique2.append([list_old2[m],list_new2[m],list_score2[m]])

        
 
             
        ###    Filling 3 : STRCUTURE NAME ## input = list_trio_unique2     ### 
 
        # Setting the number of columns in the QTableWidget
        self.dlg.tableWidget3.setColumnCount(3)
        
        # Headers of the QTableWidget
        column_names3 = ["OLD Name*", 'NEW Name**', 'Check']
        self.dlg.tableWidget3.setHorizontalHeaderLabels(column_names3)
          
        # Re-organize list by descending score 
        list_trio_unique2 = sorted(list_trio_unique2, key=lambda x: x[2], reverse=False)
        current_row_count=1
        
        for k, (old, new, score) in enumerate(list_trio_unique2): 
                      
            # Add a row
            self.dlg.tableWidget3.setRowCount(current_row_count)

            self.dlg.tableWidget3.setItem(k, 0, QTableWidgetItem(str(old)))
            self.dlg.tableWidget3.setItem(k, 1, QTableWidgetItem(str(new)))
            
            ### Creation of a color scale according to score : red for the lowest scores and green for the highest
            
            # Score between 0 and 100 normalized
            score_normalized = score / 100
        
            # Linear interpolation between red and green
            teinte = int(score_normalized * 120)
            saturation = 140
            value = 250
        
            # Color calculation using HSV color space
            color = QColor.fromHsv(teinte, saturation, value)
            
            for column in range(2):
               item2 = self.dlg.tableWidget3.item(k, column)
               if item2:
                   item2.setBackground(color)
            
            # Legend for color scale
            score_ranges = [0, 20, 40, 60, 80, 100]
            legend_colors = [QColor.fromHsv(12, 140, 250), QColor.fromHsv(36, 140, 250), QColor.fromHsv(60, 140, 250), QColor.fromHsv(84, 140, 250), QColor.fromHsv(108, 140, 250)]
         
            # Create a widget for the legend
            legendbox_layout2 = QVBoxLayout(self.dlg.legendbox_2)

            # Add labels with colors and score ranges
            for i in range(len(score_ranges) - 1):
                range_label = f"{score_ranges[i]} - {score_ranges[i + 1]}"
                color_label = QLabel()
                color_label.setStyleSheet(f"background-color: {legend_colors[i].name()}; border: 2px solid black;")
                legendbox_layout2.addWidget(color_label)
                legendbox_layout2.addWidget(QLabel(range_label))
            
            
            # Forbid editing of first 2 columns
            item1 = self.dlg.tableWidget3.item(k, 0)
            item2 = self.dlg.tableWidget3.item(k, 1)
            item1.setFlags(item1.flags() & ~Qt.ItemIsEditable)
            item2.setFlags(item2.flags() & ~Qt.ItemIsEditable)
  
    
            # Add a column with "Delete" and "Modify" buttons for each row
      
            button_widget = QWidget(self.dlg)
            
            btn_modifier = QPushButton("Edit", button_widget)
            btn_modifier.clicked.connect(lambda state, row=k: self.button_edit3(row))
            btn_modifier.setMinimumHeight(17)
       
            btn_supprimer = QPushButton("Delete", button_widget)
            btn_supprimer.clicked.connect(lambda state, row=k: self.button_delete3(row))
            btn_supprimer.setMinimumHeight(17)

            layout = QHBoxLayout(button_widget)
            layout.addWidget(btn_modifier)
            layout.addWidget(btn_supprimer)
            button_widget.setLayout(layout)
        
            self.dlg.tableWidget3.setCellWidget(k, 2, button_widget)
            
            # Cells size 
            
            self.dlg.tableWidget3.setRowHeight(k, 28) 
        
            self.dlg.tableWidget3.setColumnWidth(0, 150) 
            self.dlg.tableWidget3.setColumnWidth(1, 150) 
            self.dlg.tableWidget3.setColumnWidth(2, 150)
           
            current_row_count += 1
            
        # Initialize cell editing status + actions performed in table
        self.row_edit_status = [False] * len(list_trio_unique2)
        self.table3States = []
        self.table3States.append(self.getTableState3())
 
        
    # Retrieve the status of all tableWidget3 cells
    def getTableState3(self):
        
        state3 = []
        for row in range(self.dlg.tableWidget3.rowCount()):
            row_state = []
            for col in range(2):
                item = self.dlg.tableWidget3.item(row, col)
                
                # Text
                if isinstance(item, QTableWidgetItem):
                    cell_text = item.text()
                    cell_color = item.background().color().name() if item.background().style() != Qt.NoBrush else None
                
                # ComboBox
                elif isinstance(item, QWidget):
                    combo_box = self.dlg.tableWidget3.cellWidget(row, col)
                    if isinstance(combo_box, QComboBox):
                        cell_text = combo_box.currentText()
                    else:
                        cell_text = ""
                    cell_color = item.background().color().name() if item.background().style() != Qt.NoBrush else None
                else:
                    cell_text = ""
                    cell_color = None

                cell_state = {'text': cell_text, 'color': cell_color}
                row_state.append(cell_state)
            state3.append(row_state)
                
        return state3

   

    # Delete row
    def button_delete3(self, row):
        
        self.table3States.append(self.getTableState3())
        
        for col in range(2):
            item = self.dlg.tableWidget3.item(row, col)
            if item is not None:
                item.setText("-")
        
        combo_box_item = self.dlg.tableWidget3.cellWidget(row, 1)
        
        if isinstance(combo_box_item, QComboBox):
            combo_box_item.hide()
            combo_box_item.setCurrentText('-')
            self.dlg.tableWidget3.setCellWidget(row, 1, combo_box_item)
            
        item1 = self.dlg.tableWidget3.item(row, 0)
        item2 = self.dlg.tableWidget3.item(row, 1)
        item1.setFlags(item1.flags() & ~Qt.ItemIsEditable)
        item2.setFlags(item2.flags() & ~Qt.ItemIsEditable)
        
        self.dlg.tableWidget3.repaint()
  
    

    # Modify row 
    def button_edit3(self, row):
 
        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_files_WAXI_columns = os.path.join(os.path.dirname(WAXI_projet_path), "99. COMMAND FILES - PLUGIN/columns_types_structures_WAXI4.xlsx")
        
        Dataframe = read_excel(emplacement_files_WAXI_columns)
        list_structure_reference = Dataframe.columns.tolist()
        
        # CASE 1 : If the row has already been deleted 
        if self.dlg.tableWidget3.item(row, 0).text() == "-" and self.dlg.tableWidget3.item(row, 1).text() == "-":
            return
    
        
        # CASE 2 : If the button is clicked for the 1st time
        if not self.row_edit_status[row]:

            self.table3States.append(self.getTableState3())
            
            current_text = self.dlg.tableWidget3.item(row, 1).text()
              
            combo_box = QComboBox()
            combo_box.addItems(list_structure_reference)
            self.dlg.tableWidget3.setCellWidget(row, 1, combo_box)
            combo_box.setCurrentText(current_text)
            
          
            item = self.dlg.tableWidget3.item(row, 1)
            item.setFlags(item.flags() | Qt.ItemIsEditable)
            self.row_edit_status[row] = True
            
       
        # CASE 3 : If the button is clicked for the 2nd time 
        else:
            combo_box = self.dlg.tableWidget3.cellWidget(row, 1)
            item = self.dlg.tableWidget3.item(row, 1)
            
            # ComboBox
            if isinstance(combo_box, QComboBox):
                selected_text = combo_box.currentText()
                self.dlg.tableWidget3.removeCellWidget(row, 1)
            
            # Text
            else:
                selected_text = item.text()    
            
            item.setText(selected_text)
            
            table_state = self.getTableState2()
            cell_state = table_state[row][1]
            original_color = QColor(cell_state['color'])
            item.setBackground(original_color)
            
            item.setFlags(item.flags() & ~Qt.ItemIsEditable)
            self.row_edit_status[row] = False
         
        self.dlg.tableWidget3.repaint()
     

    
    # Come back
    def Go_Back_table3(self):
        
        if self.table3States:
            previousState = self.table3States.pop()
            for row, row_state in enumerate(previousState):
                for col, cell in enumerate(row_state):

                    cell_text = cell['text']
                    item = self.dlg.tableWidget3.item(row, col)
                    item.setText(cell_text)

                    cell_color = cell['color']
                    if cell_color:
                        item.setBackground(QColor(cell_color))
                     
        else:
            self.iface.messageBar().pushMessage("No previous action !", level=Qgis.Warning, duration=45) 



    ## Retrieving QTableWidget 2 content : LITHOLOGIES NAMES CHECK  ## 
    
    def recup_contenu_3(self): 
        
        list_structure_unique_check_OK = []

        for row in range(self.dlg.tableWidget3.rowCount()):
            old = self.dlg.tableWidget3.item(row, 0).text()
            
            if old != '-' and old != 'NULL' :
                if isinstance(self.dlg.tableWidget3.cellWidget(row, 1), QComboBox):
                    new = self.dlg.tableWidget3.cellWidget(row, 1).currentText()
                else:
                    new = self.dlg.tableWidget3.item(row, 1).text()
        
                list_structure_unique_check_OK.append([old, new])
        
        
        return list_structure_unique_check_OK
  
 
  
    ###############################################################################
    ######         Step 9 : Structure sorting in differents Excel sheets     ######
    ###############################################################################   
    
    
    def structure_sorting (self, name_layer_to_import, fichier_output, list_columns_check3, list_structure_unique_check_OK):
        
        from openpyxl import Workbook
   
        ### 1. Creating the output Workbook
        
        fichier_output_structures = Workbook()
        project = QgsProject.instance()
        
        worksheets_structure = ['Lineations_PT','Fold axes_PT','Bedding-Lava flow-S0_PT','Foliation-cleavage_PT',
                                'Shear zones and faults_PT','Fold and crenulation axial planes_PT','Fractures_PT',
                                'Veins_PT','Dikes-Sills_PT','Planar structures_LN','Fractured zones_PG','Brecciated zones_PG',
                                'Cataclastic zones_PG']
        
        for k in range (len(worksheets_structure)):
            
            # Retrieving the reference layer in QGIS
            layer = project.mapLayersByName(worksheets_structure[k])[0]
    
            # Retrieve field names from the attribute table for this layer
            header = [str(field.name()) for field in layer.fields()]
        
            # Creation of the worksheet 
            name_worksheet2 = worksheets_structure[k] +'_'+ name_layer_to_import
            structure_output = fichier_output_structures.create_sheet(name_worksheet2.split('.')[0]) 
            structure_output.append(header)
            
 
        ### 2. Arranging columns in worksheets 
        
        # We browse the column containing the old structures in file_output
        for m in range (0,len(fichier_output['Structure_type'])):

            # We browse the list of unique (old, new) pairs verified by the user
            for k in range (len(list_structure_unique_check_OK)):
   
                if fichier_output['Structure_type'].iloc[m] == list_structure_unique_check_OK[k][0] :
                    if list_structure_unique_check_OK[k][1] != 'NULL' : 
                        fichier_output['Structure_type'].iloc[m] = (list_structure_unique_check_OK[k][1]+ '_' + name_layer_to_import).split('.')[0]  
                        break  # Once the match has been found, exit the internal loop
                    else : 
                        fichier_output['Structure_type'].iloc[m] = 'NULL'
                        

            else:
                fichier_output['Structure_type'].iloc[m] = 'NULL'
                    
        fichier_output['Structure_type'] = fichier_output['Structure_type'].fillna('NULL')  
        

        # Arrange rows according to their Structure_type value
        for k in range(0,len(fichier_output['Structure_type'])): 
            
            type_structure2 = fichier_output['Structure_type'][k]
            
            
            if type_structure2 != 'NULL':
                
                for sheet in fichier_output_structures.sheetnames :
                    if sheet != 'Sheet': 
                        if type_structure2 == sheet :
                            
                            header_reference = [col[0].value for col in fichier_output_structures[sheet].iter_cols(min_row=1, max_row=1)]
                            ligne = []
                            for col_reference in (header_reference) :
                                if col_reference not in list_columns_check3 :
                                    ligne.append ('')
                                else : 
                                    ligne.append(fichier_output[col_reference][k]) 
                                    
                            fichier_output_structures[sheet].append(ligne)
         
        return fichier_output_structures
  
  
  
    ###############################################################################
    ##   Step 9 : Import the 2 fichier_output (lithology + structure) into QGIS  ##
    ###############################################################################
    
    def import_Excel_create_QGISfile (self, file_lithology, file_structure, name_input):
        
        from openpyxl import Workbook, load_workbook
        
        if file_lithology and file_structure : 
            workbooks = [file_lithology, file_structure]
        
        elif file_lithology :
            workbooks = [file_lithology]
        
        elif file_structure : 
            workbooks = [file_structure]
        
        else : 
            workbooks = []
             
        for workbook in workbooks : 
            
            # Browse all the sheets in the Excel workbook
            for sheet_name in workbook.sheetnames:
                
                if sheet_name != 'Sheet':
                    
                    sheet = workbook[sheet_name]
        
                   # Retrieve column names
                    headers = [cell.value for cell in sheet[1]]
        
                    # Retrieve geometry column index
                    geometry_column_index = headers.index('Geometry') 
            
                    # Vector layer creation
                    layer_name = sheet_name 
                    layer = QgsVectorLayer("Point?crs=epsg:4326", layer_name, "memory")
                    
                    if "_PT" in layer_name :
                        name_reference = layer_name.split("_PT")[0]
                        name_reference = name_reference + "_PT"
                        
                    elif "_PG" in layer_name :
                        name_reference = layer_name.split("_PG")[0]
                        name_reference = name_reference + "_PG"

                    project = QgsProject.instance()                     
                    layer_reference = project.mapLayersByName(name_reference)[0]
                    
                    type_field_data = []
                    for field in layer_reference.fields():
                        type_donnee = field.typeName()
                        type_field_data.append(type_donnee)
                            
                    # Add fields name
                    layer_fields = []
                    compte = 0
                    
                    for header in headers:
                        type_donnee = type_field_data[compte]
            
                        if type_donnee == 'String' : 
                            field = QgsField(header, QVariant.String)
                        elif type_donnee == 'Integer' : 
                            field = QgsField(header, QVariant.Int)
                        elif type_donnee == 'Integer64' : 
                            field = QgsField(header, QVariant.LongLong)
                        elif type_donnee == 'JSON' : 
                            field = QgsField(header, QVariant.String)
                        layer_fields.append(field)
                        compte+=1
                        
                    layer.dataProvider().addAttributes(layer_fields)
                    layer.updateFields()
                    
                    # Add fields content
                    for row in sheet.iter_rows(min_row=2, values_only=True):
                        
                        # Geometry
                        feature = QgsFeature(layer.fields())
                        geometry_wkt = row[geometry_column_index]
                        feature.setGeometry(QgsGeometry.fromWkt(geometry_wkt))
        
                        # Other fields of the attribute table
                        for i, value in enumerate(row):
                            type_donnee = type_field_data[i]
                            if type_donnee == 'String' or type_donnee == 'JSON':
                                feature.setAttribute(i, str(value))
                            elif type_donnee in ['Integer', 'Integer64']:
                                if value.strip():
                                    try:
                                        feature.setAttribute(i, int(float(value)))
                                    except ValueError:
                                        feature.setAttribute(i, None)
                                    else:
                                        feature.setAttribute(i, None)
        
                        layer.dataProvider().addFeature(feature)
                    
                    # Add the layer to the QGIS project 
                    QgsProject.instance().addMapLayer(layer)
                        

 
  
    ###############################################################################
    ######             5 METHODES globales de la page Import_data          ########
    ###############################################################################

        
    def method_import_data (self):

        # Retrieve the path of the file to be processed from the computer (input by the user)
        if(os.path.exists(self.mynormpath(self.dlg.lineEdit_13.text()))):
            
            path_layer_to_import =  self.dlg.lineEdit_13.text()
        
            # File name retrieval
            segments = path_layer_to_import.split("/")
            name_layer_to_import = segments[-1]

            # Load layer into QGIS
            couche = QgsVectorLayer(path_layer_to_import, name_layer_to_import, "ogr")
       
            if couche.isValid():
                pass
            
            else:
                self.iface.messageBar().pushMessage("Erreur", "Unable to load selected layer !", level=Qgis.Critical)

            # Step 1 : Check layer coordinates + Create the Geometry column
            self.convert_coordinates_WGS84(couche)

            # Step 2 : Export the layer in Excel format + Fill Table1 with Columns pairs
            fichier_input =  self.export_layer_fill_Table1 (couche)
            
            self.iface.messageBar().pushMessage("Selected File loaded ","OK", level=Qgis.Success, duration=45)   
            
            return fichier_input, name_layer_to_import

            
        else:
            self.iface.messageBar().pushMessage("Directory not found: " + self.dlg.lineEdit_13.text(), level=Qgis.Warning, duration=45)   
         
        
        
    def method_columns_check_OK (self, fichier_input, name_layer_to_import):
        
        # Step 3 : Retrieving data from QTableWidget1
        list_columns_check = self.recup_contenu_1()
            
        
        # Step 4 : Dataframe creation with sorted and verified columns
        fichier_output, list_columns_check3 = self.DataFrame_columns_check (fichier_input, list_columns_check,  name_layer_to_import)
         
        
        if 'Litho' in list_columns_check3  :
            # Step 5 LITHO : Fill Table2 with Lithologies pairs 
            self.fill_Table2(fichier_output)
        
        if 'Structure_type' in list_columns_check3  :
            # Step 6 STRUCTURE : Fill Table3 with Structure pairs
            self.fill_Table3(fichier_output)
            
    
        self.iface.messageBar().pushMessage("Names of columns checked ","OK", level=Qgis.Success, duration=45)
    
        return fichier_output, list_columns_check3
    
            
     
        
     
    def method_lithologies_check_OK (self, fichier_input, name_layer_to_import, fichier_output, list_columns_check3):
        
        # Step 7 : Retrieving data from QTableWidget2
        list_lithologies_unique_check_OK = self.recup_contenu_2()
        
        # Step 8 : Organizing lithologies in different sheets of an Excel file
        fichier_output_lithology = self.lithologies_sorting(fichier_output, list_columns_check3, list_lithologies_unique_check_OK, name_layer_to_import)
        self.iface.messageBar().pushMessage("Names of lithologies checked ","OK", level=Qgis.Success, duration=45)
        
        return fichier_output_lithology



    def method_structures_check_OK (self, name_layer_to_import, fichier_output, list_columns_check3):
         
        # Step 9 : Retrieving data from QTableWidget3
        list_structure_unique_check_OK = self.recup_contenu_3()
        
       
        # Step 10 : organizing structures
        fichier_output_structures = self.structure_sorting(name_layer_to_import, fichier_output, list_columns_check3, list_structure_unique_check_OK)
        self.iface.messageBar().pushMessage("Names of structures checked ","OK", level=Qgis.Success, duration=45)
        
        return fichier_output_structures
         
    
    

    def method_import_data_as_layers (self, fichier_output_lithology, fichier_output_structures, name_input):
       
        # Step 7 : Import the Excel file into QGIS and create different QGIS files 
        self.import_Excel_create_QGISfile (fichier_output_lithology, fichier_output_structures, name_input)
        self.iface.messageBar().pushMessage("Data imported in the QGIS project ","OK", level=Qgis.Success, duration=45)

    
    
    
    ###############################################################################
    ######                 5 CLICKS de la page Import_data                 ########
    ###############################################################################
    

    def click_import_data (self): 
        
        fichier_input = 0
        name_layer_to_import = 0
        fichier_input, name_layer_to_import = self.method_import_data ()
        
        # Connect Columns check OK button correctly
        self.dlg.pushButton_9.clicked.connect(lambda: self.click_columns_check_OK(fichier_input, name_layer_to_import))
    
    
    def click_columns_check_OK (self, fichier_input, name_layer_to_import): 
        
        fichier_output = DataFrame()
        list_columns_check3 = []
        
        fichier_output, list_columns_check3 = self.method_columns_check_OK(fichier_input, name_layer_to_import)
        
        # Connect Lithologies check OK button correctly 
        if 'Litho' in list_columns_check3  :
            self.dlg.pushButton_10.clicked.connect(lambda: self.click_lithologies_check_OK(fichier_input, name_layer_to_import, fichier_output,  list_columns_check3)) 
        
        else :
            if 'Structure_type' in list_columns_check3  :
                self.dlg.pushButton_26.clicked.connect(lambda: self.click_structure_check_OK(fichier_input,name_layer_to_import, fichier_output, list_columns_check3, fichier_output_lithology=None))
            
  
    def click_lithologies_check_OK (self, fichier_input, name_layer_to_import, fichier_output, list_columns_check3): 
        
        from openpyxl import Workbook
        fichier_output_lithology = Workbook()
        
        fichier_output_lithology = self.method_lithologies_check_OK(fichier_input, name_layer_to_import,fichier_output, list_columns_check3)
        
        # Connect Structure check OK button correctly
        if 'Structure_type' in list_columns_check3  :
            self.dlg.pushButton_26.clicked.connect(lambda: self.click_structure_check_OK(fichier_input,name_layer_to_import, fichier_output, list_columns_check3, fichier_output_lithology))
        else : 
            # Connect Generate_Output_QGIS_layer button correctly
            self.dlg.pushButton_14.disconnect()
            self.dlg.pushButton_14.clicked.connect(lambda: self.click_Generate_Output_QGIS_layer(fichier_input, name_layer_to_import, fichier_output_lithology, fichier_output_structures=None))
        
        
        
    def click_structure_check_OK (self,fichier_input, name_layer_to_import, fichier_output, list_columns_check3, fichier_output_lithology)  : 
        
        fichier_output_structures  = self.method_structures_check_OK(name_layer_to_import, fichier_output, list_columns_check3)
        
        self.dlg.pushButton_14.disconnect()
        # Connect Generate_Output_QGIS_layer button correctly
        self.dlg.pushButton_14.clicked.connect(lambda: self.click_Generate_Output_QGIS_layer(fichier_input, name_layer_to_import, fichier_output_lithology, fichier_output_structures))
    
    def click_Generate_Output_QGIS_layer (self, fichier_input, name_layer_to_import, fichier_output_lithology, fichier_output_structures):
        self.method_import_data_as_layers(fichier_output_lithology, fichier_output_structures, name_layer_to_import)
       
        
       
    def click_Reset_This_Window (self):
        self.resetWindow_import_data()
    
    
    
    ###############################################################################
    ################       Page 2 : Fieldwork preparation           ###############
    ###############################################################################

    
    ### Clip to Canvas ###
     
    def clipToCanvas(self):
    # Clips all WAXI QFIELD vector layers to current canvas and 
    # saves out layers in a new directory
        
        if(os.path.exists(self.mynormpath(self.dlg.lineEdit_3.text()))):
            
            # set up paths
            project = QgsProject.instance()
            proj_file_path = project.fileName()
            head_tail = os.path.split(proj_file_path)
            dir_99="/99. COMMAND FILES - PLUGIN/"
            dir_0="/0. FIELD DATA/"
            dir_10="/10. ORTHOPHOTOGRAPHY-SATELLITE IMAGERY/"

            oldProjPath=head_tail[0]
            oldGpkgPath=oldProjPath+'/0. FIELD DATA/CURRENT MISSION.gpkg'
            newProjPath=self.mynormpath(self.dlg.lineEdit_3.text()).strip()
            newGpkgPath=newProjPath+'/0. FIELD DATA/CURRENT MISSION.gpkg'
            shp_list=self.mynormpath(os.path.dirname(os.path.realpath(__file__))+"/shp.csv")
            
            # clipping rectangle from Canvas
            e = self.iface.mapCanvas().extent()  
            extent = QgsRectangle(e.xMinimum(), e.yMinimum(), e.xMaximum(), e.yMaximum())  # Replace with the desired extents
            shps=read_csv(shp_list,names=['name','dir_code'])
            shps=shps.set_index("name")   
            geom = QgsGeometry().fromRect(extent)
            ftr = QgsFeature()
            ftr.setGeometry(geom)    
            project = QgsProject.instance()
            crs = project.crs()            
            clip_layer = QgsVectorLayer('Polygon?{}'.format(crs), 'Test_polygon','memory')    
            with edit(clip_layer):
                clip_layer.addFeature(ftr)

            # create directory structure
                
            dirs=[newProjPath,newProjPath+'/0. FIELD DATA',newProjPath+'/99. COMMAND FILES - PLUGIN',newProjPath+"/8. GEOGRAPHY/"]

            for dirpath in dirs:
                if(not os.path.exists(self.mynormpath(dirpath))):
                    os.mkdir(self.mynormpath(dirpath))
            
            
            # copy over files that are not clipped
            src_path = oldProjPath+dir_99+"/Stops_PT_autoinc.qml"            
            dst_path = newProjPath+dir_99+"/Stops_PT_autoinc.qml"
            shutil.copyfile(src_path,dst_path)

            '''
            src_file = oldProjPath+dir_99+"/Version.txt"            
            dst_file = newProjPath+dir_99+"/Version.txt"
            shutil.copyfile(src_file,dst_file)
            '''

            src_path = oldProjPath+dir_99+"/Stops_PT_no_autoinc.qml"
            dst_path = newProjPath+dir_99+"/Stops_PT_no_autoinc.qml"
            shutil.copyfile(src_path,dst_path)
    
            src_path=oldProjPath+dir_0+"/99. CSV FILES"
            dst_path=self.mynormpath(newProjPath+dir_0+"/99. CSV FILES/")
    
            shutil.copytree(src_path, dst_path)

            shutil.copyfile(proj_file_path, newProjPath+'/'+head_tail[1].replace('.qgz','_clip.qgz'))

            src_path=oldProjPath+"/0. FIELD DATA/DCIM/"
            dst_path=self.mynormpath(newProjPath+"/0. FIELD DATA/DCIM/")
            shutil.copytree(src_path, dst_path)

            src_path=oldProjPath+"/10. ORTHOPHOTOGRAPHY-SATELLITE IMAGERY"
            dst_path=self.mynormpath(newProjPath+"/10. ORTHOPHOTOGRAPHY-SATELLITE IMAGERY")
            shutil.copytree(src_path, dst_path)

            src_path = oldProjPath+dir_0+"/CURRENT MISSION+CSV FILES.qlr"
            dst_path = newProjPath+dir_0+"/CURRENT MISSION+CSV FILES.qlr"
            shutil.copyfile(src_path,dst_path)

            src_path = oldProjPath+dir_10+"/GoogleSatellite_5km_compressed.tif"
            dst_path = newProjPath+dir_10+"/GoogleSatellite_5km_compressed.tif"
            shutil.copyfile(src_path,dst_path)

            '''
            src_file = oldProjPath+dir_99+"/columns_reference_WAXI4.xlsx"
            dst_file = newProjPath+dir_99+"/columns_reference_WAXI4.xlsx"
            shutil.copyfile(src_file,dst_file)
    
            src_file = oldProjPath+dir_99+"/columns_types_structures_WAXI4.xlsx"
            dst_file = newProjPath+dir_99+"/columns_types_structures_WAXI4.xlsx"
            shutil.copyfile(src_file,dst_file)
            '''
    
            in_pref=oldProjPath+'/99. COMMAND FILES - PLUGIN/'
            out_pref=newProjPath+'/99. COMMAND FILES - PLUGIN/'

            copies=[[oldGpkgPath,newGpkgPath],
                    [in_pref+'columns_reference_WAXI4.xlsx',out_pref+'columns_reference_WAXI4.xlsx'],
                    [in_pref+'columns_types_structures_WAXI4.xlsx',out_pref+'columns_types_structures_WAXI4.xlsx'],
                    [in_pref+'stereonet.json',out_pref+'stereonet.json'],
                    [in_pref+'Stops_PT.qml',out_pref+'Stops_PT.qml'],
                    [in_pref+'Stops_PT_autoinc.qml',out_pref+'Stops_PT_autoinc.qml'],
                    [in_pref+'Stops_PT_no_autoinc.qml',out_pref+'Stops_PT_no_autoinc.qml'],
                    [in_pref+'Version.txt',out_pref+'Version.txt']
                    ]
            
            for pairs in copies:
                shutil.copyfile(pairs[0],pairs[1])
            
            # Prepare the output shapefile parameters for clipping
            
            for layer in project.mapLayers().values():
                # Check if the layer name matches the target name
                if layer.name() in shps.index.tolist():  
                    if(not '_PG' in layer.name()): 
                        # Get the file path of the layer
        
                        input_path=self.mynormpath(layer.dataProvider().dataSourceUri())

                        output_path_gpkg=self.mynormpath(newGpkgPath)
                        print(output_path_gpkg)
                        processing.run("native:clip", 
                            {'INPUT':input_path,
                                'OVERLAY':clip_layer,
                                'OUTPUT':'ogr:dbname=\''+output_path_gpkg+'\' table="'+layer.name()+'" (geom)'})         
    
                    else:
                        print(layer.name())
            self.iface.messageBar().pushMessage("Files clipped to current extent, saved in directory" + newProjPath, level=Qgis.Success, duration=5)


        else:
            self.iface.messageBar().pushMessage("Directory not found: "+ self.dlg.lineEdit_3.text(), level=Qgis.Warning, duration=45)



    ### CSV TOOLS ### 
    
    ### Option 1 :  ADD a single value/description pair to any CSV file in the WAXI QFIELD template
    def addCsvItem(self):
        
        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_99_CSV_files = os.path.join(os.path.dirname(WAXI_projet_path), "0. FIELD DATA/99. CSV FILES/")
        
        layer_name = str(self.dlg.comboBox.currentText())
        chemin_fichier_CSV_modifier = emplacement_99_CSV_files + layer_name + ".csv"
        
        if chemin_fichier_CSV_modifier :
            
            df = read_csv(chemin_fichier_CSV_modifier, encoding="latin_1", sep=";")
            
            # Get the value to be added to the ComboBox
            new_row = {'Valeur' : str(self.dlg.lineEdit_38.text()), 'Description': str(self.dlg.lineEdit_27.text())}
            
            df = concat([df, DataFrame([new_row])], ignore_index=True)
            
            df.sort_values(by='Valeur', inplace=True)

            # Rewrites the CSV file with the added line
            df.to_csv(chemin_fichier_CSV_modifier, encoding="latin_1", sep=";", index=False)
            
            # Updates the layer in QGIS
            couche_csv = QgsProject.instance().mapLayersByName(layer_name)[0]
            couche_csv.dataProvider().forceReload()
    
            self.iface.messageBar().pushMessage("Item " + str(self.dlg.lineEdit_38.text()) + " " + str(self.dlg.lineEdit_27.text()) + " added to " + layer_name, level=Qgis.Success, duration=15)

        else:
            self.iface.messageBar().pushMessage("Layer not found: " + layer_name, level=Qgis.Warning, duration=45)
        


    ### Option 2 :  DELETE a single value to any CSV file in the WAXI QFIELD template 
    def deleteCsvItem(self):
        
        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_99_CSV_files = os.path.join(os.path.dirname(WAXI_projet_path), "0. FIELD DATA/99. CSV FILES/")
        
        layer_name = str(self.dlg.comboBox.currentText())
        chemin_fichier_CSV_modifier = emplacement_99_CSV_files + layer_name + ".csv"
        
        if chemin_fichier_CSV_modifier :
            
            df = read_csv(chemin_fichier_CSV_modifier, encoding="latin_1", sep=";")
            
            # Gets the value to be deleted from the ComboBox
            deleted_value = str(self.dlg.comboBox_delete.currentText())
            
            # Index corresponding to the value to be deleted
            index_to_drop = df[df['Valeur'] == deleted_value].index
            
            # Deletes the corresponding line
            df.drop(index_to_drop, inplace=True)
            
            # Rewrites the CSV file with the deleted line
            df.to_csv(chemin_fichier_CSV_modifier, encoding="latin_1", sep=";", index=False)
    
            # Updates the layer in QGIS
            couche_csv = QgsProject.instance().mapLayersByName(layer_name)[0]
            couche_csv.dataProvider().forceReload()
            
            # Delete word from comboBox
            index_a_supprimer = self.dlg.comboBox_delete.findText(deleted_value)
            if index_a_supprimer != -1:
                self.dlg.comboBox_delete.removeItem(index_a_supprimer)
    
            self.iface.messageBar().pushMessage("Item " + deleted_value + " deleted to "+ layer_name, level=Qgis.Success, duration=15)

        else:
            self.iface.messageBar().pushMessage("Layer not found: " + layer_name, level=Qgis.Warning, duration=45)


    ### Update project name ###

    def updateProjectTitle(self):
        if(self.dlg.lineEdit_9.text() and  self.dlg.lineEdit_10.text()):
            project = QgsProject.instance()
            new_title =  self.dlg.lineEdit_9.text()+"/"+  self.dlg.lineEdit_10.text()
            project.setTitle(new_title)
            project.write()
            self.iface.messageBar().pushMessage("Project title updated to " + new_title, level=Qgis.Success, duration=45)



    ### Toggle AutoIncrements of stop number ### 
    
    def toggleAutoInc(self):
        project = QgsProject.instance()
        proj_file_path=project.fileName()
        head_tail = os.path.split(proj_file_path)
        
        current_file_name = head_tail[0]+"/99. COMMAND FILES - PLUGIN/Stops_PT.qml"
        os.remove(current_file_name)

        no_auto_filename = head_tail[0]+"/99. COMMAND FILES - PLUGIN/Stops_PT_no_autoinc.qml"
        auto_filename = head_tail[0]+"/99. COMMAND FILES - PLUGIN/Stops_PT_autoinc.qml"
        if( self.dlg.radioButtonOn.isChecked()):
            shutil.copy(auto_filename,current_file_name)
            self.iface.messageBar().pushMessage("Auto Incrementing Stop Numbers turned ON", level=Qgis.Success, duration=15)

        else:
            shutil.copy(no_auto_filename,current_file_name)
            self.iface.messageBar().pushMessage("Auto Incrementing Stop Numbers turned OFF", level=Qgis.Success, duration=15)
        
        layer = project.mapLayersByName('Stops_PT')[0]
        layer.loadNamedStyle(head_tail[0]+"/99. COMMAND FILES - PLUGIN/Stops_PT.qml")
        layer.triggerRepaint()

    ### Set user by default ###                   #ADD
    
    def set_user_by_default (self) :
        
        from fuzzywuzzy import fuzz
        
        if(self.dlg.lineEdit_39.text()):
            
            default_value_user_csv = str(self.dlg.lineEdit_39.text())
            
            ## User.csv file location 
            WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
            emplacement_User_file = os.path.join(os.path.dirname(WAXI_projet_path), "0. FIELD DATA/99. CSV FILES/User list.csv")
            user_file = read_csv(emplacement_User_file, sep=';', encoding='latin-1')
            
            
            ## Test if the user name is already present in the User.csv file 
            list_score =[]
            liste_users = list(user_file['Valeur'])

            for test in liste_users :
                new_score = fuzz.token_set_ratio(str(test),  default_value_user_csv)
                list_score.append(new_score)
            
            # If the user name is not in the CSV file, we add it:
            if 100 not in list_score :  
                new_row = {'Valeur': default_value_user_csv, 'Description':  default_value_user_csv}
                user_file = concat([user_file, DataFrame([new_row])], ignore_index=True)
                user_file.sort_values(by='Valeur', inplace=True)
                
                # Rewrites the CSV file with the added line
                user_file.to_csv(emplacement_User_file, encoding="latin_1", sep=";", index=False)
                
                # Updates the layer in QGIS
                couche_user = QgsProject.instance().mapLayersByName('User list')[0]
                couche_user.dataProvider().forceReload()
                
                default_value_user = "'"+str(self.dlg.lineEdit_39.text())+"'"
            
            # If the user name is in the CSV file, we choose it:
            else : 
                for test in liste_users :
                    new_score = fuzz.token_set_ratio(str(test),  default_value_user_csv)
                    if new_score == 100 : 
                        default_value_user = "'"+test+"'"
                        break
                

            ## Modification of the User field in QGIS template layers 
            self.dlg.button_group = QButtonGroup()
            self.dlg.button_group.addButton(self.dlg.radioButton_All)
            self.dlg.button_group.addButton(self.dlg.radioButton_Some)
            
            
            # If the "Change for one layer" radiobutton is checked
            if (self.dlg.radioButton_Some.isChecked()):
                layer_selected = QgsProject.instance().mapLayersByName(str(self.dlg.comboBox_layers_user.currentText()))[0]

                # Find 'User' field index
                field_index =  layer_selected.fields().indexFromName('User')
            
                # Create default value 
                default_value = QgsDefaultValue(default_value_user)
            
                # Update default field value
                layer_selected.setDefaultValueDefinition(field_index, default_value)
                QgsProject.instance().write()
                
                self.iface.messageBar().pushMessage(str(default_value_user) + " is now the default user for " + str(self.dlg.comboBox_layers_user.currentText()), level=Qgis.Success, duration=15)
                    
            
            # If the "Change for all layers" radiobutton is checked
            if (self.dlg.radioButton_All.isChecked()):
                
                layers = QgsProject.instance().mapLayers()

                for layerId, layer in layers.items():
                    
                    # Select all non CSV layers of the QGIS project 
                    if isinstance(layer, QgsVectorLayer) and not layer.dataProvider().dataSourceUri().lower().endswith('.csv'):
                    
                        # Find 'User' field index
                        field_index = layer.fields().indexFromName('User')
                    
                        # Create default value 
                        default_value = QgsDefaultValue(default_value_user)
                    
                        # Update default field value
                        layer.setDefaultValueDefinition(field_index, default_value)
                        QgsProject.instance().write()

                self.iface.messageBar().pushMessage(str(default_value_user) + " is now the default user for ALL the layers in the project", level=Qgis.Success, duration=15)


    ###############################################################################
    ################       Page 3 : Field Data Management           ###############
    ###############################################################################


    ### Merge Projects ### to modifie with the new architecture of the plugin 
    
    def list_csv_files(directory):
        files = []
        for filename in os.listdir(directory):
            path = os.path.join(directory, filename)
            if (os.path.isfile(path) and path.split('.')[-1]=='csv'):
                files.append(filename)
        return files
   
    def mergeProjects(self):
    # Takes two WAXI QFIELD Projects and combines them, 
    # removing duplicates and saves out the full structure to a new directory
        
        if(os.path.exists(self.mynormpath(self.dlg.lineEdit_11.text())) and 
            os.path.exists(self.mynormpath(self.dlg.lineEdit_26.text())) and 
            os.path.exists(self.mynormpath(self.dlg.lineEdit_37.text()))):
            
            
            project = QgsProject.instance()  # assumes one of the projects is actually open!  Could use copy stored in plugin?

            # set up directory structure and load filename lists
            dir_99="/99. COMMAND FILES - PLUGIN/"
            dir_0="/0. FIELD DATA/"
            dir_10="/10. ORTHOPHOTOGRAPHY-SATELLITE IMAGERY/"

            shp_list = self.mynormpath(os.path.dirname(os.path.realpath(__file__))+"/shp.csv")
            csv_list = self.mynormpath(os.path.dirname(os.path.realpath(__file__))+"/csv.csv")
            shps=read_csv(shp_list,names=['name','dir_code'])
            shps=shps.set_index("name")
            csvs=read_csv(csv_list,names=['name'])            

            merge_project_path =  self.dlg.lineEdit_37.text()

            head_tail_main = os.path.split(self.dlg.lineEdit_11.text())
            head_tail_sub = os.path.split(self.dlg.lineEdit_26.text())
            
            main_project_path=head_tail_main[0]
            sub_project_path=head_tail_sub[0]
                       
            mainGpkgPath=main_project_path+'/0. FIELD DATA/CURRENT MISSION.gpkg'
            subGpkgPath=sub_project_path+'/0. FIELD DATA/CURRENT MISSION.gpkg'
            mergeGpkgPath=merge_project_path+'/0. FIELD DATA/CURRENT MISSION.gpkg'

            #create new directory structures
            dirs=[merge_project_path,merge_project_path+dir_0,merge_project_path+dir_99]

            for dirpath in dirs:
                if(not os.path.exists(self.mynormpath(dirpath))):
                    os.mkdir(self.mynormpath(dirpath))
    
            # copy over files that are not clipped
    
            src_path=main_project_path+'/0. FIELD DATA/99. CSV FILES'
            dst_path=self.mynormpath(merge_project_path+"/0. FIELD DATA/99. CSV FILES/")
            shutil.copytree(src_path, dst_path)

            src_path=main_project_path+dir_10
            dst_path=self.mynormpath(merge_project_path+dir_10)
            shutil.copytree(src_path, dst_path)

            src_path=main_project_path+"/8. GEOGRAPHY"
            dst_path=self.mynormpath(merge_project_path+"/8. GEOGRAPHY/")
            shutil.copytree(src_path, dst_path)

            src_path=main_project_path+"/0. FIELD DATA/DCIM/"
            dst_path=self.mynormpath(merge_project_path+"/0. FIELD DATA/DCIM/")
            shutil.copytree(src_path, dst_path)

            src_file = main_project_path+dir_0+"/CURRENT MISSION+CSV FILES.qlr"
            dst_file = merge_project_path+dir_0+"/CURRENT MISSION+CSV FILES.qlr"
            shutil.copyfile(src_file,dst_file)
            
            shutil.copyfile(self.dlg.lineEdit_11.text(), merge_project_path+'/WAXI4 - Mission ID - Date.qgz')
    
            in_pref=main_project_path+dir_99
            out_pref=merge_project_path+dir_99
            copies=[[mainGpkgPath,mergeGpkgPath],
                    #[in_pref+'columns_reference_WAXI4.xlsx',out_pref+'columns_reference_WAXI4.xlsx'],
                    [in_pref+'columns_types_structures_WAXI4.xlsx',out_pref+'columns_types_structures_WAXI4.xlsx'],
                    [in_pref+'columns_types_structures_WAXI4.xlsx',out_pref+'columns_types_structures_WAXI4.xlsx'],
                    [in_pref+'stereonet.json',out_pref+'stereonet.json'],
                    [in_pref+'Stops_PT.qml',out_pref+'Stops_PT.qml'],
                    [in_pref+'Stops_PT_autoinc.qml',out_pref+'Stops_PT_autoinc.qml'],
                    [in_pref+'Stops_PT_no_autoinc.qml',out_pref+'Stops_PT_no_autoinc.qml'],
                    [in_pref+'Version.txt',out_pref+'Version.txt'],
                    ]
            
            for pairs in copies:
                print(pairs[0],pairs[1])
                shutil.copyfile(pairs[0],pairs[1])
            
            for layer in project.mapLayers().values():
                # Check if the layer name matches the target name
                if layer.name() in shps.index.tolist():  
    
                    main_layer_path=mainGpkgPath+'|layername='+layer.name()
                    sub_layer_path=subGpkgPath+'|layername='+layer.name()
                    #merge_layer_path=mergeGpkgPath+'|layername='+layer.name()

        

                    if(layer.name()=='Sampling_PT'): #can't add coordinates when alias and cooments present

                        # merge two shapefiles
                        params = { 
                        'LAYERS': [main_layer_path, sub_layer_path],
                        'OUTPUT':'ogr:dbname=\''+mergeGpkgPath+'\' table="'+layer.name()+'" (geom)'
                        }
            
                        processing.run("native:mergevectorlayers", params )


                    else:
                        # merge two shapefiles
                        params = {
                        'LAYERS': [main_layer_path, sub_layer_path],
                        'OUTPUT': 'memory:'
                        }
                        merged_layers=processing.run("native:mergevectorlayers", params )['OUTPUT']

                       # extract geometries of merged file
                        params = { 
                        'CALC_METHOD' : 0, 
                        'INPUT' :  merged_layers, 
                        'OUTPUT' : 'memory:' 
                        }
            
                        added_geom=processing.run("qgis:exportaddgeometrycolumns",params)['OUTPUT']
        
                        # remove duplicate rows
                        params = { 
                        'FIELDS' : ['Date','User','xcoord','ycoord','SampleID'], 
                        'INPUT' : added_geom, 
                        'OUTPUT' : 'memory:' 
                        }
            
                        removed_dups=processing.run("native:removeduplicatesbyattribute", params)['OUTPUT']
            
                        # remove generated coordinate columns
                        params = {
                        'INPUT':removed_dups,
                        'COLUMN':['xcoord','ycoord'],
                        'OUTPUT':'ogr:dbname=\''+mergeGpkgPath+'\' table="'+layer.name()+'" (geom)'
                        }
            
                        processing.run("native:deletecolumn", params) 
                        
                '''
                else:
                    print("xxx",layer.name()) 
                print(shps.index.tolist())  
                '''         
                # merge and de-duplicate csv files
                for file in csvs.name:
                    main_path=self.mynormpath(main_project_path+dir_0+"/99. CSV FILES/"+file+'.csv')
                    sub_path=self.mynormpath(sub_project_path+dir_0+"/99. CSV FILES/"+file+'.csv')
                    merge_path=self.mynormpath(merge_project_path+dir_0+"/99. CSV FILES/"+file+'.csv')
        
                    main=read_csv(main_path,sep=";",encoding="latin_1")
                    sub=read_csv(sub_path,sep=";",encoding="latin_1")
                    merge=concat([main,sub])
                    merge=merge.drop_duplicates()
                    merge.to_csv(merge_path,index=False,sep=";")
                
            
            self.iface.messageBar().pushMessage("Projects merged, saved in directory" + merge_project_path, level=Qgis.Success, duration=5)


        else:
            self.iface.messageBar().pushMessage("Directory not found", level=Qgis.Warning, duration=45)  
   
  
    
  
    ### Export Data ###
    
    def exportData(self):
    # Combines sets of lithology, structure and zoneal layers into 3 shapefiles
    
        if(os.path.exists(self.mynormpath(self.dlg.lineEdit_7.text()))):
    
            project = QgsProject.instance()
            proj_file_path = project.fileName()
            head_tail = os.path.split(proj_file_path)
            file=[]
            # merge zone data 
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Fractured zones_PG"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Brecciated zones_PG"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Cataclastic zones_PG"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Alteration zones_PG"))
            output=self.mynormpath(self.dlg.lineEdit_7.text()+"/zonal_data.shp")
            
            """for f in file:
                print(f)
                layer = self.iface.addVectorLayer(f, '', 'ogr')
                # Get layer capabilities
                caps = layer.dataProvider().capabilities()
    
                # Add Fields
                if caps & QgsVectorDataProvider.AddAttributes:
                    res = layer.dataProvider().addAttributes([QgsField('DataType', QVariant.String, "string",50)])
                    layer.updateFields()
    
                #Get indexes of LDC and Fecha fields
                DataType_idx = layer.fields().lookupField('DataType')
    
                # Change attribute values
                for f in layer.getFeatures():
                    head_tail=os.path.split(f)
                    DataType = head_tail[1].replace(".shp","")
                    layer.dataProvider().changeAttributeValues({f.id(): {DataType_idx: DataType}})
            """
            # merge shapefiles
            params = {
            'LAYERS': [file[0], file[1],file[2],file[3]],
            'OUTPUT': output
            }
    
            processing.run("native:mergevectorlayers", params )
    
            # merge lithology data
            file1=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Metamorphic lithologies_PT")
            file2=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Igneous intrusive lithologies_PT")
            file3=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Sedimentary lithologies_PT")
            file4=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Supergene lithologies_PT")
            file5=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Igneous extrusive lithologies_PT")
            file6=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Volcanoclastic lithologies_PT")
            output=self.mynormpath(self.dlg.lineEdit_7.text()+"/litho_data.shp")
    
            # merge shapefiles
            params = {
            'LAYERS': [file1, file2,file3,file4,file5,file6],
            'OUTPUT': output
            }
    
            processing.run("native:mergevectorlayers", params )
    
            # merge structural data
            file1=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Bedding-Lava flow-S0_PT")
            file2=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Dikes-Sills_PT")
            file3=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Fold and crenulation axial planes_PT")
            file4=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Fold axes_PT")
            file5=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Foliation-cleavage_PT")
            file6=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Fractures_PT")
            file7=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Lineations_PT")
            file8=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Shear zones and faults_PT")
            file9=self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Veins_PT")
            output=self.mynormpath(self.dlg.lineEdit_7.text()+"/structure_data.shp")
    
            # merge shapefiles
            params = {
            'LAYERS': [file1, file2,file3,file4,file5,file6,file7,file8,file9],
            'OUTPUT': output
            }
    
            processing.run("native:mergevectorlayers", params )
            self.iface.messageBar().pushMessage("Layers merged, saved in directory" +  self.dlg.lineEdit_7.text(), level=Qgis.Success, duration=5)
    
    
    
        else:
            self.iface.messageBar().pushMessage("Directory not found: "+ self.dlg.lineEdit_7.text(), level=Qgis.Warning, duration=45)
    

    
    def mynormpath(self,path):
        return(os.path.normpath(path).replace("\\","/"))
    
    
    

    ### Virtual Stops ###     
    
    def virtualStops(self):
        distance = self.dlg.lineEdit_53.text()
        from .dbscan import Basic_DBSCAN
        from datetime import datetime
        
        if(self.dlg.lineEdit_53.text()):
            
            # Defines pseudo stop numbers based on proximity
            project = QgsProject.instance()
            proj_file_path=project.fileName()
            head_tail = os.path.split(proj_file_path)
    
            file=[]
    
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Lineations_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Fold axes_PT"))        

            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Bedding-Lava flow-S0_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Foliation-cleavage_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Shear zones and faults_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Fold and crenulation axial planes_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Fractures_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Veins_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Dikes-Sills_PT"))

            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Local lithologies_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Supergene lithologies_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Sedimentary lithologies_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Volcanoclastic lithologies_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Igneous extrusive lithologies_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Igneous intrusive lithologies_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Metamorphic lithologies_PT"))
            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Lithological contacts_PT"))

            file.append(self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Magnetic susceptibility_PT"))

            # Merge two shapefiles
            params = {
            'LAYERS': [file[0],file[1]],
            'OUTPUT': 'memory:'
            }
            print(file[0])
            print(file[1])
            merged_layers=processing.run("native:mergevectorlayers", params )['OUTPUT']
            
            for i,f in enumerate(file):
       
                    if(i>1):
                        print(f)
                        # merge two shapefiles
                        params = {
                        'LAYERS': [merged_layers,f],
                        'OUTPUT': 'memory:'
                        }
    
                        merged_layers=processing.run("native:mergevectorlayers", params )['OUTPUT']
                        
    
    
            points=[]
            feats = merged_layers.getFeatures()
            for i,f in enumerate(feats):
                point=f.geometry()
                points.append([point.asPoint().x(), point.asPoint().y()])
            canvas = self.iface.mapCanvas()
    
            if(canvas.mapUnits()==6): #if lat/long convert to metres, anything else is assuemd to be metres already (not a good idea)
                distance=float(distance)/111139.0   
            scanner = Basic_DBSCAN(eps=float(distance), minPts=1)
            """
            SIP_MONKEYPATCH_COMPAT_NAME 	0        Meters.
            SIP_MONKEYPATCH_COMPAT_NAME 	1        Kilometers.
            SIP_MONKEYPATCH_COMPAT_NAME 	2        Imperial feet.
            SIP_MONKEYPATCH_COMPAT_NAME 	3        Nautical miles.
            SIP_MONKEYPATCH_COMPAT_NAME 	4        Imperial yards.
            SIP_MONKEYPATCH_COMPAT_NAME 	5        Terrestrial miles.
            SIP_MONKEYPATCH_COMPAT_NAME 	6        Degrees, for planar geographic CRS distance measurements.
            SIP_MONKEYPATCH_COMPAT_NAME 	7        Centimeters.
            SIP_MONKEYPATCH_COMPAT_NAME 	8        Millimeters.
            Inches 	9        Inches (since QGIS 3.32)
            SIP_MONKEYPATCH_COMPAT_NAME 10        Unknown distance unit.
            """
            if(len(points)>0):
                X=np.array(points)
                X[0]=(X[0]-X[:,0].mean())/X[:,0].std()
                X[1]=(X[1]-X[:,1].mean())/X[:,1].std()
                #X = StandardScaler().fit_transform(X)
    
    
                clusters = scanner.fit_predict(X)
                #print(clusters)
                
    
                merged_layers.startEditing()
                if merged_layers.dataProvider().fieldNameIndex("v_stop") == -1:
                    merged_layers.dataProvider().addAttributes([QgsField("v_stop", QVariant.String)])
                    merged_layers.updateFields()
    
                id_new_col= merged_layers.dataProvider().fieldNameIndex("v_stop")
    
                for i,feature in enumerate(merged_layers.getFeatures()):
                    if(clusters[i]>0):
                        merged_layers.changeAttributeValue(feature.id(), id_new_col, str(clusters[i]))
    
                merged_layers.commitChanges()
                if not merged_layers.isValid():
                    print("Layer failed to build!")
                else:
                    QgsProject.instance().addMapLayer(merged_layers,False)
                    output_path = QgsProject.instance().readPath("./")
                    datestamp=datetime.now().strftime('%d-%b-%Y_%H_%M_%S')
                    params = {'INPUT': merged_layers,
                            'OPTIONS':'-update -nln '+"Virtual_Stops_" + datestamp,
                            'OUTPUT':output_path+"/0. FIELD DATA/CURRENT MISSION.gpkg"}
                    processing.run("gdal:convertformat", params)
                    '''
                    options = QgsVectorFileWriter.SaveVectorOptions()
                    options.driverName = "GPKG"
                    #options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
                    options.fileEncoding="UTF8"
    
                    writer = QgsVectorFileWriter.writeAsVectorFormatV3 (merged_layers,virtual_path, QgsProject.instance().transformContext(), options )
                    print(writer[0],writer,virtual_path)
                    if writer[0] != QgsVectorFileWriter.NoError:
                        self.iface.messageBar().pushMessage("Error occurred while creating shapefile: "+ writer[1], level=Qgis.Warning, duration=15)
                        return

                    del writer
                    '''
                    virtual_path = self.mynormpath(output_path+"/0. FIELD DATA/CURRENT MISSION.gpkg|layername=Virtual_Stops_" + datestamp ) # Path to clip rectangle in memory
                    self.iface.addVectorLayer(virtual_path, '', 'ogr')
                    self.iface.messageBar().pushMessage("Virtual Stop layer created", level=Qgis.Success, duration=5)
            else:
                self.iface.messageBar().pushMessage("No points found", level=Qgis.Warning, duration=45)


    def rmvLyr(lyrname):
        qinst = QgsProject.instance()
        
        qinst.removeMapLayer(qinst.mapLayersByName(lyrname)[0].id())

  
    
    ### Stereographic projection settings ### 

    def set_stereoConfig(self):
    
        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        stereoConfigPath = os.path.join(os.path.dirname(WAXI_projet_path), "99. COMMAND FILES - PLUGIN/stereonet.json")
        stereoConfig = {'showGtCircles':True,'showContours':True,'showKinematics':True,'linPlanes':True,'roseDiagram':True}
        
        if(os.path.exists(stereoConfigPath)):
            with open(stereoConfigPath,"r") as json_file:
                stereoConfig=json.load(json_file)
            
        stereoConfig={'showGtCircles':self.dlg.gtCircles_checkBox.isChecked(),
                      'showContours':self.dlg.contours_checkBox.isChecked(),
                      'showKinematics':self.dlg.kinematics_checkBox.isChecked(),
                      'linPlanes':self.dlg.linPlanes_checkBox.isChecked(),
                      'roseDiagram':self.dlg.rose_checkBox.isChecked()}

        with open(stereoConfigPath, "w") as outfile:
            json.dump(stereoConfig, outfile, indent=4)
    
    
    ### Merge 2 layers ###
        
    def merge_2_layers_ (self):

        project = QgsProject.instance()
        proj_file_path=project.fileName()
        head_tail = os.path.split(proj_file_path)

        couche1 = QgsProject.instance().mapLayersByName(str(self.dlg.comboBox_merge1_2.currentText()))[0]
        couche2 = QgsProject.instance().mapLayersByName(str(self.dlg.comboBox_merge2_2.currentText()))[0]
    
        # Run the merge algorithm
        merged = processing.run("qgis:mergevectorlayers", {
            'LAYERS': [couche1, couche2],
            'CRS': couche1.crs(),  # Change the CRS as needed
            'OUTPUT': 'memory:'  # Output to memory (temporary layer)
        })['OUTPUT']

        # remove duplicate rows
        params = { 
        'FIELDS' : ['Date','User','xcoord','ycoord'], 
        'INPUT' : merged, 
        'OUTPUT' : 'ogr:dbname=\''+self.mynormpath(head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg")+'\' table="'+couche2.name()+'" (geom)' 
        }

        processing.run("native:removeduplicatesbyattribute", params)['OUTPUT']


            
    def merge_2_layers (self):
        couche1 = QgsProject.instance().mapLayersByName(str(self.dlg.comboBox_merge1_2.currentText()))[0]
        couche2 = QgsProject.instance().mapLayersByName(str(self.dlg.comboBox_merge2_2.currentText()))[0]
        
        if couche1 != couche2 :
            
            colonnes_couche1 = [field.name() for field in couche1.fields()]
            colonnes_couche2 = [field.name() for field in couche2.fields()]
            
            '''
            if set(colonnes_couche1) != set(colonnes_couche2):
                
                colonnes_manquantes = set(colonnes_couche2) - set(colonnes_couche1)

                for nom_colonne in colonnes_manquantes:
                    print(nom_colonne)
                    type_donnee = couche2.fields().field(nom_colonne).typeName()
                    couche1.addAttribute(QgsField(nom_colonne, type_donnee))
                couche1.updateFields()
            '''   
   
            ## Loop on first layer entities
            
            for entite1 in couche1.getFeatures():
                # Creation of a new entity for the second layer
                nouvelle_entite = QgsFeature()
        
                # Copy geometry
                nouvelle_entite.setGeometry(entite1.geometry())
        
                # Copy attributes
                nouvelle_entite.setAttributes(entite1.attributes())
        
                # Add entity to second layer
                couche2.dataProvider().addFeatures([nouvelle_entite])
        
            # Refinishing the second layer
            couche2.updateFields()
            couche2.triggerRepaint()
        
            # Removing the first layer
            QgsProject.instance().removeMapLayer(couche1.id())

    ### Update the source path of pictures in Photographs_PT and Sampling_PT layers ###         
    
    def update_source_photo (self):       #ADD
    
        new_source_path = str(self.dlg.lineEdit_14.text())
        
        if os.path.exists(self.mynormpath(new_source_path)):
            

                
            layer_photographs_PT = QgsProject.instance().mapLayersByName("Photographs_PT")[0]
            layer_sampling_PT = QgsProject.instance().mapLayersByName("Sampling_PT")[0]
            source_field_index_photo = layer_photographs_PT.fields().indexFromName("Source")
            source_field_index_sampling = layer_sampling_PT.fields().indexFromName("Source")
            
            ## Option 1 
            if (self.dlg.option1_ckeckbox.isChecked()) :
                
                layer_photographs_PT.startEditing()

                for entite in layer_photographs_PT.getFeatures():
                    entite.setAttribute(source_field_index_photo, new_source_path)
                    layer_photographs_PT.updateFeature(entite)
                    
                layer_photographs_PT.commitChanges()
                
                layer_sampling_PT.startEditing()
                
                for entite in layer_sampling_PT.getFeatures():
                    entite.setAttribute(source_field_index_sampling, new_source_path)
                    layer_sampling_PT.updateFeature(entite)
                    
                layer_sampling_PT.commitChanges()
                
            ## Option 2
            if (self.dlg.option2_ckeckbox.isChecked()) :

                # Create default value 
                new_source_path_default = "'"+str(new_source_path)+"'"
                default_value = QgsDefaultValue(new_source_path_default)
            
                # Update default field value
                layer_photographs_PT.setDefaultValueDefinition(source_field_index_photo, default_value)
                QgsProject.instance().write()
    
            
                # Update default field value
                layer_sampling_PT.setDefaultValueDefinition(source_field_index_sampling, default_value)
                QgsProject.instance().write()
                
                
    
            self.iface.messageBar().pushMessage((new_source_path + " is now the default directory for pictures"), level=Qgis.Success, duration=15)
        
        else :
            self.iface.messageBar().pushMessage("The path doesn't exist", level=Qgis.Warning, duration=45)
            
    
 
    def get_value_default (self, layer, field) :  #ADD
        field_index = layer.fields().indexFromName(str(field))
        value = layer.defaultValueDefinition(field_index)
        defaut_value = value.expression()
        
        return defaut_value



    ### Save a new CURRENT MISSION + CSV FILES.qlr file ###         
    
    def save_template_style (self):       #ADD    
         
         if os.path.exists(self.mynormpath(self.dlg.lineEdit_18.text())):
          
            # Retrieve project layer tree
            arbre_couches = QgsProject.instance().layerTreeRoot()
            
            # Search for "FIELD DATA" group
            groupe_field_data = None
            for enfant in arbre_couches.children():
                if enfant.name() == "FIELD DATA" and isinstance(enfant, QgsLayerTreeGroup):
                    groupe_field_data = enfant
                    break

            # Create an XML structure for the layer tree
            xml_root = ET.Element("qlr")
            layer_tree_group = ET.SubElement(xml_root, "layer-tree-group")
            layer_tree_group.set("expanded", "1")
            layer_tree_group.set("checked", "Qt::Checked")
            layer_tree_group.set("groupLayer", "")
            layer_tree_group.set("name", "")
            
            custom_properties = ET.SubElement(layer_tree_group, "customproperties")
            option = ET.SubElement(custom_properties, "Option")
            
            if groupe_field_data:
                for child in groupe_field_data.children():
                    self.build_layer_tree_xml(child, layer_tree_group)
        
                # Save XML to a file
                chemin_qlr = self.mynormpath(self.dlg.lineEdit_18.text())
                chemin_complet = os.path.join(chemin_qlr, 'CURRENT MISSION+CSV FILES.qlr')
                xml_tree = ET.ElementTree(xml_root)
                xml_tree.write(chemin_complet, encoding="utf-8", xml_declaration=True)
                
            self.iface.messageBar().pushMessage(("A new CURRENT MISSION + CSV FILES.qlr file was saved in " + chemin_qlr), level=Qgis.Success, duration=15)
        
             
    # Builds the XML structure of the layer tree recursively
    def build_layer_tree_xml(self, layer, parent_element):    #ADD    
    
        # If it's a group :
        if isinstance(layer, QgsLayerTreeGroup):
            group_element = ET.SubElement(parent_element, "layer-tree-group")
            group_element.set("expanded", "1")
            group_element.set("checked", "Qt::Checked")
            group_element.set("groupLayer", "")
            group_element.set("name", layer.name())
            custom_properties = ET.SubElement(group_element, "customproperties")
            option = ET.SubElement(custom_properties, "Option")
            for child in layer.children():
                self.build_layer_tree_xml(child, group_element)
        
        # If it's a layer :
        elif isinstance(layer, QgsLayerTreeLayer):
            layer_element = ET.SubElement(parent_element, "layer-tree-layer")
            layer_element.set("providerKey", "ogr")
            layer_element.set("expanded", "1")
            layer_element.set("checked", "Qt::Checked")
            layer_element.set("id", layer.layerId())
            layer_element.set("patch_size", "-1,-1")
            layer_element.set("legend_split_behavior", "0")
            layer_element.set("name", layer.name())
            layer_element.set("source", layer.layer().source())
            layer_element.set("legend_exp", "")
            custom_properties = ET.SubElement(layer_element, "customproperties")
            option = ET.SubElement(custom_properties, "Option")
                
    
    
   ###############################################################################
   ###                              Reset windows                              ###
   ###############################################################################
    
    def resetWindow_import_data(self):

        self.dlg.lineEdit_13.clear()
        self.dlg.tableWidget1.setRowCount(0)
        self.dlg.tableWidget2.setRowCount(0)
        self.dlg.tableWidget3.setRowCount(0)
       
     
    def resetWindow_fieldwork_preparation(self):
        self.dlg.lineEdit_8.clear()
        self.dlg.lineEdit_3.clear()
        self.dlg.lineEdit_38.clear()
        self.dlg.lineEdit_27.clear()
        self.dlg.lineEdit_9.clear()
        self.dlg.lineEdit_10.clear()
        self.dlg.lineEdit_39.clear()        
        
        
    def resetWindow_data_management (self) :
        self.dlg.lineEdit_11.clear()
        self.dlg.lineEdit_26.clear()
        self.dlg.lineEdit_37.clear()
        self.dlg.lineEdit_7.clear()
        self.dlg.lineEdit_53.clear()
   
    

    ###############################################################################
    #########      Connecting Pushbuttons to LineEdits content        #############
    ############################################################################### 
      

    
    def select_dst_directory(self):
        filename = QFileDialog.getExistingDirectory(None, "Select Folder")

        self.dlg.lineEdit_3.setText(filename)
    
    def select_directory(self,widget,prompt):
        filename = QFileDialog.getExistingDirectory(None, prompt)

        widget.setText(filename)

    def select_main_project(self):
        filename, _filter = QFileDialog.getOpenFileName(None, "Select Main Project File")

        self.dlg.lineEdit_11.setText(filename)
    
    def select_sub_project(self):
        filename, _filter = QFileDialog.getOpenFileName(None, "Select Sub-Project File")

        self.dlg.lineEdit_26.setText(filename)
    
    def select_merged_directory(self):
        filename = QFileDialog.getExistingDirectory(None, "Select Destination Merged Folder")

        self.dlg.lineEdit_37.setText(filename)
        
    def select_file_to_import(self):
        filename, _filter = QFileDialog.getOpenFileName(None, "Select Import layer")
        
        self.dlg.lineEdit_13.setText(filename)
        
    def select_export_directory(self):
        filename = QFileDialog.getExistingDirectory(None, "Select Export Folder")
    
        self.dlg.lineEdit_7.setText(filename)

    def select_file_source_path_photo(self):       #ADD
        filename = QFileDialog.getExistingDirectory(None, "Select source path of your field pictures")
        
        self.dlg.lineEdit_14.setText(filename)
        
    def select_file_export_template_style(self):       #ADD
        filename = QFileDialog.getExistingDirectory(None, "Select export path of your new project style template")
        
        self.dlg.lineEdit_18.setText(filename)    

  
    def select_clip_poly(self):
        filename, _filter = QFileDialog.getOpenFileName(None, "Select Clip Polygon")
        
        self.dlg.lineEdit_8.setText(filename)

  
    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&WAXI_QF'),
                action)
            self.iface.removeToolBarIcon(action)


    def update_combobox_delete (self):
        
        self.dlg.comboBox_delete.clear()
        
        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_99_CSV_files = os.path.join(os.path.dirname(WAXI_projet_path), "0. FIELD DATA/99. CSV FILES/")
        
        if os.path.exists(emplacement_99_CSV_files):
            fichier_delete = read_csv(emplacement_99_CSV_files + self.dlg.comboBox.currentText() + ".csv", encoding="latin_1", sep=";")
            list_combobox_delete = list(fichier_delete['Valeur'])
            list_combobox_delete = [str(item) for item in list_combobox_delete]
        
        self.dlg.comboBox_delete.addItems(list_combobox_delete)
        
    def fill_ComboBox(self): 
        self.dlg.comboBox_merge1_2.clear()
        self.dlg.comboBox_merge2_2.clear()
        

        # List of the QGIS layers 
        couches = QgsProject.instance().mapLayers()

        for coucheId, couche in couches.items():
            if isinstance(couche, QgsVectorLayer) and not couche.dataProvider().dataSourceUri().lower().endswith('.csv') and couche.name() !="African borders_PG" : 
                self.dlg.comboBox_merge1_2.addItem(couche.name(), coucheId)
                self.dlg.comboBox_merge2_2.addItem(couche.name(), coucheId)
    
    
    def fill_ComboBox_layers_user(self): #ADD
        self.dlg.comboBox_layers_user.clear()

        # List of the QGIS layers 
        couches = QgsProject.instance().mapLayers()

        for coucheId, couche in couches.items():
            
            # Select all non CSV layers of the QGIS project 
            if isinstance(couche, QgsVectorLayer) and not couche.dataProvider().dataSourceUri().lower().endswith('.csv') and couche.name() !="African borders_PG" :     
                self.dlg.comboBox_layers_user.addItem(couche.name(), coucheId)
            
    
    def update_ComboBox (self):
        self.fill_ComboBox()
        self.fill_ComboBox_layers_user() #ADD


    ###############################################################################
    ########                 Tooltips (just for information)           ############
    ###############################################################################

    
    def define_tips(self):
        Value_tooltip = '<p>Value of Item to be stored in csv File selected from List Name dropdown menu.</p>'
        Description_tooltip = '<p>Additional info for Item to be stored in csv File selected from List Name dropdown menu.</p>'
        Clip_Polygon_tooltip = '<p>Path to clipping polygon shapefile- Leave blank if you want to use the current QGIS Canvas rectangle.</p>'
        Clip_path_tooltip = '<p>Path to new clipped QGIS project directory.</p>'
        Export_path_tooltip = '<p>Path to directory to store combined layers.</p>'
        Proj_name_tooltip = '<p>Name of Project, e.g. Username & date.</p>'
        Proj_region_tooltip = '<p>Region project applies to e.g. Sefwi Belt.</p>'
        Merge_main_tooltip = '<p>Path to directory of global QGIS Project.</p>'
        Merge_sub_tooltip = '<p>Path to directory of local QGIS Project.</p>'
        Merge_output_tooltip = '<p>Path to directory of newly merged QGIS Project.</p>'
        Csv_list_tooltip = 'Select CSV file to add item to'
        Epsilon_tooltip = 'The radius of the circle to be created around each data point to check the density (in metres)'
        Auto_on = 'Turn on autoincrementing of Stop Number behaviour when a new Stop is added'
        Auto_off = 'Turn off autoincrementing of Stop Number behaviour when a new Stop is added'

        Clip_tooltip='Provide an output path (and optional clipping polygon) \nto clip the all WAXI QFIELD layers of current project, retaining directory structure. \nIf no polygon is defined, it will clip to the current Canvas (field of view) of the open project'
        Add_item_tooltip='Chose the CSV file you want to add to, and define the \nValue & Description for a new field that will appear in the dropdown menus in QFIELD'
        Export_tooltip='Provide an output path to combine similar layers into \none of three shapefiles (structure polygons, structure points and lithologies)'
        Update_tooltip='Provide new Name and Region info for project'
        Merge_tooltip='Provide paths to the global QGIS project, \nthe local one you have been working on and the output directory that\n will store the merged projects, with duplicates removed.'
        Virtualstop_tooltip = 'Combine all point layers to get virtual Stop IDS'
        Autoincrement_tooltip= 'Toggle autoincrementing of Stop Number behaviour when a new Stop is added'

        gtCircles_tooltip= 'Select Checkbox to switch to Great Circle Display for Stereonet Plugin'
        contours_tooltip= 'Select Checkbox to add Contour Display for Stereonet Plugin'
        kinematics_tooltip= 'Select Checkbox to add kinematics for Lineation Display for Stereonet Plugin'
        linPlanes_tooltip= 'Select Checkbox to add Associated Great Circles to Lineation Display for Stereonet Plugin'
        rose_tooltip= 'Select Checkbox to display rose diagram instead of stereoplot in Stereonet Plugin'
        stereonet_tooltip= 'Select Checkbox to control Display behaviour for Stereonet Plugin'

        # Titles
        self.dlg.groupBox_4.setToolTip(Clip_tooltip)
        self.dlg.label_37.setToolTip(Add_item_tooltip)
        self.dlg.groupBox_10.setToolTip(Export_tooltip)
        self.dlg.groupBox_6.setToolTip(Update_tooltip)
        self.dlg.groupBox_11.setToolTip(Virtualstop_tooltip)
        self.dlg.groupBox_7.setToolTip(Autoincrement_tooltip)
        
        
        # Project Parameters 
        self.dlg.projName_pushButton.setToolTip("Update project name")
        self.dlg.merge_pushButton.setToolTip("Merge projects")
        self.dlg.merge_layers_pushButton_2.setToolTip("Merge two QGIS layers")
        self.dlg.clip_pushButton.setToolTip("Clip to current canvas")
        self.dlg.lineEdit_9.setToolTip(Proj_name_tooltip)
        self.dlg.lineEdit_10.setToolTip(Proj_region_tooltip)

        
        # CSV 
        self.dlg.csv_pushButton.setToolTip ("Add new item to CSV file")
        self.dlg.csv_pushButton_2.setToolTip ("Delete an item from CSV file")
        
        
        # Stop 
        self.dlg.autoinc_pushButton.setToolTip("Toggle Auto-Increment of Stop numbers")
        self.dlg.virtual_pushButton.setToolTip("Create virtual stops")
        
        # Import Data 
        self.dlg.lineEdit_13.setToolTip("Select the file you want to load")
        self.dlg.pushButton_8.setToolTip("Process the file you want to load")
        
        
        self.dlg.pushButton_11.setToolTip("Go Back")
        self.dlg.pushButton_9.setToolTip("All columns name are suitable for you")
        
        self.dlg.pushButton_12.setToolTip("Go Back")
        self.dlg.pushButton_10.setToolTip("All lithologies are suitable for you")
        
        self.dlg.pushButton_14.setToolTip("Import processed data into QGIS")
        
        self.dlg.pushButton_13.setToolTip("Reset this window")
        self.dlg.pushButton_19.setToolTip("Reset this window")
        self.dlg.pushButton_22.setToolTip("Reset this window")
        
     
        # Export Data 
        self.dlg.export_pushButton.setToolTip("Export layers")
        
        # Stereo 
        self.dlg.stereonet_pushButton.setToolTip("Update setting of stereonet display")
        
        
        # Help 
        #self.dlg.pushButton_33.setToolTip("Click here to access to WAXI website")
        #self.dlg.pushButton_30.setToolTip("Click here to access to AMIRA website")
        #self.dlg.pushButton_32.setToolTip("Click here to access to CET website")
        #self.dlg.pushButton_31.setToolTip("Click here to access to the WAXI Zenodo page")
        
        #self.dlg.pushButton_35.setToolTip("Click here to access to the WAXI publications")
        #self.dlg.pushButton_36.setToolTip("Click here to access to the WAXI theses")
        
        
        # RadioButtons
        self.dlg.radioButtonOn.setToolTip(Auto_on)
        self.dlg.radioButtonOff.setToolTip(Auto_off)

        # LineEdit
        self.dlg.lineEdit_38.setToolTip(Value_tooltip)
        self.dlg.lineEdit_27.setToolTip(Description_tooltip)

        self.dlg.lineEdit_8.setToolTip(Clip_Polygon_tooltip)
        self.dlg.pushButton_6.setToolTip(Clip_Polygon_tooltip)

        self.dlg.lineEdit_3.setToolTip(Clip_path_tooltip)
        self.dlg.pushButton.setToolTip(Clip_path_tooltip)

        self.dlg.lineEdit_7.setToolTip(Export_path_tooltip)
        self.dlg.pushButton_5.setToolTip(Export_path_tooltip)

        self.dlg.lineEdit_11.setToolTip(Merge_main_tooltip)
        self.dlg.pushButton_29.setToolTip(Merge_main_tooltip)

        self.dlg.lineEdit_26.setToolTip(Merge_sub_tooltip)
        self.dlg.pushButton_20.setToolTip(Merge_sub_tooltip)

        self.dlg.lineEdit_37.setToolTip(Merge_output_tooltip)
        self.dlg.pushButton_27.setToolTip(Merge_output_tooltip)

        self.dlg.lineEdit_53.setToolTip(Epsilon_tooltip)


        self.dlg.gtCircles_checkBox.setToolTip(gtCircles_tooltip)
        self.dlg.contours_checkBox.setToolTip(contours_tooltip)
        self.dlg.kinematics_checkBox.setToolTip(kinematics_tooltip)
        self.dlg.linPlanes_checkBox.setToolTip(linPlanes_tooltip)
        self.dlg.rose_checkBox.setToolTip(rose_tooltip)




    ###############################################################################
    ####################                   RUN                   ##################
    ############################################################################### 
    def check_version(self):

        project = QgsProject.instance()
        proj_file_path=project.fileName()
        head_tail = os.path.split(proj_file_path)
 
        plugin_version=template_version='0.0.0'
        template_version_file=open(head_tail[0]+'/99. COMMAND FILES - PLUGIN/Version.txt')
        version=template_version_file.readline()
        template_version=version[1:].split('.')
        
        metadata_path = self.mynormpath(os.path.dirname(os.path.realpath(__file__))+"/metadata.txt")
        plugin_version_file=open(metadata_path)
        metadata=plugin_version_file.readlines()
        for line in metadata:
            parts=line.split("=")
            if(len(parts)==2 and parts[0]=='version'):
                plugin_version=parts[1].split('.')
        plugin_version[2]=plugin_version[2].strip()
        print(plugin_version,template_version)

        if(template_version[0]>plugin_version[0] or
            ((template_version[0] == plugin_version[0]) and template_version[1]>plugin_version[1])):
            self.iface.messageBar().pushMessage("ERROR: Template newer than plugin, please update plugin NOW!", level=Qgis.Critical, duration=45)
        elif(template_version[0]<plugin_version[0] or
            ((template_version[0] == plugin_version[0]) and template_version[1]<plugin_version[1])):
            self.iface.messageBar().pushMessage("WARNING: Plugin newer than template, uncertain behaviour!", level=Qgis.Warning, duration=45)
        else:
            self.iface.messageBar().pushMessage("SUCCESS: Plugin and template are compatible!!", level=Qgis.Success, duration=45)

        template_version_file.close()
        plugin_version_file.close()

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        
        import geopandas as gpd
        import fiona 
        self.check_version()

        project = QgsProject.instance()
        proj_file_path=project.fileName()
        head_tail = os.path.split(proj_file_path)
        
        geopackage_path = head_tail[0]+"/0. FIELD DATA/CURRENT MISSION.gpkg"
        
        if os.path.exists(geopackage_path):



            if self.first_start == True:
                self.first_start = False
                
                    
                ### Accessing the main window : QDialog
                self.dlg = WAXI_QFDialog()   
                self.dlg.setFixedSize(1131, 600)
                
            
                ### Connection of PushButtons ### 
                
                # Project_parameters
                self.dlg.projName_pushButton.clicked.connect(self.updateProjectTitle)
                self.dlg.merge_pushButton.clicked.connect(self.mergeProjects)
                self.dlg.merge_layers_pushButton_2.clicked.connect(self.merge_2_layers)

                self.dlg.clip_pushButton.clicked.connect(self.clipToCanvas)
                self.dlg.pushButton_19.clicked.connect(self.resetWindow_fieldwork_preparation)
                
                # Import_data (the first button connects all the other buttons with the correct input parameters as the program runs)
                
                self.dlg.pushButton_8.clicked.connect(self.click_import_data)  
                self.dlg.pushButton_11.clicked.connect(self.Go_Back_table1)
                self.dlg.pushButton_12.clicked.connect(self.Go_Back_table2)
                self.dlg.pushButton_25.clicked.connect(self.Go_Back_table3)
                self.dlg.pushButton_13.clicked.connect(self.click_Reset_This_Window)

                self.dlg.pushButton_user_default.clicked.connect(self.set_user_by_default) #ADD
                self.fill_ComboBox_layers_user() #ADD
                
                self.dlg.pushButton_update_source_photo.clicked.connect(self.update_source_photo) #ADD
                
                
                # Update the repository path for pictures tool (show current defaut_value)

                
                #Sampling_PT = QgsProject.instance().mapLayersByName("Sampling_PT")[0]  #ADD
                #self.dlg.lineEdit_16.setText('./0. FIELD DATA/DCIM/')  #ADD
                
                
                # Save a new CURRENT MISSION+CSV FILES.qlr file
                self.dlg.pushButton_save__project_template_style_2.clicked.connect(self.save_template_style)  #ADD
                
                # Export_data
                self.dlg.export_pushButton.clicked.connect(self.exportData)
                self.dlg.pushButton_22.clicked.connect(self.resetWindow_data_management)
                
                
                # Stop 
                self.dlg.virtual_pushButton.clicked.connect(self.virtualStops)
                self.dlg.autoinc_pushButton.clicked.connect(self.toggleAutoInc)


                # Stereo             
                self.dlg.stereonet_pushButton.clicked.connect(self.set_stereoConfig)
                self.dlg.stereonet_pushButton_2.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("https://github.com/swaxi/qgis-stereonet")))
                
                
                # CSV
                self.dlg.csv_pushButton.clicked.connect(self.addCsvItem) 
                self.dlg.csv_pushButton_2.clicked.connect(self.deleteCsvItem)
        
            
                # HELP 
                
                self.dlg.tableWidget4.setColumnWidth(0, 350) 
                self.dlg.tableWidget4.setColumnWidth(1, 171)
                
                self.dlg.tableWidget4.item(0, 0).setBackground(QColor.fromHsv(0, 0, 240))
                self.dlg.tableWidget4.item(0, 1).setBackground(QColor.fromHsv(0, 0, 240))
                
                self.dlg.tableWidget4.item(1, 0).setBackground(QColor.fromHsv(0, 0, 220))
                self.dlg.tableWidget4.item(1, 1).setBackground(QColor.fromHsv(0, 0, 220))
                
                self.dlg.tableWidget4.item(2, 0).setBackground(QColor.fromHsv(0, 0, 240))
                self.dlg.tableWidget4.item(2, 1).setBackground(QColor.fromHsv(0, 0, 240))
                
                self.dlg.tableWidget4.item(3, 0).setBackground(QColor.fromHsv(0, 0, 220))
                self.dlg.tableWidget4.item(3, 1).setBackground(QColor.fromHsv(0, 0, 220))
                
                self.dlg.tableWidget4.horizontalHeader().setVisible(True)
                self.dlg.tableWidget4.setEditTriggers(QTableWidget.NoEditTriggers)

                
                # Home Page 
                
                # Connection to the Github issues apge site  : https://github.com/swaxi/WAXI_QF/issues/
                self.dlg.pushButton_23.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("https://github.com/swaxi/WAXI_QF/issues/")))

                # Connection to the WAXI site  : https://waxi4.org/
                self.dlg.pushButton_41.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("https://waxi4.org/")))

                # Connection to the help file  : http://13.210.3.244/manual_qfield_plugin/
                self.dlg.pushButton_21.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("http://13.210.3.244/manual_qfield_plugin/")))
                
                #  Connection to the AMIRA site : https://amira.global/
                self.dlg.pushButton_40.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("https://amira.global/")))
                
                #  Connection to the CET site : https://www.cet.edu.au/
                self.dlg.pushButton_37.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("https://www.cet.edu.au/")))
            
                #  Connection to the Zenodo site : https://zenodo.org/records/10147786
                self.dlg.pushButton_34.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("https://zenodo.org/records/10692516")))
            
                #  Connection to the WAXI articles : 
                self.dlg.pushButton_38.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("https://waxi4.org/publications/journal-articles/")))
                self.dlg.pushButton_39.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("https://waxi4.org/publications/theses/")))
            
                
                # PushButtons to search for files on the computer
            
                self.dlg.pushButton_7.clicked.connect(self.select_file_to_import)
                self.dlg.pushButton_6.clicked.connect(self.select_clip_poly)
                self.dlg.pushButton.clicked.connect(self.select_dst_directory)
                self.dlg.pushButton_29.clicked.connect(self.select_main_project)
                self.dlg.pushButton_20.clicked.connect(self.select_sub_project)
                self.dlg.pushButton_27.clicked.connect(self.select_merged_directory)
                self.dlg.pushButton_5.clicked.connect(self.select_export_directory)
                self.dlg.pushButton_15.clicked.connect(self.select_file_source_path_photo) # ADD
                self.dlg.pushButton_17.clicked.connect(self.select_file_export_template_style) # ADD                
                
                self.dlg.comboBox.currentIndexChanged.connect(self.update_combobox_delete)

                # ComboBox for create dropdown list of all csv files
                csv_list = self.mynormpath(os.path.dirname(os.path.realpath(__file__))+"/csv.csv")
                csvs=read_csv(csv_list,names=['name'])
                csv_file_list=[]
                for name in csvs.name:
                    csv_file_list.append(name)
                self.dlg.comboBox.addItems(csv_file_list[:-2])
                
                
                # Combobox Merge 2 layers 
                self.fill_ComboBox()
                QgsProject.instance().layersAdded.connect(self.update_ComboBox)
                QgsProject.instance().layersRemoved.connect(self.update_ComboBox)

                self.define_tips()
                
                
                ### Show the dialog
                self.dlg.show()
                
            result = self.dlg.exec_()

        else:

            self.iface.messageBar().pushMessage("ERROR: A WAXI Template Should be Loaded before using this plugin", level=Qgis.Critical, duration=45)

               
                    
                        
                    
                    

            
              
                
                