# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GEOL_QMAPS
                                 A QGIS plugin
 GEOL_QMAPS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-13
        git sha              : $Format:%H$
        copyright            : (C) 2024 by GEOL_QMAPS
        email                : GEOL_QMAPS
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.gui import QgsMessageBar
from qgis.PyQt.QtCore import (
    QSettings,
    QTranslator,
    QCoreApplication,
    Qt,
    QThread,
    pyqtSignal,
    QUrl,
)
from qgis.PyQt.QtGui import (
    QIcon,
    QColor,
    QBrush,
    QDesktopServices,
    QFont,
    QStandardItemModel,
    QStandardItem,
)
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import (
    QAction,
    QFileDialog,
    QDialog,
    QProgressBar,
    QApplication,
    QMainWindow,
    QDockWidget,
    QVBoxLayout,
    QHBoxLayout,
    QTabWidget,
    QLabel,
    QSizePolicy,
    QTableWidget,
    QTableWidgetItem,
    QPushButton,
    QTableWidget,
    QWidget,
    QComboBox,
    QGroupBox,
    QStyledItemDelegate,
    QListView,
    QButtonGroup,
)

from PyQt5.QtWidgets import (
    QHeaderView
)
from qgis.core import (
    Qgis,
    QgsProject,
    QgsVectorLayer,
    QgsPoint,
    QgsRectangle,
    QgsGeometry,
    QgsField,
    QgsFeature,
    QgsExpression,
    QgsCoordinateTransform,
    QgsCoordinateReferenceSystem,
    QgsApplication,
    QgsProviderRegistry,
    QgsLayerTreeGroup,
    QgsLayerTreeLayer,
    QgsDefaultValue,
    QgsCoordinateTransformContext,
)
from qgis.PyQt.QtCore import QVariant, QUrl
from qgis.utils import plugins, iface
from qgis.utils import qgsfunction
from qgis.PyQt.QtWidgets import QAction, QToolBar
from qgis.core import QgsProject, QgsLayerTreeGroup, QgsLayerDefinition
from qgis.PyQt.QtWidgets import QDockWidget
from qgis.PyQt.QtCore import Qt

import warnings

warnings.filterwarnings("ignore", category=UserWarning, module="\\*")
from osgeo import ogr
import os
import subprocess
import sys
import numpy as np
import shutil
import json
from xml.etree import ElementTree as ET  # ADD
from datetime import datetime
import exifread

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
# from .WAXI_QF_dialog import WAXI_QFDialog
import os.path
from qgis.core import QgsRectangle, Qgis
from qgis.core.additions.edit import edit
import processing
from qgis.core import (
    QgsGeometry,
    QgsWkbTypes,
    QgsProject,
    QgsVectorLayer,
    QgsVectorFileWriter,
    QgsApplication,
    QgsFeature,
    QgsVectorDataProvider,
    QgsField,
)

from scipy.spatial.distance import cdist
from processing.gui.AlgorithmExecutor import execute_in_place
import hashlib


# Libraries for manipulating Excel files
import pandas as pd
import platform

# Library for list copies
from copy import copy

# import warnings
# warnings.simplefilter(action='ignore', category=FutureWarning)


# Library for check the input file nature
from pathlib import Path
from .FieldMove_Import import FM_Import
from .GEOL_QMAPS_dockwidget import GEOL_QMAPSDockWidget
from .ppigrf import igrf, get_inclination_declination

# Importation des bibliothèques situées dans le dossier du plugin
plugin_directory = os.path.dirname(__file__)
biblio_python_directory = os.path.join(plugin_directory, "biblio_Python")
sys.path.append(biblio_python_directory)


class GEOL_QMAPS:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = str(QSettings().value("locale/userLocale"))[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "GEOL_QMAPS_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&GEOL_QMAPS")
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar("GEOL_QMAPS")
        self.toolbar.setObjectName("GEOL_QMAPS")

        # print "** INITIALIZING GEOL_QMAPS"

        self.pluginIsActive = False
        self.dlg = None

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Initialize the attributes so they exist when used later.
        self.create_lithologies = False 
        self.create_structures = False
        self.fichier_output_lithology = None
        self.fichier_output_structures = None

        ## Python library integration
        def install_library(library_name):
            try:
                if platform.system() == "Windows":
                    subprocess.check_call(
                        ["python", "-m", "pip", "install", library_name]
                    )
                else:
                    subprocess.check_call(
                        ["python3", "-m", "pip3", "install", library_name]
                    )
                print(f"Successfully installed {library_name}")
            except subprocess.CalledProcessError as e:
                print(f"Error installing {library_name}: {e}")

        # Library Xlswriter
        """ 
        try:
            import xlsxwriter

        except:
            install_library("xlsxwriter")

        # Library Openpyxl
        try:
            import openpyxl

        except:
            install_library("openpyxl")
        """

        # Library fiona
        try:
            import fiona

        except:
            install_library("fiona")

        # Library FuzzyWuzzy
        try:
            import fuzzywuzzy

        except:
            install_library("fuzzywuzzy")

        """# Library Geopandas
        try:
            import geopandas

        except:
            install_library("geopandas")"""

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("GEOL_QMAPS", message)

   # Lipari colorscale
    def lipari_color(self, score):
        """
        Returns a QColor based on the given normalized score (0 to 100)
        using a Roma colorscale (Cramieri et al.).
        """
        stops = [
            (0, QColor("#FF0000")),  # red
            (50, QColor("#FFFFFF")),  # white
            (100, QColor("#00FF00"))  # green
        ]
        if score <= stops[0][0]:
            return stops[0][1]
        if score >= stops[-1][0]:
            return stops[-1][1]
        for i in range(1, len(stops)):
            if score <= stops[i][0]:
                lower_score, lower_color = stops[i - 1]
                upper_score, upper_color = stops[i]
                t = (score - lower_score) / (upper_score - lower_score)
                r = lower_color.red() + t * (upper_color.red() - lower_color.red())
                g = lower_color.green() + t * (upper_color.green() - lower_color.green())
                b = lower_color.blue() + t * (upper_color.blue() - lower_color.blue())
                return QColor(int(r), int(g), int(b))

    # create legend with colorbar
    def create_legend_widget(self):
        # Create the legend container widget
        legend_container = QWidget()
        legend_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Horizontal layout for the legend container
        h_layout = QHBoxLayout(legend_container)
        h_layout.setContentsMargins(0, 0, 0, 0)
        h_layout.setSpacing(5)

        # Vertical layout for the color bar and top/bottom labels
        v_layout = QVBoxLayout()
        v_layout.setContentsMargins(0, 0, 0, 0)
        v_layout.setSpacing(2)

        top_label = QLabel("highest")
        top_label.setAlignment(Qt.AlignCenter)
        top_label.setFont(QFont("Arial", 6))

        bottom_label = QLabel("lowest")
        bottom_label.setAlignment(Qt.AlignCenter)
        bottom_label.setFont(QFont("Arial", 6))

        # Create the color bar widget (set fixed width and allow vertical expansion)
        color_bar = QLabel()
        color_bar.setFixedWidth(40)
        color_bar.setMinimumHeight(200)
        color_bar.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
        color_bar.setStyleSheet(
            "background: qlineargradient(spread:pad, x1:0, y1:1, x2:0, y2:0, "
            "stop:0 #FF0000, stop:0.5 #FFFFFF, stop:1 #00FF00);"
            "border: 1px solid black;"
        )

        # Add widgets to the vertical layout with the color bar taking extra space
        v_layout.addWidget(top_label, 0)
        v_layout.addWidget(color_bar, 1)
        v_layout.addWidget(bottom_label, 0)

        # Add the vertical layout to the horizontal layout, then add stretch for centering
        h_layout.addLayout(v_layout)
        h_layout.addStretch()

        legend_container.setLayout(h_layout)
        return legend_container

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ":/plugins/GEOL_QMAPS/icon.png"
        self.add_action(
            icon_path,
            text=self.tr("GEOL_QMAPS"),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        # will be set False in run()
        self.first_start = True

    # --------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        # print "** CLOSING GEOL_QMAPS"

        # disconnects
        self.dlg.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dlg = None

        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        # print "** UNLOAD GEOL_QMAPS"

        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&GEOL_QMAPS"), action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    # --------------------------------------------------------------------------

    def check_version(self):

        project = QgsProject.instance()

        plugin_version = template_version = "0.0.0"
        template_version_file_path = self.mynormpath(
            self.basePath + self.dir_99 + "Version.txt"
        )
        template_version_file = open(template_version_file_path, "r")
        version = template_version_file.readline()
        template_version = version[1:].split(".")

        metadata_path = self.mynormpath(
            os.path.dirname(os.path.realpath(__file__)) + "/metadata.txt"
        )
        plugin_version_file = open(metadata_path)
        metadata = plugin_version_file.readlines()
        for line in metadata:
            parts = line.split("=")
            if len(parts) == 2 and parts[0] == "version":
                pversion = parts[1]
                plugin_version = parts[1].split(".")
        plugin_version[2] = plugin_version[2].strip()

        version_text = "Plugin v" + pversion.rstrip() + "  Template " + version
        self.dlg.versions_label.setText(version_text)

        pv = ".".join(plugin_version)
        tv = ".".join(template_version)
        if template_version[0] > plugin_version[0] or (
            (template_version[0] == plugin_version[0])
            and template_version[1] > plugin_version[1]
        ):
            self.iface.messageBar().pushMessage(
                "ERROR: Template {} newer than Plugin {}, please update plugin NOW!".format(
                    pv, tv
                ),
                level=Qgis.Critical,
                duration=45,
            )
        elif template_version[0] < plugin_version[0] or (
            (template_version[0] == plugin_version[0])
            and template_version[1] < plugin_version[1]
        ):
            self.iface.messageBar().pushMessage(
                "WARNING: Plugin {} newer than Template {}, uncertain behaviour! You can get the latest template <a href='https://zenodo.org/records/13374088'>here</a>".format(
                    pv, tv
                ),
                level=Qgis.Warning,
                duration=45,
            )
        else:
            self.iface.messageBar().pushMessage(
                "SUCCESS: Plugin {} and Template {} are compatible!!".format(pv, tv),
                level=Qgis.Success,
                duration=15,
            )

        template_version_file.close()
        plugin_version_file.close()

    def run(self):
        """Run method that loads and starts the plugin"""

        project = QgsProject.instance()
        proj_file_path = project.fileName()
        head_tail = os.path.split(proj_file_path)
        self.basePath = head_tail[0] + "/"
        self.dir_99 = "99_COMMAND_FILES_PLUGIN/"
        self.dir_0 = "0_FIELD_DATA/"
        self.dir_1 = "1_EXISTING_FIELD_DATABASE/"
        self.dir_11 = "11_ORTHOPHOTOGRAPHY-SATELLITE_IMAGERY/"
        self.geopackage_file_path = (
            self.basePath + "/1_EXISTING_FIELD_DATABASE/" + "/COMPILATION.gpkg"
        )

        self.layers_names = [
            "Deformation zones_PG",
            "Local lithologies_PT",
            "Supergene lithologies_PT",
            "Sedimentary lithologies_PT",
            "Volcanoclastic lithologies_PT",
            "Igneous extrusive lithologies_PT",
            "Igneous intrusive lithologies_PT",
            "Metamorphic lithologies_PT",
            "Bedding-Lava flow-S0_PT",
            "Dikes-Sills_PT",
            "Folds_PT",
            "Foliation-cleavage_PT",
            "Fractures_PT",
            "Lineations_PT",
            "Shear zones and faults_PT",
            "Veins_PT",
            "Lithological contacts_PT"
        ]
        self.layers_names_all = [
            "Magnetic susceptibility_PT",
            "Observations_PT",
            "Photographs_PT",
            "Sampling_PT",
            "Stops_PT",
        ]
        self.layers_names_all = self.layers_names_all + self.layers_names

        # self.templateCSV_path = self.basePath + self.dir_99 + "/CSV FILES/"
        self.FM_Import = FM_Import(None)

        if os.path.exists(self.geopackage_file_path):
            if not self.pluginIsActive:
                self.pluginIsActive = True

                # print "** STARTING GEOL_QMAPS"

                # dockwidget may not exist if:
                #    first run of plugin
                #    removed on close (see self.onClosePlugin method)
                if self.dlg == None:
                    # Create the dockwidget (after translation) and keep reference
                    self.dlg = GEOL_QMAPSDockWidget()

                # connect to provide cleanup on closing of dockwidget
                self.dlg.closingPlugin.connect(self.onClosePlugin)

                # show the dockwidget
                # TODO: fix to allow choice of dock location

                # Create the dialog with elements (after translation) and keep reference
                # Only create GUI ONCE in callback, so that it will only load when the plugin is started

                self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dlg)

                # Find existing dock widgets in the right area
                right_docks = [
                    d
                    for d in self.iface.mainWindow().findChildren(QDockWidget)
                    if self.iface.mainWindow().dockWidgetArea(d)
                    == Qt.RightDockWidgetArea
                ]
                # If there are other dock widgets, tab this one with the first one found
                if right_docks:
                    for dock in right_docks:
                        if dock != self.dlg:
                            self.iface.mainWindow().tabifyDockWidget(dock, self.dlg)
                            # Optionally, bring your plugin tab to the front
                            self.dlg.raise_()
                            break

                self.dlg.show()

                self.check_version()

                if self.first_start == True:
                    self.first_start = False

                    ### Accessing the main window : QDialog
                    # self.dlg = WAXI_QFDialog()
                    # self.dlg.setFixedSize(1131, 600)

                    ### Connection of PushButtons ###

                    # Project_parameters
                    self.dlg.projName_pushButton.clicked.connect(
                        self.updateProjectTitle
                    )
                    self.dlg.merge_pushButton.clicked.connect(self.mergeProjects)
                    self.dlg.merge_pushButton_2.clicked.connect(self.removeDuplicates)
                    self.dlg.merge_layers_pushButton_2.clicked.connect(
                        self.merge_2_layers
                    )

                    self.dlg.clip_pushButton.clicked.connect(self.clipToCanvas)
                    self.dlg.pushButton_19.clicked.connect(
                        self.resetWindow_fieldwork_preparation
                    )

                    # Import_data (the first button connects all the other buttons with the correct input parameters as the program runs)

                    self.dlg.pushButton_9.clicked.connect(self.handlePushButton9)
                    self.dlg.pushButton_11.clicked.connect(self.Go_Back_table1)
                    self.dlg.pushButton_12.clicked.connect(self.Go_Back_table2)
                    self.dlg.pushButton_25.clicked.connect(self.Go_Back_table3)
                    self.dlg.pushButton_13.clicked.connect(self.click_Reset_This_Window)

                    self.dlg.pushButton_user_default.clicked.connect(
                        self.set_user_by_default
                    )  # ADD
                    self.fill_ComboBox_layers_user()  # ADD

                    self.dlg.pushButton_update_source_photo.clicked.connect(
                        self.update_source_photo
                    )  # ADD

                    # Save a new CURRENT_MISSION+DICTIONARIES.qlr file
                    self.dlg.pushButton_save__project_template_style_2.clicked.connect(
                        self.save_template_style
                    )  # ADD

                    # Export_data
                    self.dlg.export_pushButton.clicked.connect(self.exportData)
                    self.dlg.pushButton_22.clicked.connect(
                        self.resetWindow_data_management
                    )

                    # Stop
                    self.dlg.virtual_pushButton.clicked.connect(self.virtualStops)
                    """self.dlg.autoinc_on_pushButton.clicked.connect(self.toggleAutoInc)
                    self.dlg.autoinc_off_pushButton.clicked.connect(self.toggleAutoInc)"""

                    # Stereo
                    self.dlg.stereonet_pushButton.clicked.connect(self.set_stereoConfig)
                    self.dlg.stereonet_pushButton_2.clicked.connect(
                        lambda: QDesktopServices.openUrl(
                            QUrl("https://github.com/swaxi/qgis-stereonet")
                        )
                    )

                    # auto inc
                    self.set_qmapsConfig()

                    # CSV
                    self.dlg.csv_pushButton.clicked.connect(self.addCsvItem)
                    self.dlg.csv_pushButton_2.clicked.connect(self.deleteCsvItem)

                    # HELP

                    # Send email to Mark Jessell and Julien Perret
                    self.dlg.pushButton_24.clicked.connect(
                        lambda: QDesktopServices.openUrl(
                            QUrl(
                                "mailto:julien.perret@uwa.edu.au;mark.jessell@uwa.edu.au"
                            )
                        )
                    )
                    self.dlg.pushButton_28.clicked.connect(
                        lambda: QDesktopServices.openUrl(
                            QUrl(
                                "mailto:julien.perret@uwa.edu.au;mark.jessell@uwa.edu.au"
                            )
                        )
                    )

                    # Help

                    # Connection to the Github issues page site  : https://github.com/swaxi/WAXI_QF/issues/
                    self.dlg.pushButton_23.clicked.connect(
                        lambda: QDesktopServices.openUrl(
                            QUrl("https://github.com/swaxi/WAXI_QF/issues/")
                        )
                    )

                    # Connection to the WAXI site  : https://waxi4.org/
                    self.dlg.pushButton_41.clicked.connect(
                        lambda: QDesktopServices.openUrl(QUrl("https://waxi4.org/"))
                    )

                    # Connection to the help file  : https://github.com/swaxi/GEOL-QMAPS/tree/main#5-workflow
                    self.dlg.pushButton_21.clicked.connect(
                        lambda: QDesktopServices.openUrl(
                            QUrl("https://github.com/swaxi/GEOL-QMAPS/tree/main#5-workflow")
                        )
                    )

                    #  Connection to the AMIRA site : https://amira.global/
                    self.dlg.pushButton_40.clicked.connect(
                        lambda: QDesktopServices.openUrl(QUrl("https://amira.global/"))
                    )

                    #  Connection to the CET site : https://www.cet.edu.au/
                    # self.dlg.pushButton_37.clicked.connect(
                    #    lambda: QDesktopServices.openUrl(QUrl("https://www.cet.edu.au/"))
                    # )

                    #  Connection to the Zenodo repository for the corresponding template release:
                    self.dlg.pushButton_34.clicked.connect(
                        lambda: QDesktopServices.openUrl(
                            QUrl("https://doi.org/10.5281/zenodo.15067027")
                        )
                    )

                    #  Connection to the WAXI articles :
                    # self.dlg.pushButton_38.clicked.connect(
                    #    lambda: QDesktopServices.openUrl(
                    #        QUrl("https://waxi4.org/publications/journal-articles/")
                    #    )
                    # )
                    # self.dlg.pushButton_39.clicked.connect(
                    #    lambda: QDesktopServices.openUrl(
                    #        QUrl("https://waxi4.org/publications/theses/")
                    #    )
                    # )

                    # PushButtons to search for files on the computer

                    self.dlg.pushButton_FM_project_select.clicked.connect(
                        self.import_FM_Project
                    )
                    self.dlg.pushButton_7.clicked.connect(self.select_file_to_import)
                    self.dlg.pushButton_6.clicked.connect(self.select_clip_poly)
                    self.dlg.pushButton.clicked.connect(self.select_dst_directory)
                    self.dlg.pushButton_29.clicked.connect(self.select_main_project)
                    self.dlg.pushButton_20.clicked.connect(self.select_sub_project)
                    self.dlg.pushButton_27.clicked.connect(self.select_merged_directory)
                    self.dlg.pushButton_5.clicked.connect(self.select_export_directory)
                    self.dlg.pushButton_15.clicked.connect(
                        self.select_file_source_path_photo
                    )  # ADD
                    self.dlg.pushButton_17.clicked.connect(
                        self.select_file_export_template_style
                    )  # ADD

                    self.dlg.comboBox.currentIndexChanged.connect(
                        self.update_combobox_delete
                    )
                    self.dlg.structure_style_on_pushButton.clicked.connect(
                        self.set_orientation_style
                    )
                    self.dlg.structure_style_off_pushButton.clicked.connect(
                        self.set_orientation_style
                    )

                    self.dlg.merge_current_existing_pushButton_3.clicked.connect(
                        self.merge_current_to_existing
                    )

                    self.dlg.pushButton_use_exif_azimuth.clicked.connect(
                        self.use_exif_azimuth
                    )

                    head_tail = os.path.split(proj_file_path)
                    main_project_path = head_tail[0] + "/"
                    self.dictionaries_path = (
                        main_project_path + self.dir_99 + "/Dictionaries.gpkg"
                    )
                    self.csvs = self.get_csv_list(self.dictionaries_path)
                    self.csvs = self.csvs[1:]

                    # ComboBox for create dropdown list of all csv files
                    self.sorted_csv_combobBox()

                    # set default structural emasurement from project in gui
                    layer = QgsProject.instance().mapLayersByName("Veins_PT")[0]
                    # Find 'Measure' field index
                    field_index = layer.fields().indexFromName("Measure")

                    # Update default field value
                    default_value = layer.defaultValueDefinition(
                        field_index
                    ).expression()

                    if default_value == "'Dip - dip direction'":
                        self.dlg.structure_style_on_pushButton.setChecked(True)
                    else:
                        self.dlg.structure_style_off_pushButton.setChecked(True)

                    # Combobox Merge 2 layers
                    self.fill_ComboBox()
                    QgsProject.instance().layersAdded.connect(self.update_ComboBox)
                    QgsProject.instance().layersRemoved.connect(self.update_ComboBox)

                    self.sheetHashUUID = []
                    self.define_tips()

                    ### Show the dialog
                    self.dlg.show()

                # result = self.dlg.exec_()

        else:

            self.iface.messageBar().pushMessage(
                "ERROR: A Project based on a GEOL-QMAPS Template should be loaded before using this plugin, you can get the template <a href='https://zenodo.org/records/13374088'>here</a>",
                level=Qgis.Critical,
                duration=45,
            )

    ###############################################################################
    ####################         Page 1 : Import data            ##################
    ###############################################################################

    """
    Author: Eliott Betend
    For : WAXI Project (Stage 4) - CET 
    Condition : version de QGIS > 3.22
    """

    ###############################################################################
    ################# Step 0 : Check the input file nature ########################
    ###############################################################################

    def test_input_file_nature(chemin):
        chemin = Path(chemin)

        if chemin.exists():

            # Retrieve the file extension to determine its nature
            extension = chemin.suffix.lower()

            # Tests the nature of the file based on its extension

            if extension == ".shp" or extension == ".gpkg":
                return "Fichier Shapefile ou Geopackage"

            else:
                return "Fichier non compatible"
        else:
            return "Le fichier n'existe pas !"

    ###############################################################################
    ######## Step 1 : Check layer coordinates + Create geometry column ############
    ###############################################################################

    def convert_coordinates_WGS84(self, layer):

        # Selection of all entities in the layer
        layer.selectAll()

        # Creation of a new 'Geometry' column in the layer's attribute table
        layer.startEditing()
        layer.addAttribute(QgsField("Geometry", QVariant.String))

        # Recuperation of CRS (Coordinate Reference System)
        crs = layer.crs()

        # Conversion of coordinates to WGS84
        for feature in layer.selectedFeatures():
            geometrie = feature.geometry()

            transformation = QgsCoordinateTransform(
                crs, QgsProject.instance().crs(), QgsProject.instance()
            )
            geometrie.transform(transformation)

            feature["Geometry"] = geometrie.asWkt()
            layer.updateFeature(feature)

        # Save changes
        layer.commitChanges()
        layer.removeSelection()

        # Refreshing the view in QGIS
        QgsProject.instance().reloadAllLayers()

    ###############################################################################
    # Step 2 : Export the layer in Excel format + Fill Table1 with Columns pairs ##
    ###############################################################################

    def export_layer_fill_Table1(self, layer):
        from fuzzywuzzy import fuzz

        # 1. Load your input file into a DataFrame
        noms_des_champs = [field.name() for field in layer.fields()]
        data_list = []
        for feature in layer.getFeatures():
            ligne = {
                field.name(): (feature[field.name()] if feature[field.name()] is not None else "")
                for field in layer.fields()
            }
            data_list.append(ligne)
        input_file = pd.DataFrame(data_list, columns=noms_des_champs)
        input_file = input_file.astype(str)

        # 2. Load columns_reference_WAXI4.csv
        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_files_WAXI_columns = os.path.join(
            os.path.dirname(WAXI_projet_path),
            self.dir_99 + "/columns_reference_WAXI4.csv",
        )
        column_reference = pd.read_csv(emplacement_files_WAXI_columns)
        list_column_reference = column_reference.columns.tolist()

        # 3. Load columns_reference_fieldnames_aliases_WAXI4.csv
        alias_file_path = os.path.join(
            os.path.dirname(WAXI_projet_path),
            self.dir_99 + "/columns_reference_fieldnames_aliases_WAXI4.csv",
        )
        alias_df = pd.read_csv(alias_file_path)

        # Build the forward alias mapping (real_name → alias) as a class attribute
        self.alias_mapping = dict(
            zip(alias_df.iloc[:, 0].astype(str), alias_df.iloc[:, 1].astype(str))
        )
        # Build the reverse mapping (alias → real_name) as a class attribute
        self.reverse_alias_mapping = {v: k for k, v in self.alias_mapping.items()}

        # Define self.alias_list as a class attribute
        self.alias_list = list(self.alias_mapping.values())
        if "NULL" not in self.alias_list:
            self.alias_list.insert(0, "NULL")

        # 4. Pair creation based on similarity score
        list_column_input = input_file.columns.tolist()
        list_trio_columns = []
        for col in list_column_input:
            list_trio_columns.append([col, "NULL", 0])

        # 5. Fuzzy matching logic
        for k in range(len(list_column_input)):
            best_column = "NULL"
            score = 0
            if list_column_input[k] == "NULL" or list_column_input[k].strip() == "":
                list_trio_columns[k][1] = "NULL"
                list_trio_columns[k][2] = 0
            else:
                for column in list_column_reference:
                    sum_score = 0
                    sum_score += fuzz.token_set_ratio(list_column_input[k], column) * 3
                    contenu_column = column_reference[column]
                    for elt2 in contenu_column:
                        sum_score += fuzz.token_set_ratio(list_column_input[k], str(elt2))
                    if sum_score > score:
                        score = sum_score
                        best_column = column

                # Use the alias from self.alias_mapping if available
                if best_column != "NULL" and best_column in self.alias_mapping:
                    alias_value = self.alias_mapping[best_column]
                else:
                    alias_value = best_column

                list_trio_columns[k][1] = alias_value
                list_trio_columns[k][2] = score

        # Modification: Ensure no duplicate assignments among the alias values
        list_trio_columns_trie = list_trio_columns
        for place1 in range(len(list_trio_columns) - 1):
            test = list_trio_columns[place1][1]
            for place2 in range(len(list_trio_columns) - 1):
                if place1 != place2:
                    if test != "NULL":
                        if test == list_trio_columns[place2][1]:
                            if list_trio_columns[place1][2] > list_trio_columns[place2][2]:
                                list_trio_columns_trie[place2][1] = "NULL"
                                list_trio_columns_trie[place2][2] = 0
                            elif list_trio_columns[place1][2] < list_trio_columns[place2][2]:
                                list_trio_columns_trie[place1][1] = "NULL"
                                list_trio_columns_trie[place1][2] = 0
                            else:
                                if abs(len(list_trio_columns[place1][0]) - len(list_trio_columns[place1][1])) < abs(
                                        len(list_trio_columns[place2][0]) - len(list_trio_columns[place1][1])):
                                    list_trio_columns_trie[place2][1] = "NULL"
                                    list_trio_columns_trie[place2][2] = 0
                                else:
                                    list_trio_columns_trie[place1][1] = "NULL"
                                    list_trio_columns_trie[place1][2] = 0

        ### Populate the table "Database Fields"
        self.dlg.tableWidget1.setColumnCount(3)
        column_names1 = ["Legacy data value", "Assigned standard value", "Modify the assigned value"]
        self.dlg.tableWidget1.setHorizontalHeaderLabels(column_names1)
        self.dlg.tableWidget3.setWordWrap(True)
        self.dlg.tableWidget1.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive) #adjustable width of the columns
        self.dlg.tableWidget1.verticalHeader().setVisible(False) #vertical header (1 to n) invisible

        # Set the header font size
        header_font = self.dlg.tableWidget1.horizontalHeader().font()
        header_font.setPointSize(8)  # Adjust this value as needed
        self.dlg.tableWidget1.horizontalHeader().setFont(header_font)

        # Create a new legend widget and set it in the legend box for Table1
        legend_widget = self.create_legend_widget()
        legend_main_layout = QVBoxLayout(self.dlg.legendbox_3)
        legend_main_layout.setContentsMargins(0, 0, 0, 0)
        legend_main_layout.addWidget(legend_widget, stretch=1, alignment=Qt.AlignHCenter)
        self.dlg.legendbox_3.setLayout(legend_main_layout)

        # Compute the real maximum score among all rows (ignoring "Geometry")
        valid_scores = [score for (old, new, score) in list_trio_columns_trie if old != "Geometry"]
        max_score = max(valid_scores) if valid_scores else 1  # avoid division by zero

        # Set the row count once to the total number of unique structure triplets
        self.dlg.tableWidget1.setRowCount(len(list_trio_columns_trie)-1)

        for k, (old, new, score) in enumerate(list_trio_columns_trie):
            if old != "Geometry":
                # Create and set the legacy value item with custom font
                legacy_item = QTableWidgetItem(str(old))
                legacy_item.setFont(QFont("Arial", 8))  # Adjust font family and size as needed
                self.dlg.tableWidget1.setItem(k, 0, legacy_item)

                # Create and set the assigned value item with custom font
                assigned_item = QTableWidgetItem(str(new))
                assigned_item.setFont(QFont("Arial", 8))
                self.dlg.tableWidget1.setItem(k, 1, assigned_item)

                # Normalize the current row score based on the maximum score found
                new_score = (score / max_score) * 100.0 if max_score > 0 else 0

                # Use the Lipari colorscale helper to get the corresponding color
                new_color = self.lipari_color(new_score)

                # Apply the new color to both legacy and assigned cells
                for column in range(2):
                    item = self.dlg.tableWidget1.item(k, column)
                    if item:
                        item.setBackground(new_color)

                # Forbid editing of the first two columns
                legacy_item.setFlags(legacy_item.flags() & ~Qt.ItemIsEditable)
                assigned_item.setFlags(assigned_item.flags() & ~Qt.ItemIsEditable)

                # Create composite widget for "Modify the assigned value" column:
                modify_widget = QWidget(self.dlg)
                h_layout = QHBoxLayout(modify_widget)
                h_layout.setContentsMargins(0, 0, 0, 0)

                # QComboBox with alias options
                combo = QComboBox(modify_widget)
                for alias in self.alias_list:
                    combo.addItem(alias)
                if new in self.alias_list:
                    combo.setCurrentIndex(self.alias_list.index(new))
                else:
                    combo.setCurrentIndex(0)
                h_layout.addWidget(combo)

                # Connect the combo box so that when the selection changes, update_assigned_value is called
                combo.currentIndexChanged.connect(
                    lambda idx, row=k, combo=combo: self.update_assigned_value(row, combo.currentText()))

                # "Delete" button to remove the assigned alias
                btn_delete = QPushButton("Delete", modify_widget)
                btn_delete.setMinimumHeight(17)
                btn_delete.clicked.connect(lambda state, row=k: self.button_delete1(row))
                h_layout.addWidget(btn_delete)

                modify_widget.setLayout(h_layout)
                self.dlg.tableWidget1.setCellWidget(k, 2, modify_widget)

                # Set cell dimensions
                self.dlg.tableWidget1.resizeRowsToContents()
                self.dlg.tableWidget1.setColumnWidth(0, 185)
                self.dlg.tableWidget1.setColumnWidth(1, 185)
                self.dlg.tableWidget1.setColumnWidth(2, 185)

            # Initialise cell editing status and table state (if required)
            self.row_edit_status = [False] * len(list_trio_columns_trie)
            self.table1States = []
            self.table1States.append(self.getTableState1())

        return input_file

    # Retrieve the status of all tableWidget1 cells
    def getTableState1(self):

        state = []
        for row in range(self.dlg.tableWidget1.rowCount()):
            row_state = []
            for col in range(2):
                item = self.dlg.tableWidget1.item(row, col)

                # Text
                if isinstance(item, QTableWidgetItem):
                    cell_text = item.text()
                    cell_color = (
                        item.background().color().name()
                        if item.background().style() != Qt.NoBrush
                        else None
                    )

                # ComboBox
                elif isinstance(item, QWidget):
                    combo_box = self.dlg.tableWidget1.cellWidget(row, col)
                    if isinstance(combo_box, QComboBox):
                        cell_text = combo_box.currentText()
                    else:
                        cell_text = ""
                    cell_color = (
                        item.background().color().name()
                        if item.background().style() != Qt.NoBrush
                        else None
                    )
                else:
                    cell_text = ""
                    cell_color = None

                cell_state = {"text": cell_text, "color": cell_color}
                row_state.append(cell_state)
            state.append(row_state)

        return state

    # Delete row
    def button_delete1(self, row):

        # Saving the previous state of the displayboard
        self.table1States.append(self.getTableState1())

        for col in range(2):
            item = self.dlg.tableWidget1.item(row, col)
            if item is not None:
                item.setText("-")

        combo_box_item = self.dlg.tableWidget1.cellWidget(row, 1)

        if isinstance(combo_box_item, QComboBox):
            combo_box_item.hide()
            combo_box_item.setCurrentText("-")
            self.dlg.tableWidget1.setCellWidget(row, 1, combo_box_item)

        # Prohibit editing of these cells
        item1 = self.dlg.tableWidget1.item(row, 0)
        item2 = self.dlg.tableWidget1.item(row, 1)
        item1.setFlags(item1.flags() & ~Qt.ItemIsEditable)
        item2.setFlags(item2.flags() & ~Qt.ItemIsEditable)

        self.dlg.tableWidget1.repaint()

    # Modify row if column name didn't match
    def button_edit1(self, row):

        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_files_WAXI_columns = os.path.join(
            os.path.dirname(WAXI_projet_path),
            self.dir_99 + "/columns_reference_WAXI4.csv",
        )

        column_reference = pd.read_csv(emplacement_files_WAXI_columns)
        list_column_reference = column_reference.columns.tolist()

        # CASE 1 : If the line has already been deleted
        if (
            self.dlg.tableWidget1.item(row, 0).text() == "-"
            and self.dlg.tableWidget1.item(row, 1).text() == "-"
        ):
            return

        # CASE 2 : If the button is clicked for the 1st time
        if not self.row_edit_status[row]:

            self.table1States.append(self.getTableState1())

            current_text = self.dlg.tableWidget1.item(row, 1).text()

            combo_box = QComboBox()
            combo_box.addItems(list_column_reference)
            self.dlg.tableWidget1.setCellWidget(row, 1, combo_box)
            combo_box.setCurrentText(current_text)

            item = self.dlg.tableWidget1.item(row, 1)
            item.setFlags(item.flags() | Qt.ItemIsEditable)
            self.row_edit_status[row] = True

        # CASE 3 : f the button is clicked for the 2nd time
        else:
            combo_box = self.dlg.tableWidget1.cellWidget(row, 1)
            item = self.dlg.tableWidget1.item(row, 1)

            # ComboBox
            if isinstance(combo_box, QComboBox):
                selected_text = combo_box.currentText()
                self.dlg.tableWidget1.removeCellWidget(row, 1)

            # Text
            else:
                selected_text = item.text()

            item.setText(selected_text)

            table_state = self.getTableState1()
            cell_state = table_state[row][1]
            original_color = QColor(cell_state["color"])
            item.setBackground(original_color)

            item.setFlags(item.flags() & ~Qt.ItemIsEditable)
            self.row_edit_status[row] = False

        self.dlg.tableWidget1.repaint()

    #Update assigned value
    def update_assigned_value(self, row, new_alias):
        from fuzzywuzzy import fuzz  # ensure fuzz is imported
        legacy_item = self.dlg.tableWidget1.item(row, 0)
        if legacy_item is None:
            return
        legacy_value = legacy_item.text()
        new_score = fuzz.token_set_ratio(legacy_value, new_alias)  # new_score in [0, 100]
        assigned_item = self.dlg.tableWidget1.item(row, 1)
        if assigned_item:
            assigned_item.setText(new_alias)
        else:
            assigned_item = QTableWidgetItem(new_alias)
            self.dlg.tableWidget1.setItem(row, 1, assigned_item)
        # Instead of using HSV, use lipari_color helper:
        new_color = self.lipari_color(new_score)
        legacy_item.setBackground(new_color)
        assigned_item.setBackground(new_color)

        # Set the new background colour for both legacy and assigned value cells
        legacy_item.setBackground(new_color)
        assigned_item.setBackground(new_color)

    def update_assigned_value2(self, row, new_alias):
        from fuzzywuzzy import fuzz
        legacy_item = self.dlg.tableWidget2.item(row, 0)
        if legacy_item is None:
            return
        legacy_value = legacy_item.text()
        new_score = fuzz.token_set_ratio(legacy_value, new_alias)
        assigned_item = self.dlg.tableWidget2.item(row, 1)
        if assigned_item:
            assigned_item.setText(new_alias)
        else:
            assigned_item = QTableWidgetItem(new_alias)
            self.dlg.tableWidget2.setItem(row, 1, assigned_item)
        new_color = self.lipari_color(new_score)
        legacy_item.setBackground(new_color)
        assigned_item.setBackground(new_color)

    def update_assigned_value3(self, row, new_alias):
        from fuzzywuzzy import fuzz  # ensure fuzz is imported
        legacy_item = self.dlg.tableWidget3.item(row, 0)
        if legacy_item is None:
            return
        legacy_value = legacy_item.text()
        new_score = fuzz.token_set_ratio(legacy_value, new_alias)
        assigned_item = self.dlg.tableWidget3.item(row, 1)
        if assigned_item:
            assigned_item.setText(new_alias)
        else:
            assigned_item = QTableWidgetItem(new_alias)
            self.dlg.tableWidget3.setItem(row, 1, assigned_item)
        new_color = self.lipari_color(new_score)
        legacy_item.setBackground(new_color)
        assigned_item.setBackground(new_color)

    # Come Back
    def Go_Back_table1(self):

        if self.table1States:
            previousState = self.table1States.pop()
            for row, row_state in enumerate(previousState):
                for col, cell in enumerate(row_state):
                    # texte de la cellule
                    cell_text = cell["text"]
                    item = self.dlg.tableWidget1.item(row, col)
                    item.setText(cell_text)

                    # couleur de la cellule
                    cell_color = cell["color"]
                    if cell_color:
                        item.setBackground(QColor(cell_color))

        else:
            self.iface.messageBar().pushMessage(
                "No previous action !", level=Qgis.Warning, duration=45
            )

    # Content retrieval of QTableWidget 1 : COLUMNS NAMES CHECK  ##
    def recup_contenu_1(self):
        list_columns_check_OK = []
        new_values_count = {}

        for row in range(self.dlg.tableWidget1.rowCount()):
            if self.dlg.tableWidget1.item(row, 0):
                old = self.dlg.tableWidget1.item(row, 0).text()
                if old != "-":
                    # Retrieve the alias directly from the table
                    if isinstance(self.dlg.tableWidget1.cellWidget(row, 1), QComboBox):
                        alias = self.dlg.tableWidget1.cellWidget(row, 1).currentText()
                    else:
                        alias = self.dlg.tableWidget1.item(row, 1).text()

                    if alias != "NULL":
                        # No more reversing here—store the alias as-is
                        if alias in new_values_count:
                            self.iface.messageBar().pushMessage(
                                f"Erreur: La valeur '{alias}' est en double !",
                                level=Qgis.Warning,
                                duration=45,
                            )
                            return
                        new_values_count[alias] = 1

                        # (old, alias)
                        list_columns_check_OK.append([old, alias])

        list_columns_check_OK.append(["Geometry", "Geometry"])
        return list_columns_check_OK

    ###############################################################################
    ##########    Step 4 : Creation of a DataFrame sorted and checked      ########
    ###############################################################################

    def DataFrame_columns_check(self, input_file, list_columns_check, name_input_file):
        # list_columns_check might look like: [[old_legacy_field, alias], ... ]

        fichier_output = pd.DataFrame()
        list_columns_check3 = []

        for old_legacy_field, alias in list_columns_check:
            if alias != "NULL":
                try:
                    fichier_output[alias] = input_file[old_legacy_field]
                    list_columns_check3.append(alias)
                except KeyError:
                    pass

        # Add a column to specify Geographic Coordinates Reference System
        fichier_output["CRS"] = "WSG84_EPSG:4326"
        list_columns_check3.append("CRS")

        # Add a column to specify INPUT file name
        fichier_output["Source"] = name_input_file.split(".")[0]
        list_columns_check3.append("Source")

        # Add a column for RAW DATA
        fichier_output["Existing databases - raw data"] = None
        list_columns_check3.append("Existing databases - raw data")

        for index, row in input_file.iterrows():
            ligne_raw_data = []

            for column, value in row.items():
                if str(column) != "Geometry":
                    ligne_raw_data.append(f"{column} : {value} ; ")

            fichier_output.at[index, "Existing databases - raw data"] = "".join(
                ligne_raw_data
            )

        self.fichier_output_cp = fichier_output.copy(deep=True)

        return fichier_output, list_columns_check3

    ###############################################################################
    ###########    Step 5 : Fill Table2 with Lithologies pairs     ################
    ###############################################################################

    def fill_Table2(self, fichier_output):

        # from openpyxl import Workbook
        from fuzzywuzzy import fuzz

        # If user never mapped “Lithology - Outcrop Lithology,” skip with a warning:
        if "Lithology - Outcrop Lithology" not in fichier_output.columns:
            self.iface.messageBar().pushMessage(
                "No column named 'Lithology - Outcrop Lithology' found in your data. Lithology Names table will be empty.",
                level=Qgis.Warning,
                duration=10
            )
            return

        value_counts = self.fichier_output_cp["Lithology - Outcrop Lithology"].value_counts().to_dict()

        # List of input lithologies
        list_lithology_input = fichier_output["Lithology - Outcrop Lithology"].tolist()

        list_lithology_reference = self.get_first_column_text(
            self.dictionaries_path, "General__List of all lithologies"
        )

        # Empty list of lithology name pairs (input value, reference value)
        list_trio = []
        for k in range(0, len(list_lithology_input)):
            list_trio.append([list_lithology_input[k], "NULL", 0])

        # Identification with Fuzzywuzzy :
        for k in range(0, len(list_lithology_input)):

            # Initialize similarity score and new name
            score = 0
            new_rock_name = "NULL"

            if list_lithology_input[k] == "NULL" or list_lithology_input[k] == " ":

                list_trio[k][1] = "NULL"
                list_trio[k][2] = 0

            else:

                ## Condition 1 : prefix leuco, micro and meta to be deleted in front of names
                letters = [
                    "áéíóúàèìòùâêîôûäëïöüçÁÉÍÓÚÀÈÌÒÙÂÊÎÔÛÄËÏÖÜÇ",
                    "aeiouaeiouaeiouaeioucAEIOUAEIOUAEIOUAEIOUC",
                ]
                sylables = [
                    ["Micro-", ""],
                    ["micro-", ""],
                    ["Meta-", ""],
                    ["meta-", ""],
                    ["Micro", ""],
                    ["micro", ""],
                    ["Meta", ""],
                    ["meta", ""],
                    # modifiers
                    ["Micro-", ""],
                    ["micro-", ""],
                    ["Meta-", ""],
                    ["meta-", ""],
                    ["Micro", ""],
                    ["micro", ""],
                    ["Meta", ""],
                    [
                        "meta",
                        "",
                    ],
                    # abbreviations
                    [" sst ", "Sandstone"],
                    [" Sst ", "Sandstone"],
                    [" qtzite ", "Quartzite"],
                    [" Qtzite ", "Quartzite"],
                    [" qtz ", "Quartzite"],
                    [" QTZ ", "quartz"],
                    [" lst ", "Limestone"],
                    [" Lst ", "Limestone"],
                    # francophone translations
                    ["Argillite ", "Shale "],
                    ["Argillites ", "Shale "],
                    ["argillite ", "Shale "],
                    ["argillites ", "Shale "],
                    ["Argilite ", "Shale "],  # typo
                    ["Argilites ", "Shale "],  # typo
                    ["argilite ", "Shale "],  # typo
                    ["argilites ", "Shale "],  # typo
                    ["Gres ", "Sandstone "],
                    ["gres ", "Sandstone "],
                    ["Volcaniques ", "Volcanics "],
                    ["Volcanique ", "Volcanic "],
                    ["Volcanosediment ", "Volcanoclastic "],
                    ["Schiste ", "Schist "],
                    ["Schistes ", "Schist "],
                ]
                for i in range(len(letters[0])):
                    list_lithology_input[k] = list_lithology_input[k].replace(
                        letters[0][i], letters[1][i]
                    )

                for i in range(len(sylables)):
                    list_lithology_input[k] = list_lithology_input[k].replace(
                        sylables[i][0], sylables[i][1]
                    )

                for rock_reference in list_lithology_reference:

                    new_score = fuzz.token_set_ratio(
                        list_lithology_input[k], rock_reference
                    )

                    # If the 2 words don't begin with the same letter : -15 penalty on the score
                    if list_lithology_input[k][0].lower() != rock_reference[0].lower():
                        new_score = new_score - 15

                    if new_score > score:
                        score = new_score
                        new_rock_name = rock_reference

                # Add the name that matched the most
                list_trio[k][1] = new_rock_name

                # Add match score
                list_trio[k][2] = score

        # Creation of a lithology checklist for the user
        # Build list_trio_litho_no_duplicate from list_trio_struct by excluding duplicates and triplets with null legacy values
        list_trio_litho_no_duplicate = []
        seen_legacies = set()

        for trio in list_trio:
            legacy_value = str(trio[0]).strip()  # Convert to string and remove surrounding whitespace
            # Skip triplets where the legacy value is "NULL" (case-insensitive) or empty
            if legacy_value.upper() == "NULL" or legacy_value == "":
                continue
            if legacy_value not in seen_legacies:
                seen_legacies.add(legacy_value)
                list_trio_litho_no_duplicate.append(trio)

        ###    Filling 2 : LITHOLOGIES NAME ## input = list_couple     ###

        ### Populate the table "Lithology Names"
        self.dlg.tableWidget2.setColumnCount(3)
        column_names2 = ["Legacy data value", "Assigned standard value", "Modify the assigned value"]
        self.dlg.tableWidget2.setHorizontalHeaderLabels(column_names2)
        self.dlg.tableWidget2.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)  # interactive width of the columns
        self.dlg.tableWidget2.verticalHeader().setVisible(False)  # vertical header (1 to n) invisible
        self.dlg.tableWidget2.setWordWrap(True) # Enable word wrap on the table widget so that cells wrap text

        # Set the header font size
        header_font = self.dlg.tableWidget2.horizontalHeader().font()
        header_font.setPointSize(8)  # Adjust this value as needed
        self.dlg.tableWidget2.horizontalHeader().setFont(header_font)

        # Create a new legend widget and set it in the legend box
        legend_widget = self.create_legend_widget()
        legend_main_layout = QVBoxLayout(self.dlg.legendbox)
        legend_main_layout.setContentsMargins(0, 0, 0, 0)
        legend_main_layout.addWidget(legend_widget, stretch=1, alignment=Qt.AlignHCenter)
        self.dlg.legendbox.setLayout(legend_main_layout)

        # Re-organize the list of unique lithology pairs (sorted in ascending order of score)
        list_trio_litho_no_duplicate = sorted(list_trio_litho_no_duplicate, key=lambda x: x[2], reverse=False)

        # Dynamically compute the maximum score (ignoring any rows with a "-" legacy value)
        valid_scores = [score for (old, new, score) in list_trio_litho_no_duplicate if old != "-"]
        max_score = max(valid_scores) if valid_scores else 1  # Avoid division by zero

        # Set the row count once to the total number of unique structure triplets
        self.dlg.tableWidget2.setRowCount(len(list_trio_litho_no_duplicate))

        for k, (old, new, score) in enumerate(list_trio_litho_no_duplicate):
            # Prepare the legacy text; here we append the count if available
            legacy_text = str(old) + " : " + str(value_counts.get(old, 0))
            legacy_item = QTableWidgetItem(legacy_text)
            legacy_item.setFont(QFont("Arial", 8))
            self.dlg.tableWidget2.setItem(k, 0, legacy_item)

            # Set the assigned value cell
            assigned_item = QTableWidgetItem(str(new))
            assigned_item.setFont(QFont("Arial", 8))
            self.dlg.tableWidget2.setItem(k, 1, assigned_item)

            # Normalize the current row's score relative to the dynamic maximum
            new_score = (score / max_score) * 100.0 if max_score > 0 else 0
            # Get the corresponding color from the Lipari colorscale
            new_color = self.lipari_color(new_score)

            # Apply the color to both legacy and assigned cells
            for column in range(2):
                item = self.dlg.tableWidget2.item(k, column)
                if item:
                    item.setBackground(new_color)

            # Forbid editing of first 2 columns
            item1 = self.dlg.tableWidget2.item(k, 0)
            item2 = self.dlg.tableWidget2.item(k, 1)
            item1.setFlags(item1.flags() & ~Qt.ItemIsEditable)
            item2.setFlags(item2.flags() & ~Qt.ItemIsEditable)

            # Delete and Edit actions:
            modify_widget = QWidget(self.dlg)
            h_layout = QHBoxLayout(modify_widget)
            h_layout.setContentsMargins(0, 0, 0, 0)

            # QComboBox with lithology options (using the reference list of lithologies)
            combo = QComboBox(modify_widget)
            for litho in list_lithology_reference:
                combo.addItem(litho)
            if new in list_lithology_reference:
                combo.setCurrentIndex(list_lithology_reference.index(new))
            else:
                combo.setCurrentIndex(0)
            h_layout.addWidget(combo)

            # Connect the combo box change signal to update the assigned value and recalc the matching score
            combo.currentIndexChanged.connect(
                lambda idx, row=k, combo=combo: self.update_assigned_value2(row, combo.currentText()))

            # "Delete" button remains
            btn_delete = QPushButton("Delete", modify_widget)
            btn_delete.setMinimumHeight(17)
            btn_delete.clicked.connect(lambda state, row=k: self.button_delete2(row))
            h_layout.addWidget(btn_delete)

            modify_widget.setLayout(h_layout)
            self.dlg.tableWidget2.setCellWidget(k, 2, modify_widget)

            # Set cells dimension
            self.dlg.tableWidget2.resizeRowsToContents()
            self.dlg.tableWidget2.setColumnWidth(0, 185)
            self.dlg.tableWidget2.setColumnWidth(1, 185)
            self.dlg.tableWidget2.setColumnWidth(2, 185)

        # Initialize cell editing status + actions performed in table
        self.row_edit_status = [False] * len(list_trio_litho_no_duplicate)
        self.table2States = []
        self.table2States.append(self.getTableState2())

    # Retrieve the status of all tableWidget2 cells
    def getTableState2(self):
        state2 = []
        for row in range(self.dlg.tableWidget2.rowCount()):
            row_state = []
            for col in range(2):
                item = self.dlg.tableWidget2.item(row, col)

                # Text
                if isinstance(item, QTableWidgetItem):
                    cell_text = item.text()
                    cell_color = (
                        item.background().color().name()
                        if item.background().style() != Qt.NoBrush
                        else None
                    )

                # ComboBox
                elif isinstance(item, QWidget):
                    combo_box = self.dlg.tableWidget2.cellWidget(row, col)
                    if isinstance(combo_box, QComboBox):
                        cell_text = combo_box.currentText()
                    else:
                        cell_text = ""
                    cell_color = (
                        item.background().color().name()
                        if item.background().style() != Qt.NoBrush
                        else None
                    )
                else:
                    cell_text = ""
                    cell_color = None

                cell_state = {"text": cell_text, "color": cell_color}
                row_state.append(cell_state)
            state2.append(row_state)
        return state2

    # Delete row
    def button_delete2(self, row):

        self.table2States.append(self.getTableState2())

        for col in range(2):
            item = self.dlg.tableWidget2.item(row, col)
            if item is not None:
                item.setText("-")

        combo_box_item = self.dlg.tableWidget2.cellWidget(row, 1)

        if isinstance(combo_box_item, QComboBox):
            combo_box_text = combo_box_item.currentText()
            combo_box_item.hide()
            combo_box_item.setCurrentText("-")
            self.dlg.tableWidget2.setCellWidget(row, 1, combo_box_item)

        item1 = self.dlg.tableWidget2.item(row, 0)
        item2 = self.dlg.tableWidget2.item(row, 1)
        item1.setFlags(item1.flags() & ~Qt.ItemIsEditable)
        item2.setFlags(item2.flags() & ~Qt.ItemIsEditable)

        self.dlg.tableWidget2.repaint()

    # Come back
    def Go_Back_table2(self):

        if self.table2States:
            previousState = self.table2States.pop()
            for row, row_state in enumerate(previousState):
                for col, cell in enumerate(row_state):

                    cell_text = cell["text"]
                    item = self.dlg.tableWidget2.item(row, col)
                    item.setText(cell_text)

                    cell_color = cell["color"]
                    if cell_color:
                        item.setBackground(QColor(cell_color))

        else:
            self.iface.messageBar().pushMessage(
                "No previous action !", level=Qgis.Warning, duration=45
            )

    ## Retrieving QTableWidget 2 content : LITHOLOGIES NAMES CHECK  ##

    def recup_contenu_2(self):
        list_lithologies_unique_check_OK = []
        for row in range(self.dlg.tableWidget2.rowCount()):
            old = self.dlg.tableWidget2.item(row, 0).text().split(" :")[0]
            if old != "-":
                # Retrieve the alias
                if isinstance(self.dlg.tableWidget2.cellWidget(row, 1), QComboBox):
                    alias = self.dlg.tableWidget2.cellWidget(row, 1).currentText()
                else:
                    alias = self.dlg.tableWidget2.item(row, 1).text()

                # Convert alias → real_name
                real_name = self.reverse_alias_mapping.get(alias, alias)
                list_lithologies_unique_check_OK.append([old, real_name])

        return list_lithologies_unique_check_OK

    ###############################################################################
    ###        Step 7 : Lithologies sorting in differents Excel sheets          ###
    ###############################################################################

    def lithologies_sorting(
        self,
        fichier_output,
        list_columns_check3,
        list_lithologies_unique_check_OK,
        name_input_file,
    ):

        # from openpyxl import Workbook
        from fuzzywuzzy import fuzz

        # Add lithologies to Excel file

        list_old = []
        for k in range(len(list_lithologies_unique_check_OK)):
            list_old.append(list_lithologies_unique_check_OK[k][0])

        fichier_output = fichier_output[fichier_output["Lithology - Outcrop Lithology"].isin(list_old)]
        fichier_output = fichier_output.reset_index(drop=True)

        # We browse the column containing the old lithos in file_output
        for m in range(len(fichier_output["Lithology - Outcrop Lithology"])):

            # We browse the list of unique (old, new) pairs verified by the user
            for k in range(len(list_lithologies_unique_check_OK)):

                if (
                    fichier_output["Lithology - Outcrop Lithology"].iloc[m]
                    == list_lithologies_unique_check_OK[k][0]
                ):
                    fichier_output["Lithology - Outcrop Lithology"].iloc[m] = list_lithologies_unique_check_OK[
                        k
                    ][1]

        ### Sorting lithologies ###

        # Lists of reference rocks from the WAXI4 QGIS project

        litho_local = self.get_first_column_text(
            self.dictionaries_path, "Local lithologies__List of lithologies"
        )
        litho_supergene = self.get_first_column_text(
            self.dictionaries_path, "Supergene lithologies__List of lithologies"
        )
        litho_sedimentary = self.get_first_column_text(
            self.dictionaries_path, "Sedimentary lithologies__List of lithologies"
        )
        litho_volcanoclastic = self.get_first_column_text(
            self.dictionaries_path,
            "Volcanoclastic lithologies__List of lithologies (clast size-based)",
        )
        litho_igneous_extrusive = self.get_first_column_text(
            self.dictionaries_path, "Igneous extrusive lithologies__List of lithologies"
        )
        litho_igneous_intrusive = self.get_first_column_text(
            self.dictionaries_path, "Igneous intrusive lithologies__List of lithologies"
        )
        litho_metamorphic = self.get_first_column_text(
            self.dictionaries_path, "Metamorphic lithologies__List of lithologies"
        )

        ### Creation of the output Workbook ###

        fichier_output_lithology = {}  # create dictionary of pandas dataframes
        project = QgsProject.instance()

        worksheets_lithology = [
            "Local lithologies_PT",
            "Supergene lithologies_PT",
            "Sedimentary lithologies_PT",
            "Volcanoclastic lithologies_PT",
            "Igneous extrusive lithologies_PT",
            "Igneous intrusive lithologies_PT",
            "Metamorphic lithologies_PT",
        ]

        for litho_class in worksheets_lithology:

            # Retrieving the reference layer in QGIS
            layer = project.mapLayersByName(litho_class)[0]

            # Retrieve field names from the attribute table for this layer
            header = [str(field.name()) for field in layer.fields()]

            basename = os.path.basename(name_input_file)
            filename_without_extension = os.path.splitext(basename)[0]
            # Creation of the worksheet
            name_worksheet1 = litho_class + "_" + filename_without_extension
            fichier_output_lithology[name_worksheet1] = pd.DataFrame(columns=header)

        for k in range(0, len(fichier_output["Lithology - Outcrop Lithology"])):

            r = fichier_output["Lithology - Outcrop Lithology"][k]

            # litho_local :
            if r in litho_local and r != "Unknown":
                fichier_output_lithology = self.add_row_to_fichier_output_lithology(
                    k,
                    fichier_output_lithology,
                    fichier_output,
                    "Local lithologies_PT_",
                    list_columns_check3,
                    filename_without_extension,
                )

            # litho_supergene :
            elif r in litho_supergene and r != "Unknown":
                fichier_output_lithology = self.add_row_to_fichier_output_lithology(
                    k,
                    fichier_output_lithology,
                    fichier_output,
                    "Supergene lithologies_PT_",
                    list_columns_check3,
                    filename_without_extension,
                )

            # litho_sedimentary :
            elif r in litho_sedimentary and r != "Unknown":
                fichier_output_lithology = self.add_row_to_fichier_output_lithology(
                    k,
                    fichier_output_lithology,
                    fichier_output,
                    "Sedimentary lithologies_PT_",
                    list_columns_check3,
                    filename_without_extension,
                )

            # litho_volcanoclastic :
            elif r in litho_volcanoclastic and r != "Unknown":
                fichier_output_lithology = self.add_row_to_fichier_output_lithology(
                    k,
                    fichier_output_lithology,
                    fichier_output,
                    "Volcanoclastic lithologies_PT_",
                    list_columns_check3,
                    filename_without_extension,
                )

            # litho_volcanic :
            elif r in litho_igneous_extrusive and r != "Unknown":
                fichier_output_lithology = self.add_row_to_fichier_output_lithology(
                    k,
                    fichier_output_lithology,
                    fichier_output,
                    "Igneous extrusive lithologies_PT_",
                    list_columns_check3,
                    filename_without_extension,
                )

            # litho_plutonic :
            elif r in litho_igneous_intrusive and r != "Unknown":
                """print(k,
                fichier_output_lithology,
                fichier_output,
                "Igneous intrusive lithologies_PT_",
                list_columns_check3,
                filename_without_extension)"""
                fichier_output_lithology = self.add_row_to_fichier_output_lithology(
                    k,
                    fichier_output_lithology,
                    fichier_output,
                    "Igneous intrusive lithologies_PT_",
                    list_columns_check3,
                    filename_without_extension,
                )

            # litho_metamorphic :
            elif r in litho_metamorphic and r != "Unknown":
                fichier_output_lithology = self.add_row_to_fichier_output_lithology(
                    k,
                    fichier_output_lithology,
                    fichier_output,
                    "Metamorphic lithologies_PT_",
                    list_columns_check3,
                    filename_without_extension,
                )
        return fichier_output_lithology

    # add each row to the master dictionary of pandas
    def add_row_to_fichier_output_lithology(
            self,
            k,
            fichier_output_lithology,
            fichier_output,
            name_prefix,
            list_columns_check3,
            filename_without_extension,
    ):
        full_name = name_prefix + filename_without_extension
        header_local = fichier_output_lithology[full_name].columns

        ligne = []
        for col_reference in header_local:
            # Convert real name to alias:
            alias_for_col = self.alias_mapping.get(col_reference, col_reference)
            if alias_for_col in fichier_output.columns:
                ligne.append(fichier_output.at[k, alias_for_col])
            else:
                ligne.append("")

        # If "Reference" is in the columns and not assigned in the DAtabase Fields table, set it to the imported layer name.
        if "Reference" in header_local and "Reference" not in list_columns_check3:
            ref_index = header_local.get_loc("Reference")
            ligne[ref_index] = filename_without_extension
            
        fichier_output_lithology[full_name].loc[len(fichier_output_lithology[full_name])] = ligne
        return fichier_output_lithology

    ###############################################################################
    ###########    Step 8 : Fill Table3 with Structure pairs       ################
    ###############################################################################

    def fill_Table3(self, fichier_output):

        # from openpyxl import Workbook
        from fuzzywuzzy import fuzz

        #Check
        if "Structures - Structure Type" not in fichier_output.columns:
            self.iface.messageBar().pushMessage(
                "No column named 'Structures - Structure Type' found in your data. Structure Types table will be empty.",
                level=Qgis.Warning,
                duration=10
            )
            return

        # List of input structures
        list_structure_input = fichier_output["Structures - Structure Type"].tolist()

        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        emplacement_files_WAXI_columns = os.path.join(
            os.path.dirname(WAXI_projet_path),
            self.dir_99 + "/columns_types_structures_WAXI4.csv",
        )

        Dataframe = pd.read_csv(emplacement_files_WAXI_columns)

        # Empty list of structure name pairs (input value, reference value)

        list_trio_struct = []
        for k in range(0, len(list_structure_input)):
            list_trio_struct.append([list_structure_input[k], "NULL", 0])

        # Structure_type column modified to conform
        for k in range(0, len(list_structure_input)):

            type_structure = list_structure_input[k]

            if type_structure == "NULL" or type_structure == " ":

                list_trio_struct[k][1] = "NULL"
                list_trio_struct[k][2] = 0

            else:
                score = 0
                structure = "NULL"

                # Go through all the boxes in the Excel file to determine the type of structures
                for index, row in Dataframe.iloc[1:].iterrows():
                    for colonne, valeur in row.items():

                        new_score = fuzz.token_set_ratio(type_structure, valeur)

                        if new_score > score:
                            score = new_score
                            structure = colonne

                if score < 50 and (
                    "vein" in type_structure or "veins" in type_structure
                ):
                    list_trio_struct[k][1] = "Veins_PT"
                    list_trio_struct[k][2] = 90

                else:
                    list_trio_struct[k][1] = structure
                    list_trio_struct[k][2] = score

        # Create a structure checklist for the user
        # Build list_trio_struct_no_duplicate from list_trio_struct by excluding duplicates and triplets with null legacy values
        list_trio_struct_no_duplicate = []
        seen_legacies = set()

        for trio in list_trio_struct:
            legacy_value = str(trio[0]).strip()  # Convert to string and remove surrounding whitespace
            # Skip triplets where the legacy value is "NULL" (case-insensitive) or empty
            if legacy_value.upper() == "NULL" or legacy_value == "":
                continue
            if legacy_value not in seen_legacies:
                seen_legacies.add(legacy_value)
                list_trio_struct_no_duplicate.append(trio)

        ###    Filling 3 : STRUCTURE NAME ## input = list_trio_struct_no_duplicate     ###

        ### Populate the table "Structures Types"
        self.dlg.tableWidget3.setColumnCount(3)
        column_names3 = ["Legacy data value", "Assigned standard value", "Modify the assigned value"]
        self.dlg.tableWidget3.setHorizontalHeaderLabels(column_names3)
        self.dlg.tableWidget3.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)  # adjustable width of the columns
        self.dlg.tableWidget3.verticalHeader().setVisible(False)  # vertical header (1 to n) invisible
        self.dlg.tableWidget3.setWordWrap(True) # Enable word wrap on the table widget so that cells wrap text

        # Set the header font size
        header_font = self.dlg.tableWidget3.horizontalHeader().font()
        header_font.setPointSize(8)  # Adjust this value as needed
        self.dlg.tableWidget3.horizontalHeader().setFont(header_font)

        # Create a new legend widget and set it in the legend box
        legend_widget = self.create_legend_widget()
        legend_main_layout = QVBoxLayout(self.dlg.legendbox_2)
        legend_main_layout.setContentsMargins(0, 0, 0, 0)
        legend_main_layout.addWidget(legend_widget, stretch=1, alignment=Qt.AlignHCenter)
        self.dlg.legendbox_2.setLayout(legend_main_layout)

        # Assume list_trio_struct_no_duplicate is a list of structure pairs (old, new, score)
        list_trio_struct_no_duplicate = sorted(list_trio_struct_no_duplicate, key=lambda x: x[2], reverse=False)

        # Dynamically compute the maximum score among rows (ignoring rows where legacy is "-")
        valid_scores = [score for (old, new, score) in list_trio_struct_no_duplicate if old != "-"]
        max_score = max(valid_scores) if valid_scores else 1  # Avoid division by zero

        # Set the row count once to the total number of unique structure triplets
        self.dlg.tableWidget3.setRowCount(len(list_trio_struct_no_duplicate))

        for k, (old, new, score) in enumerate(list_trio_struct_no_duplicate):
            # Create and set the legacy value item with custom font
            legacy_item = QTableWidgetItem(str(old))
            legacy_item.setFont(QFont("Arial", 8))
            self.dlg.tableWidget3.setItem(k, 0, legacy_item)

            # Create and set the assigned value item with custom font
            assigned_item = QTableWidgetItem(str(new))
            assigned_item.setFont(QFont("Arial", 8))
            self.dlg.tableWidget3.setItem(k, 1, assigned_item)

            # Normalize the score dynamically relative to the real maximum
            new_score = (score / max_score) * 100.0 if max_score > 0 else 0
            # Get the color using Lipari colorscale helper (which maps 0-100 to a continuous color)
            new_color = self.lipari_color(new_score)

            # Apply the new color as the background for both cells
            for col in range(2):
                item = self.dlg.tableWidget3.item(k, col)
                if item:
                    item.setBackground(new_color)


            # Forbid editing of first 2 columns
            item1 = self.dlg.tableWidget3.item(k, 0)
            item2 = self.dlg.tableWidget3.item(k, 1)
            item1.setFlags(item1.flags() & ~Qt.ItemIsEditable)
            item2.setFlags(item2.flags() & ~Qt.ItemIsEditable)

            # Create composite widget for "Modify the assigned value" column:
            modify_widget = QWidget(self.dlg)
            h_layout = QHBoxLayout(modify_widget)
            h_layout.setContentsMargins(0, 0, 0, 0)

            # Create a QComboBox for structure choices.
            # (Assuming you extract structure options from your DataFrame)
            structure_options = list(Dataframe.columns)
            combo = QComboBox(modify_widget)
            for option in structure_options:
                combo.addItem(option)
            if new in structure_options:
                combo.setCurrentIndex(structure_options.index(new))
            else:
                combo.setCurrentIndex(0)
            h_layout.addWidget(combo)

            # Connect the combo box signal to update the assigned value and recalc the matching score.
            combo.currentIndexChanged.connect(
                lambda idx, row=k, combo=combo: self.update_assigned_value3(row, combo.currentText())
            )

            # Create the Delete button.
            btn_delete = QPushButton("Delete", modify_widget)
            btn_delete.setMinimumHeight(17)
            btn_delete.clicked.connect(lambda state, row=k: self.button_delete3(row))
            h_layout.addWidget(btn_delete)

            modify_widget.setLayout(h_layout)
            self.dlg.tableWidget3.setCellWidget(k, 2, modify_widget)

            # Set cell dimensions
            self.dlg.tableWidget3.resizeRowsToContents()
            self.dlg.tableWidget3.setColumnWidth(0, 185)
            self.dlg.tableWidget3.setColumnWidth(1, 185)
            self.dlg.tableWidget3.setColumnWidth(2, 185)

        # Initialize cell editing status + actions performed in table
        self.row_edit_status = [False] * len(list_trio_struct_no_duplicate)
        self.table3States = []
        self.table3States.append(self.getTableState3())

    # Retrieve the status of all tableWidget3 cells
    def getTableState3(self):

        state3 = []
        for row in range(self.dlg.tableWidget3.rowCount()):
            row_state = []
            for col in range(2):
                item = self.dlg.tableWidget3.item(row, col)

                # Text
                if isinstance(item, QTableWidgetItem):
                    cell_text = item.text()
                    cell_color = (
                        item.background().color().name()
                        if item.background().style() != Qt.NoBrush
                        else None
                    )

                # ComboBox
                elif isinstance(item, QWidget):
                    combo_box = self.dlg.tableWidget3.cellWidget(row, col)
                    if isinstance(combo_box, QComboBox):
                        cell_text = combo_box.currentText()
                    else:
                        cell_text = ""
                    cell_color = (
                        item.background().color().name()
                        if item.background().style() != Qt.NoBrush
                        else None
                    )
                else:
                    cell_text = ""
                    cell_color = None

                cell_state = {"text": cell_text, "color": cell_color}
                row_state.append(cell_state)
            state3.append(row_state)

        return state3

    # Delete row
    def button_delete3(self, row):

        self.table3States.append(self.getTableState3())

        for col in range(2):
            item = self.dlg.tableWidget3.item(row, col)
            if item is not None:
                item.setText("-")

        combo_box_item = self.dlg.tableWidget3.cellWidget(row, 1)

        if isinstance(combo_box_item, QComboBox):
            combo_box_item.hide()
            combo_box_item.setCurrentText("-")
            self.dlg.tableWidget3.setCellWidget(row, 1, combo_box_item)

        item1 = self.dlg.tableWidget3.item(row, 0)
        item2 = self.dlg.tableWidget3.item(row, 1)
        item1.setFlags(item1.flags() & ~Qt.ItemIsEditable)
        item2.setFlags(item2.flags() & ~Qt.ItemIsEditable)

        self.dlg.tableWidget3.repaint()

    # Come back
    def Go_Back_table3(self):

        if self.table3States:
            previousState = self.table3States.pop()
            for row, row_state in enumerate(previousState):
                for col, cell in enumerate(row_state):

                    cell_text = cell["text"]
                    item = self.dlg.tableWidget3.item(row, col)
                    item.setText(cell_text)

                    cell_color = cell["color"]
                    if cell_color:
                        item.setBackground(QColor(cell_color))

        else:
            self.iface.messageBar().pushMessage(
                "No previous action !", level=Qgis.Warning, duration=45
            )

    ## Retrieving QTableWidget 2 content : LITHOLOGIES NAMES CHECK  ##

    def recup_contenu_3(self):
        """
        Collects the final user-verified mapping for Structures from tableWidget3.
        Returns a list of sublists, each of the form:
          [old_legacy_value, assigned_structure, standard_layer, Type, Kinematics]
        """
        structure_map = []
        # List of standard mappings: each sublist is
        # [legacy value, standard "Structures - Structure Type", standard layer, Type, Kinematics]
        AssignedStructures = [
            ['Lineations - Unknown Kinematics', 'Lineations_PT', 'Unknown', 'Unknown'],
            ['Lineations - Normal-Slip', 'Lineations_PT', 'Unknown', 'Normal-slip'],
            ['Lineations - Reverse-Slip', 'Lineations_PT', 'Unknown', 'Reverse-slip'],
            ['Lineations - Dextral-Slip', 'Lineations_PT', 'Unknown', 'Dextral-slip'],
            ['Lineations - Sinistral-Slip', 'Lineations_PT', 'Unknown', 'Sinistral-slip'],
            ['Lineations_PT - Paleoflow Direction', 'Lineations_PT', 'Paleoflow direction', 'Unknown'],
            ['Lineations_PT - UST', 'Lineations_PT', 'UST', 'Unknown'],
            ['Lineations_PT - Bearing', 'Lineations_PT', 'Bearing lineation', 'Unknown'],
            ['Bedding-Lava flow-S0_PT - Unknown Polarity', 'Bedding-Lava flow-S0_PT', 'Unknown', ''],
            ['Bedding-Lava flow-S0_PT - Normal Polarity', 'Bedding-Lava flow-S0_PT', 'Normal', ''],
            ['Bedding-Lava flow-S0_PT - Reverse Polarity', 'Bedding-Lava flow-S0_PT', 'Inverted', ''],
            ['Foliation-cleavage_PT', 'Foliation-cleavage_PT', '', ''],
            ['Shear zones and faults_PT - Unknown Kinematics', 'Shear zones and faults_PT', 'Unknown', ''],
            ['Shear zones and faults_PT - Normal-Slip', 'Shear zones and faults_PT', 'Normal-slip', ''],
            ['Shear zones and faults_PT - Low-Angle Detachment', 'Shear zones and faults_PT', 'Low-angle detachment',
             ''],
            ['Shear zones and faults_PT - Reverse-Slip', 'Shear zones and faults_PT', 'Reverse-slip', ''],
            ['Shear zones and faults_PT - Dextral-Slip', 'Shear zones and faults_PT', 'Dextral-slip', ''],
            ['Shear zones and faults_PT - Sinistral-Slip', 'Shear zones and faults_PT', 'Sinistral-slip', ''],
            ['Folds_PT - Unknown, Recumbent, Vertical', 'Folds_PT', 'Unknown', ''],
            ['Folds_PT - Anticline-Antiform', 'Folds_PT', 'Antiform', ''],
            ['Folds_PT - Syncline-Synform', 'Folds_PT', 'Synform', ''],
            ['Folds_PT - M-shaped', 'Folds_PT', 'M fold', ''],
            ['Folds_PT - S-shaped', 'Folds_PT', 'S fold', ''],
            ['Folds_PT - Z-shaped', 'Folds_PT', 'Z fold', ''],
            ['Fractures_PT', 'Fractures_PT', '', ''],
            ['Veins_PT', 'Veins_PT', '', ''],
            ['Dikes - Sills_PT', 'Dikes - Sills_PT', '', ''],
            ['Lithological contacts_PT', 'Lithological contacts_PT', '', ''],
        ]
        # Loop through tableWidget3 rows
        for row in range(self.dlg.tableWidget3.rowCount()):
            if self.dlg.tableWidget3.item(row, 0) is None:
                continue
            old_value = self.dlg.tableWidget3.item(row, 0).text().strip()
            if old_value == "-":
                continue

            # Retrieve assigned value from column 1
            if isinstance(self.dlg.tableWidget3.cellWidget(row, 1), QComboBox):
                assigned_value = self.dlg.tableWidget3.cellWidget(row, 1).currentText().strip()
            else:
                assigned_item = self.dlg.tableWidget3.item(row, 1)
                assigned_value = assigned_item.text().strip() if assigned_item else "NULL"

            # Find a matching mapping from AssignedStructures based on the assigned_value
            matching = None
            for mapping in AssignedStructures:
                if mapping[0] == assigned_value:
                    matching = mapping
                    break
            if matching:
                # Create a sublist with five elements:
                # [old_value, assigned_value, standard_layer, Type, Kinematics]
                structure_map.append([old_value, assigned_value, matching[1], matching[2], matching[3]])
            else:
                # No mapping found: use defaults ("Unknown" for layer, empty strings for Type/Kinematics)
                structure_map.append([old_value, assigned_value, "Unknown", "", ""])
        return structure_map

    ###############################################################################
    ######         Step 9 : Structure sorting in differents Excel sheets     ######
    ###############################################################################

    def structure_sorting(self,
                          fichier_output: pd.DataFrame,
                          structure_map: list,
                          list_columns_check3: list,
                          name_input_file: str) -> dict:
        """
        Sorts the rows in fichier_output into multiple structure-type DataFrames
        based on the user-confirmed mapping.
        Each mapping in structure_map is a list with:
          [old_legacy_value, assigned_structure, standard_layer, Type, Kinematics]
        """
        # 1) Build the mapping dictionary.
        map_dict = {}
        for entry in structure_map:
            if len(entry) < 2:
                continue
            old_val = entry[0].strip() if isinstance(entry[0], str) else str(entry[0]).strip()
            assigned = entry[1].strip() if len(entry) > 1 and isinstance(entry[1], str) else str(entry[1]).strip()
            layer = entry[2].strip() if len(entry) > 2 and isinstance(entry[2], str) else "Unknown"
            type_val = entry[3].strip() if len(entry) > 3 and isinstance(entry[3], str) and entry[
                3].strip() != "" else None
            kinematics_val = entry[4].strip() if len(entry) > 4 and isinstance(entry[4], str) and entry[
                4].strip() != "" else None
            map_dict[old_val] = {
                "assigned": assigned,
                "layer": layer,
                "Type": type_val,
                "Kinematics": kinematics_val
            }

        # 2) Update fichier_output with new structure values and auto-fill additional fields.
        if "Structures - Structure Type" in fichier_output.columns:
            if "Type" not in fichier_output.columns:
                fichier_output["Type"] = ""
            if "Kinematics" not in fichier_output.columns:
                fichier_output["Kinematics"] = ""
            if "Standard_Layer" not in fichier_output.columns:
                fichier_output["Standard_Layer"] = ""
            for i in range(len(fichier_output)):
                old_val = fichier_output.loc[i, "Structures - Structure Type"].strip()
                if old_val in map_dict:
                    mapping = map_dict[old_val]
                    fichier_output.loc[i, "Structures - Structure Type"] = mapping["assigned"]
                    fichier_output.loc[i, "Standard_Layer"] = mapping["layer"]
                    if mapping["Type"]:
                        fichier_output.loc[i, "Type"] = mapping["Type"]
                    if mapping["Kinematics"]:
                        fichier_output.loc[i, "Kinematics"] = mapping["Kinematics"]
                else:
                    fichier_output.loc[i, "Structures - Structure Type"] = "Unknown"

        # 3) Create empty DataFrames for each known structure layer.
        project = QgsProject.instance()
        structure_layer_names = [
            "Lineations_PT",
            "Bedding-Lava flow-S0_PT",
            "Foliation-cleavage_PT",
            "Shear zones and faults_PT",
            "Folds_PT",
            "Fractures_PT",
            "Veins_PT",
            "Dikes-Sills_PT",
            "Lithological contacts_PT"
        ]
        fichier_output_structures = {}
        base_filename = os.path.splitext(os.path.basename(name_input_file))[0]

        for struct_layer_name in structure_layer_names:
            layer_list = project.mapLayersByName(struct_layer_name)
            if not layer_list:
                continue
            # For each found layer, define the header from its fields:
            header = [field.name() for field in layer_list[0].fields()]
            # Only add "Reference" if it was not assigned in Table1.
            if "Reference" not in list_columns_check3 and "Reference" not in header:
                header.append("Reference")
            df_key = f"{struct_layer_name}_{base_filename}"
            # Create a new DataFrame with this header.
            fichier_output_structures[df_key] = pd.DataFrame(columns=header)

        # 4) Append each row of fichier_output to the appropriate structure-type DataFrame.
        for i in range(len(fichier_output)):
            standard_layer = (fichier_output.loc[i, "Standard_Layer"]
                              if "Standard_Layer" in fichier_output.columns
                              else fichier_output.loc[i, "Structures - Structure Type"])
            if standard_layer in structure_layer_names:
                df_key = f"{standard_layer}_{base_filename}"
                if df_key not in fichier_output_structures:
                    continue
                target_df = fichier_output_structures[df_key]
                row_to_append = []
                for col_reference in target_df.columns:
                    # For the "Kinematics" field, copy directly from fichier_output.
                    if col_reference.lower() == "kinematics":
                        row_to_append.append(fichier_output.at[i, "Kinematics"])
                    else:
                        alias_for_col = self.alias_mapping.get(col_reference, col_reference)
                        if alias_for_col in fichier_output.columns:
                            row_to_append.append(fichier_output.at[i, alias_for_col])
                        else:
                            row_to_append.append("")
                # If "Reference" exists and was not assigned in Table1, fill it.
                if "Reference" in target_df.columns and "Reference" not in list_columns_check3:
                    ref_index = target_df.columns.get_loc("Reference")
                    row_to_append[ref_index] = base_filename
                target_df.loc[len(target_df)] = row_to_append

        return fichier_output_structures


    ###############################################################################
    ##   Step 9 : Import the 2 fichier_output (lithology + structure) into QGIS  ##
    ###############################################################################

    def import_Excel_create_QGISfile(self, file_lithology, file_structure):

        # from openpyxl import Workbook, load_workbook

        if file_lithology and file_structure:
            workbooks = [file_lithology, file_structure]

        elif file_lithology:
            workbooks = [file_lithology]
            # file_lithology.save(r"C:\\Users\\00073294\\Dropbox\\temp_dropbox\\GEOL-QMAPS_v3.0.10 - test 1 and test 2 for merging tool\\debug.xlsx")

        elif file_structure:
            workbooks = [file_structure]
            # file_structure.save(
            #    r"C:\\Users\\00073294\\Dropbox\\WAXI4\\gis\\####W4S5\\debug.xlsx"
            # )

        else:
            workbooks = []
        self.sheetHashUUID = {}
        for workbook in workbooks:

            # loop through all the sheets in the Excel workbook
            for sheet in workbook:

                # sheet = workbook[sheet_name]

                # Retrieve column names
                headers = list(workbook[sheet].columns)

                # Retrieve geometry column index
                geometry_column_index = headers.index("Geometry")

                # Vector layer creation
                layer_name = sheet
                layer = QgsVectorLayer("Point?crs=epsg:4326", layer_name, "memory")

                if "_PT" in layer_name:
                    name_reference = layer_name.split("_PT")[0]
                    name_reference = name_reference + "_PT"

                elif "_PG" in layer_name:
                    name_reference = layer_name.split("_PG")[0]
                    name_reference = name_reference + "_PG"

                project = QgsProject.instance()
                layer_reference = project.mapLayersByName(name_reference)[0]

                type_field_data = []
                for field in layer_reference.fields():
                    type_donnee = field.typeName()
                    type_field_data.append(type_donnee)

                field_names = layer_reference.fields().names()

                # Add fields name
                layer_fields = []
                compte = 0

                for header in headers:
                    type_donnee = type_field_data[compte]

                    if type_donnee == "String":
                        field = QgsField(header, QVariant.String)
                    elif type_donnee == "Integer":
                        # print("int",header)
                        field = QgsField(header, QVariant.LongLong)
                    elif type_donnee == "Integer64":
                        # print("int64",header)
                        field = QgsField(header, QVariant.LongLong)
                    elif type_donnee == "JSON":
                        field = QgsField(header, QVariant.String)
                    layer_fields.append(field)
                    compte += 1

                layer.dataProvider().addAttributes(layer_fields)
                layer.updateFields()

                # Add fields content by looping through sheet rows
                for index, row in workbook[sheet].iterrows():

                    # Geometry
                    feature = QgsFeature(layer.fields())
                    geometry_wkt = row[geometry_column_index]
                    feature.setGeometry(QgsGeometry.fromWkt(geometry_wkt))

                    # Other fields of the attribute table by looping through sheet columns
                    for i, value in enumerate(row):

                        if field_names[i] == "Existing databases - raw data":
                            hash = hashlib.sha256(value.encode()).hexdigest()

                        type_donnee = type_field_data[i]
                        if type_donnee == "String" or type_donnee == "JSON":
                            if field_names[i] == "UUID":
                                feature.setAttribute(
                                    i, str(hash)
                                )  # relies on 'UUID' field coming after 'Existing databases - raw data' field
                                self.sheetHashUUID[str(hash)] = [new_text]
                            elif (
                                field_names[i] == "Measure" and "Lineations_PT" in sheet
                            ):
                                feature.setAttribute(i, "Vertical plane")
                            elif field_names[i] == "Existing databases - raw data":
                                new_text = {}
                                for pair in value[:-1].split(";"):
                                    if ":" in pair:
                                        key = pair.split(":")[0]
                                        entry = pair.split(":")[1]
                                        new_text[key] = entry
                                feature.setAttribute(i, str(new_text))

                            else:
                                feature.setAttribute(i, str(value))
                        elif type_donnee in ["Integer", "Integer64"]:
                            if value.strip():
                                try:
                                    feature.setAttribute(i, int(float(value.strip())))
                                except ValueError:
                                    feature.setAttribute(i, None)
                    layer.dataProvider().addFeature(feature)
                layer.commitChanges()

                # Add the layer to the QGIS project
                if layer.featureCount() > 0:
                    QgsProject.instance().addMapLayer(layer)
                iface.mapCanvas().refresh()

    ###############################################################################
    ######             5 METHODES globales de la page Import_data          ########
    ###############################################################################

    def method_import_data(self):

        # Retrieve the path of the file to be processed from the computer (input by the user)
        if os.path.exists(self.mynormpath(self.dlg.lineEdit_13.text())):

            path_layer_to_import = self.dlg.lineEdit_13.text()

            # File name retrieval
            segments = path_layer_to_import.split("/")
            name_layer_to_import = segments[-1]

            # Load layer into QGIS
            layer = QgsVectorLayer(path_layer_to_import, name_layer_to_import, "ogr")

            if layer.isValid():
                pass

            else:
                self.iface.messageBar().pushMessage(
                    "Erreur", "Unable to load selected layer !", level=Qgis.Critical
                )

            # Step 1 : Check layer coordinates + Create the Geometry column
            self.convert_coordinates_WGS84(layer)

            # Step 2 : Export the layer in Excel format + Fill Table1 with Columns pairs
            fichier_input = self.export_layer_fill_Table1(layer)

            self.iface.messageBar().pushMessage(
                "Selected File loaded ", "OK", level=Qgis.Success, duration=45
            )

            return fichier_input, name_layer_to_import

        else:
            self.iface.messageBar().pushMessage(
                "Directory not found: " + self.dlg.lineEdit_13.text(),
                level=Qgis.Warning,
                duration=45,
            )

    def method_columns_check_OK(self, fichier_input, name_layer_to_import):

        # Step 3 : Retrieving data from QTableWidget1
        list_columns_check = self.recup_contenu_1()

        # Step 4 : Dataframe creation with sorted and verified columns
        fichier_output, list_columns_check3 = self.DataFrame_columns_check(
            fichier_input, list_columns_check, name_layer_to_import
        )

        if "Lithology - Outcrop Lithology" in list_columns_check3:
            # Step 5 LITHO : Fill Table2 with Lithologies pairs
            self.fill_Table2(fichier_output)

        if "Structures - Structure Type" in list_columns_check3:
            # Step 6 STRUCTURE : Fill Table3 with Structure pairs
            self.fill_Table3(fichier_output)

        self.iface.messageBar().pushMessage(
            "Names of columns checked ", "OK", level=Qgis.Success, duration=45
        )

        # If "Structures - Structure Type" is selected in Table1, display a warning about how to handle linear and planar measurements separately in case their measurements are not in distinct fields.
        if "Structures - Structure Type" in list_columns_check3:
            self.iface.messageBar().pushMessage(
                "Warning",
                "If your data source includes both linear and planar measurements, but dip direction and trend/plunge direction (or dip and plunge, respectively) share the same data fields, please ensure that you import them separately. For planar measurements, assign legacy fields to standard values as follows: select \"Structures – Planar Measurements / Dip Direction\" and \"Structures – Planar Measurements / Dip\". For linear measurements, assign them using \"Structures – Linear Measurements / Trend – Plunge Direction\" and \"Structures – Linear Measurements / Trend – Plunge\".",
                level=Qgis.Warning,
                duration=45
            )

        return fichier_output, list_columns_check3

    #Check lithologies and get the files ready for export to scratch standard layers
    def method_lithologies_check_OK(
        self, name_layer_to_import, fichier_output, list_columns_check3
    ):

        # Step 7 : Retrieving data from QTableWidget2
        list_lithologies_unique_check_OK = self.recup_contenu_2()


        # Step 8 : Organizing lithologies in different sheets of an Excel file
        fichier_output_lithology = self.lithologies_sorting(
            fichier_output,
            list_columns_check3,
            list_lithologies_unique_check_OK,
            name_layer_to_import,
        )
        return fichier_output_lithology

    #Check Structures and get the files ready for export to scratch standard layers
    def method_structures_check_OK(self, fichier_output, list_columns_check3, name_layer_to_import):
        # Step 1: gather user inputs, fill table, etc.

        # Step 2: call self.structure_sorting or any function that builds a dictionary
        structure_map=self.recup_contenu_3()
        fichier_output_structures = self.structure_sorting(
            fichier_output, structure_map, list_columns_check3, name_layer_to_import
        )

        # Step 3: actually return that dictionary
        return fichier_output_structures

    def method_import_data_as_layers(self, fichier_output_lithology, fichier_output_structures):

        # Step 7 : Import the Excel file into QGIS and create different QGIS files
        self.import_Excel_create_QGISfile(fichier_output_lithology, fichier_output_structures)
        self.iface.messageBar().pushMessage(
            "Data imported in the QGIS project ", "OK", level=Qgis.Success, duration=45
        )

    ###############################################################################
    ######                 5 CLICKS de la page Import_data                 ########
    ###############################################################################

    def click_import_data(self):

        fichier_input = 0
        name_layer_to_import = 0
        fichier_input, name_layer_to_import = self.method_import_data()

        # Connect Columns check OK button correctly
        self.fichier_input, self.name_layer_to_import = self.method_import_data()
        self.dlg.pushButton_9.setEnabled(True)
        self.dlg.pushButton_9.clicked.connect(self.handlePushButton9)

    def handlePushButton9(self):
        # Check that the necessary data has been imported
        if hasattr(self, 'fichier_input') and hasattr(self, 'name_layer_to_import'):
            self.click_columns_check_OK(self.fichier_input, self.name_layer_to_import)
        else:
            self.iface.messageBar().pushMessage( "Please import the data first!", level=Qgis.Warning, duration=45)


    def click_columns_check_OK(self, fichier_input, name_layer_to_import):

        fichier_output = pd.DataFrame()
        list_columns_check3 = []

        fichier_output, list_columns_check3 = self.method_columns_check_OK(
            fichier_input, name_layer_to_import
        )

        # Connect Lithologies check OK button correctly
        if "Lithology - Outcrop Lithology" in list_columns_check3:
            self.dlg.pushButton_10.clicked.connect(
                lambda: self.click_lithologies_check_OK(name_layer_to_import, fichier_output, list_columns_check3)
            )

        # Connect Structures check OK button correctly
        if "Structures - Structure Type" in list_columns_check3:
            self.dlg.pushButton_26.clicked.connect(
                lambda: self.click_structure_check_OK(fichier_output,list_columns_check3,name_layer_to_import)
            )

    def click_lithologies_check_OK(self, name_layer_to_import, fichier_output, list_columns_check3):
        """
        Called when pushbutton10 is clicked.
        Uses the helper method_lithologies_check_OK to generate the lithologies DataFrame.
        """
        self.fichier_output_lithology = self.method_lithologies_check_OK(name_layer_to_import, fichier_output, list_columns_check3)
        self.create_lithologies = True
        self.iface.messageBar().pushMessage("Names of lithologies checked ", "OK", level=Qgis.Success, duration=45)

    def click_structure_check_OK(self, fichier_output, list_columns_check3, name_layer_to_import):
        """
        Called when pushbutton26 is clicked.
        Uses the helper method_structures_check_OK to generate the structures DataFrame.
        """
        self.fichier_output_structures = self.method_structures_check_OK(fichier_output, list_columns_check3, name_layer_to_import)
        self.create_structures = True
        self.iface.messageBar().pushMessage("Types of structures checked ", "OK", level=Qgis.Success, duration=45)

    def Generate_Output_QGIS_Layers(self):
        """
        Generates scratch QGIS layers based on the DataFrames produced by the check_OK methods.
        If only lithologies or only structures were checked, only that set of layers is created.
        If both were checked, layers for both are generated.
        """
        # Generate lithologies layers if the flag is set
        if self.create_lithologies is not None and self.fichier_output_lithology is not None and self.create_structures is not None and self.fichier_output_structures is not None:
            self.iface.messageBar().pushMessage("Generating lithologies and structures layers...", level=Qgis.Info, duration=10)
            self.method_import_data_as_layers(self.fichier_output_lithology, self.fichier_output_structures)

        # Generate structures layers if the flag is set
        elif self.create_lithologies is not None and self.fichier_output_lithology is not None:
            self.iface.messageBar().pushMessage("Generating lithologies layers...", level=Qgis.Info, duration=10)
            self.method_import_data_as_layers(self.fichier_output_lithology, None)

        # Generate structures layers if the flag is set
        elif self.create_structures is None and self.fichier_output_structures is None:
            self.iface.messageBar().pushMessage("Generating structures layers...", level=Qgis.Info, duration=10)
            self.method_import_data_as_layers(None, self.fichier_output_structures)

        # Reset the flags after generation
        self.create_lithologies = False
        self.create_structures = False

    def click_Reset_This_Window(self):
        self.resetWindow_import_data()

    ###############################################################################
    ################       Page 2 : Fieldwork preparation           ###############
    ###############################################################################

    def safe_copy_file(self, src_path, dst_path):
        if os.path.exists(src_path):
            shutil.copyfile(src_path, dst_path)
        else:
            print(src_path, "not found")

    def safe_copy_tree(self, src_path, dst_path):
        if os.path.exists(src_path):
            shutil.copytree(src_path, dst_path)
        else:
            print(src_path, "not found")

    ### Clip to Canvas ###

    def clipToCanvas(self):
        # Clips all WAXI QFIELD vector layers to current canvas and
        # saves out layers in a new directory

        if self.dlg.lineEdit_3.text():

            # set up paths
            project = QgsProject.instance()
            proj_file_path = project.fileName()
            head_tail = os.path.split(proj_file_path)

            oldProjPath = head_tail[0] + "/"
            oldGpkgPath = (
                oldProjPath + "/1_EXISTING_FIELD_DATABASE/" + "COMPILATION.gpkg"
            )
            newProjPath = self.mynormpath(self.dlg.lineEdit_3.text()).strip() + "/"
            newGpkgPath = (
                newProjPath + "/1_EXISTING_FIELD_DATABASE/" + "COMPILATION.gpkg"
            )
            shp_list = self.mynormpath(
                os.path.dirname(os.path.realpath(__file__)) + "/shp.csv"
            )

            clip_poly_shp = self.mynormpath(self.dlg.lineEdit_8.text())

            shps = pd.read_csv(shp_list, names=["name", "dir_code"])
            shps = shps.set_index("name")

            # clipping rectangle from shapefile polygon
            if self.dlg.lineEdit_8.text():

                clip_layer = QgsVectorLayer(
                    os.path.split(clip_poly_shp)[0],
                    os.path.split(clip_poly_shp)[1],
                    "ogr",
                )
            # clipping rectangle from Canvas
            else:
                e = self.iface.mapCanvas().extent()

                extent = QgsRectangle(
                    e.xMinimum(), e.yMinimum(), e.xMaximum(), e.yMaximum()
                )  # Replace with the desired extents
                geom = QgsGeometry().fromRect(extent)
                ftr = QgsFeature()
                ftr.setGeometry(geom)
                project = QgsProject.instance()
                crs = project.crs()
                clip_layer = QgsVectorLayer(
                    "Polygon?{}".format(crs), "Test_polygon", "memory"
                )
                with edit(clip_layer):
                    clip_layer.addFeature(ftr)

            # create directory structure

            dirs = [
                newProjPath,
                newProjPath + self.dir_0,
                newProjPath + self.dir_99,
                newProjPath + "/1_EXISTING_FIELD_DATABASE/",
            ]

            for dirpath in dirs:
                if not os.path.exists(self.mynormpath(dirpath)):
                    os.mkdir(self.mynormpath(dirpath))

            # copy over files that are not clipped
            cp_dirs = [
                # "1_EXISTING_FIELD_DATABASE",
                "2_GPS-LOCALITIES_OF_INTEREST",
                "3_GEOCHEMISTRY",
                "4_GEOCHRONOLOGY",
                "5_MINING_AND_EXPLORATION",
                "6_GEOLOGY",
                "7_GEOPHYSICS",
                "8_LAND_USE",
                "9_GEOGRAPHY",
                "10_TOPOGRAPHY",
                # "11_ORTHOPHOTOGRAPHY-SATELLITE_IMAGERY",
                # self.dir_0 + "/DCIM/",
            ]

            for cp_dir in cp_dirs:
                src_path = oldProjPath + cp_dir
                dst_path = self.mynormpath(newProjPath + cp_dir)
                self.safe_copy_tree(src_path, dst_path)

            """src_path = oldProjPath + self.dir_99 + "/Stops_PT_autoinc.qml"
            dst_path = newProjPath + self.dir_99 + "/Stops_PT_autoinc.qml"
            self.safe_copy_file(src_path, dst_path)

            src_path = oldProjPath + self.dir_99 + "/Stops_PT_no_autoinc.qml"
            dst_path = newProjPath + self.dir_99 + "/Stops_PT_no_autoinc.qml"
            self.safe_copy_file(src_path, dst_path)"""

            src_path = oldProjPath + self.dir_99 + "Dictionaries.gpkg"
            dst_path = newProjPath + self.dir_99 + "Dictionaries.gpkg"

            self.safe_copy_file(src_path, dst_path)

            shutil.copyfile(
                proj_file_path,
                newProjPath + "/" + head_tail[1].replace(".qgz", "_clip.qgz"),
            )

            shutil.copyfile(oldGpkgPath, newGpkgPath)

            shutil.copyfile(
                oldProjPath + "/0_FIELD_DATA/" + "CURRENT_MISSION.gpkg",
                newProjPath + "/0_FIELD_DATA/" + "CURRENT_MISSION.gpkg",
            )

            src_path = oldProjPath + self.dir_0 + "/DCIM/"
            dst_path = self.mynormpath(newProjPath + self.dir_0 + "/DCIM/")
            self.safe_copy_tree(src_path, dst_path)

            src_path = oldProjPath + self.dir_11
            dst_path = self.mynormpath(newProjPath + self.dir_11)
            self.safe_copy_tree(src_path, dst_path)

            src_path = oldProjPath + self.dir_0 + "/CURRENT_MISSION+DICTIONARIES.qlr"
            dst_path = newProjPath + self.dir_0 + "/CURRENT_MISSION+DICTIONARIES.qlr"
            self.safe_copy_file(src_path, dst_path)

            src_path = oldProjPath + "/1_EXISTING_FIELD_DATABASE/" + "/COMPILATION.qlr"
            dst_path = newProjPath + "/1_EXISTING_FIELD_DATABASE/" + "/COMPILATION.qlr"
            if os.path.exists(src_path):
                self.safe_copy_file(src_path, dst_path)

            src_path = oldProjPath + self.dir_11 + "/GoogleSatellite_5km_compressed.tif"
            dst_path = newProjPath + self.dir_11 + "/GoogleSatellite_5km_compressed.tif"
            if os.path.exists(src_path):
                self.safe_copy_file(src_path, dst_path)

            in_pref = oldProjPath + self.dir_99
            out_pref = newProjPath + self.dir_99

            copies = [
                [oldGpkgPath, newGpkgPath],
                [in_pref + "columns_reference_WAXI4.csv", out_pref + "columns_reference_WAXI4.csv"],
                [in_pref + "columns_types_structures_WAXI4.csv", out_pref + "columns_types_structures_WAXI4.csv"],
                [in_pref + "stereonet.json", out_pref + "stereonet.json"],
                [in_pref + "Version.txt", out_pref + "Version.txt"],
                [in_pref + "columns_reference_fieldnames_aliases_WAXI4.csv", out_pref + "columns_reference_fieldnames_aliases_WAXI4.csv"],
                [in_pref + "Dictionaries.gpkg", out_pref + "Dictionaries.gpkg"],
                [in_pref + "qmap.json", out_pref + "qmap.json"],
            ]

            for pairs in copies:
                shutil.copyfile(self.mynormpath(pairs[0]), self.mynormpath(pairs[1]))

            # Prepare the output shapefile parameters for clipping

            for layer in project.mapLayers().values():
                # Check if the layer name matches the target name

                """
                if layer.name() in shps.index.tolist():
                if (
                    ("_PG" in layer.name()
                    or "_PT" in layer.name()
                    or "_LN" in layer.name()) and "Compilation_" in layer.name()
                ):"""
                # Get the file path of the layer
                if layer.name().startswith("Compilation_"):
                    input_path = self.mynormpath(layer.dataProvider().dataSourceUri())

                    output_path_gpkg = self.mynormpath(newGpkgPath)

                    processing.run(
                        "native:clip",
                        {
                            "INPUT": input_path,
                            "OVERLAY": clip_layer,
                            "OUTPUT": "ogr:dbname='"
                            + output_path_gpkg
                            + "' table=\""
                            + layer.name()
                            + '" (geom)',
                        },
                    )

                else:
                    pass

            self.iface.messageBar().pushMessage(
                "Files clipped to current extent, saved in directory" + newProjPath,
                level=Qgis.Success,
                duration=15,
            )

        else:
            self.iface.messageBar().pushMessage(
                "Directory not found: " + self.dlg.lineEdit_3.text(),
                level=Qgis.Warning,
                duration=45,
            )

    ### CSV TOOLS ###
    def delete_row_from_csv_layer(
        self, gpkg_path, layer_name, column_name, value_to_delete
    ):
        """
        Delete rows with a specific value from a CSV layer in a GeoPackage.

        Parameters:
            gpkg_path (str): Path to the GeoPackage file.
            layer_name (str): The name of the CSV layer in the GeoPackage.
            column_name (str): The name of the column to search for the value.
            value_to_delete (str): The value in the column to identify rows for deletion.

        Returns:
            None
        """
        import fiona

        # Open the GeoPackage layer
        try:
            with fiona.open(gpkg_path, layer=layer_name, mode="r") as src:
                # Get metadata and features from the layer
                layer_crs = src.crs
                layer_schema = src.schema
                features = list(src)

            # Filter out rows where the specified column matches the value to delete
            updated_features = [
                feature
                for feature in features
                if feature["properties"][column_name] != value_to_delete
            ]

            # Create a backup of the original GeoPackage
            # backup_path = f"{gpkg_path}.bak"
            # os.rename(gpkg_path, backup_path)

            # Write the updated features back to the GeoPackage
            with fiona.open(
                gpkg_path,
                mode="w",
                driver="GPKG",
                layer=layer_name,
                schema=layer_schema,
                crs=layer_crs,
            ) as dst:
                dst.writerecords(updated_features)

            # print(f"Rows with {column_name} = {value_to_delete} have been removed successfully.")
            # print(f"A backup of the original GeoPackage was created at: {backup_path}")

        except Exception as e:
            print(f"Error processing the GeoPackage layer: {e}")

    def add_row_to_csv_layer(self, gpkg_path, layer_name, new_row):
        """
        Add a row to a CSV layer in a GeoPackage.

        Parameters:
            gpkg_path (str): Path to the GeoPackage file.
            layer_name (str): The name of the CSV layer in the GeoPackage.
            new_row (dict): A dictionary representing the new row to add.
                            The keys must match the column names of the layer.

        Returns:
            None
        """
        import fiona

        try:
            # Open the GeoPackage layer in read mode to retrieve metadata
            with fiona.open(gpkg_path, layer=layer_name, mode="r") as src:
                layer_crs = src.crs
                layer_schema = src.schema
                features = list(src)  # Load existing features

            # Validate new_row keys match the schema's properties
            for key in new_row.keys():
                if key not in layer_schema["properties"]:
                    raise ValueError(
                        f"Invalid column name '{key}'. Column does not exist in the layer."
                    )

            # Create a new feature from the new_row
            new_feature = {
                "type": "Feature",
                "geometry": None,  # CSV layers typically don't have geometries
                "properties": new_row,
            }

            # Append the new feature to the features list
            features.append(new_feature)

            """# Create a backup of the original GeoPackage
            backup_path = f"{gpkg_path}.bak"
            os.rename(gpkg_path, backup_path)
            """
            # Write the updated features back to the GeoPackage
            with fiona.open(
                gpkg_path,
                mode="w",
                driver="GPKG",
                layer=layer_name,
                schema=layer_schema,
                crs=layer_crs,
            ) as dst:
                dst.writerecords(features)

            # print(f"Row added successfully to the layer '{layer_name}'.")
            # print(f"A backup of the original GeoPackage was created at: {backup_path}")

        except Exception as e:
            print(f"Error adding row to the GeoPackage layer: {e}")

    ### Option 1 :  ADD a single value/description pair to any CSV file in the WAXI QFIELD template
    def addCsvItem(self):
        """
        Adds a new item to a CSV layer and updates the corresponding layer in QGIS.
        This method retrieves the current layer from a combo box, creates a new row with values
        from a line edit, and adds this row to the specified CSV layer. If the current layer
        is related to lithologies, it also updates a general list of all lithologies. The method
        then reloads the CSV layer in QGIS and triggers a repaint to reflect the changes. A
        message is displayed in the QGIS message bar to confirm the addition.
        Parameters:
        None
        Returns:
        None
        """

        # emplacement_99_CSV_files = self.templateCSV_path

        # csv_file = str(self.dlg.comboBox.currentText())

        # csv_updates = [layer_name, "Lithologies"]
        # for csv_file in csv_updates:
        # chemin_fichier_CSV_modifier = self.mynormpath(
        # emplacement_99_CSV_files + csv_file + ".csv"
        # )
        current_layer = self.dlg.comboBox.currentText()
        new_row = {
            "Valeur": str(self.dlg.lineEdit_38.text()),
            "Description": str(self.dlg.lineEdit_38.text()),
        }

        self.add_row_to_csv_layer(self.dictionaries_path, current_layer, new_row)

        if "List of lithologies" in current_layer:
            self.add_row_to_csv_layer(
                self.dictionaries_path, "General__List of all lithologies", new_row
            )

        # Updates the layer in QGIS

        if current_layer.startswith("General__"):
            layer_csv = QgsProject.instance().mapLayersByName(
                current_layer.replace("__", " // ")
            )[0]
        else:
            layer_csv = QgsProject.instance().mapLayersByName(
                current_layer.replace("__", "/")
            )[0]

        if layer_csv.isValid():
            self.reload_csv(self.dictionaries_path, layer_csv, current_layer)
            if "List of lithologies" in current_layer:
                self.reload_csv(
                    self.dictionaries_path,
                    layer_csv,
                    "General__List of all lithologies",
                )

        else:
            print("Could not reload csv file")

        layer_csv.triggerRepaint()
        self.iface.messageBar().pushMessage(
            "Item "
            + str(self.dlg.lineEdit_38.text())
            + " "
            + str(self.dlg.lineEdit_38.text())
            + " added to "
            + current_layer,
            level=Qgis.Success,
            duration=15,
        )
        self.update_combobox_delete()

    def reload_csv(self, dictionaries_path, layer_csv, current_layer):
        # Clear all features in the existing layer
        layer_csv.startEditing()
        layer_csv.dataProvider().truncate()  # Deletes all features efficiently
        layer_csv.commitChanges()

        # Load new data from the CSV file
        new_table = QgsVectorLayer(
            f"{dictionaries_path}|layername={current_layer}", current_layer, "ogr"
        )

        if new_table.isValid():
            # Ensure the schema matches (field names and types)
            new_fields = new_table.fields()
            existing_fields = layer_csv.fields()

            if new_fields.names() != existing_fields.names():
                print(
                    "The schema of the new data does not match the existing layer. Update failed."
                )
            else:
                # Add new features to the existing layer
                layer_csv.startEditing()
                features = new_table.getFeatures()
                for feature in features:
                    layer_csv.dataProvider().addFeatures([feature])
                layer_csv.commitChanges()
        else:
            print(f"Failed to load new data from {dictionaries_path}.")

    ### Option 2 :  DELETE a single value to any CSV file in the WAXI QFIELD template
    def deleteCsvItem(self):

        # emplacement_99_CSV_files = self.templateCSV_path

        current_layer = str(self.dlg.comboBox.currentText())
        delete_item = self.dlg.comboBox_delete.currentText()

        self.delete_row_from_csv_layer(
            self.dictionaries_path, current_layer, "Valeur", delete_item
        )

        if "List of lithologies" in current_layer:

            self.delete_row_from_csv_layer(
                self.dictionaries_path,
                "General__List of all lithologies",
                "Valeur",
                delete_item,
            )
        if current_layer.startswith("General__"):
            layer_csv = QgsProject.instance().mapLayersByName(
                current_layer.replace("__", " // ")
            )[0]
        else:
            layer_csv = QgsProject.instance().mapLayersByName(
                current_layer.replace("__", "/")
            )[0]

        self.reload_csv(self.dictionaries_path, layer_csv, current_layer)

        # if chemin_fichier_CSV_modifier:
        self.iface.messageBar().pushMessage(
            "Item "
            + str(self.dlg.lineEdit_38.text())
            + " "
            + str(self.dlg.lineEdit_38.text())
            + " removed from "
            + current_layer,
            level=Qgis.Success,
            duration=15,
        )

        self.update_combobox_delete()

    ### Update project name ###

    def updateProjectTitle(self):
        if self.dlg.lineEdit_9.text() and self.dlg.lineEdit_10.text():
            project = QgsProject.instance()
            new_title = self.dlg.lineEdit_9.text() + "/" + self.dlg.lineEdit_10.text()
            project.setTitle(new_title)
            project.write()
            self.iface.messageBar().pushMessage(
                "Project title updated to " + new_title, level=Qgis.Success, duration=45
            )

    def apply_qml_style(self, layer, qml_path):
        """
        Apply a QML style file to a given layer.

        Parameters:
            layer (QgsMapLayer): The layer to which the style will be applied.
            qml_path (str): Path to the QML style file.

        Returns:
            bool: True if the style was successfully applied, False otherwise.
        """
        if not layer.isValid():
            print(f"Layer {layer.name()} is not valid.")
            return False

        result = layer.loadNamedStyle(qml_path)
        if not result:
            print(f"Failed to apply QML style: {qml_path} {result}")
            return False

        # Refresh the layer to apply the style changes
        layer.triggerRepaint()

        return True

    ### Toggle AutoIncrements of stop number ###
    """def toggleAutoInc(self):
        project = QgsProject.instance()
        proj_file_path = project.fileName()
        head_tail = os.path.split(proj_file_path)

        no_auto_filename = head_tail[0] + "/" + self.dir_99 + "/Stops_PT_no_autoinc.qml"
        auto_filename = head_tail[0] + "/" + self.dir_99 + "Stops_PT_autoinc.qml"
        layer = project.mapLayersByName("Stops_PT")[0]
        qmapConfigPath = head_tail[0] + "/" + self.dir_99 +   "/qmap.json"
        if(os.path.exists(no_auto_filename) and os.path.exists(auto_filename)):
            if self.dlg.autoinc_on_pushButton.isChecked():
                self.apply_qml_style(layer,auto_filename)
                self.iface.messageBar().pushMessage(
                    "Auto Incrementing Stop Numbers turned ON",
                    level=Qgis.Success,
                    duration=15,
                )
                qmapConfig = {
                    "autoInc": True,
                }

            else:
                self.apply_qml_style(layer,no_auto_filename)
                self.iface.messageBar().pushMessage(
                    "Auto Incrementing Stop Numbers turned OFF",
                    level=Qgis.Success,
                    duration=15,
                )
                qmapConfig = {
                    "autoInc": False,
                }

            if os.path.exists(qmapConfigPath):
                with open(qmapConfigPath, "w") as outfile:
                    json.dump(qmapConfig, outfile, indent=4)
        else:
            print("An autoinc qml file is missing from the project")"""

    ### Set user by default ###                   #ADD

    def set_user_by_default(self):

        from fuzzywuzzy import fuzz

        if self.dlg.lineEdit_39.text():

            default_value_user_csv = str(self.dlg.lineEdit_39.text())
            liste_users = self.get_first_column_text(
                self.dictionaries_path, "General__List of Users"
            )
            ## User.csv file location
            # WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
            # emplacement_User_file = self.templateCSV_path + "/User list.csv"
            # user_file = pd.read_csv(emplacement_User_file, sep=";", encoding="latin-1")

            ## Test if the user name is already present in the User.csv file
            list_score = []
            # liste_users = list(user_file["Valeur"])

            for test in liste_users:
                new_score = fuzz.token_set_ratio(str(test), default_value_user_csv)
                list_score.append(new_score)

            # If the user name is not in the CSV file, we add it:
            if 100 not in list_score:
                new_row = {
                    "Valeur": default_value_user_csv,
                    "Description": default_value_user_csv,
                }
                self.add_row_to_csv_layer(
                    self.dictionaries_path, "General__List of Users", new_row
                )

                # Updates the layer in QGIS
                layer_user = QgsProject.instance().mapLayersByName(
                    "General // List of Users"
                )[0]

                self.reload_csv(
                    self.dictionaries_path, layer_user, "General__List of Users"
                )
                # QgsProject.instance().reloadAllLayers()

                default_value_user = "'" + str(self.dlg.lineEdit_39.text()) + "'"

            # If the user name is in the CSV file, we choose it:
            else:
                for test in liste_users:
                    new_score = fuzz.token_set_ratio(str(test), default_value_user_csv)
                    if new_score == 100:
                        default_value_user = "'" + test + "'"
                        break

            ## Modification of the User field in QGIS template layers
            self.dlg.button_group = QButtonGroup()
            self.dlg.button_group.addButton(self.dlg.radioButton_All)
            self.dlg.button_group.addButton(self.dlg.radioButton_Some)

            # If the "Change for one layer" radiobutton is checked
            if self.dlg.radioButton_Some.isChecked():
                layer_selected = QgsProject.instance().mapLayersByName(
                    str(self.dlg.comboBox_layers_user.currentText())
                )[0]

                # Find 'User' field index
                field_index = layer_selected.fields().indexFromName("User")

                # Create default value
                default_value = QgsDefaultValue(default_value_user)

                # Update default field value
                layer_selected.setDefaultValueDefinition(field_index, default_value)
                QgsProject.instance().write()

                self.iface.messageBar().pushMessage(
                    str(default_value_user)
                    + " is now the default user for "
                    + str(self.dlg.comboBox_layers_user.currentText()),
                    level=Qgis.Success,
                    duration=15,
                )

            # If the "Change for all layers" radiobutton is checked
            if self.dlg.radioButton_All.isChecked():

                layers = QgsProject.instance().mapLayers()

                for layerId, layer in layers.items():

                    # Select all non CSV layers of the QGIS project
                    if isinstance(
                        layer, QgsVectorLayer
                    ) and not layer.dataProvider().dataSourceUri().lower().endswith(
                        ".csv"
                    ):

                        # Find 'User' field index
                        field_index = layer.fields().indexFromName("User")

                        # Create default value
                        default_value = QgsDefaultValue(default_value_user)

                        # Update default field value
                        layer.setDefaultValueDefinition(field_index, default_value)
                        QgsProject.instance().write()

                self.iface.messageBar().pushMessage(
                    str(default_value_user)
                    + " is now the default user for ALL the layers in the project",
                    level=Qgis.Success,
                    duration=15,
                )

    # set dip/dip direction vs dip/strike RHR

    def set_orientation_style(self):
        if self.dlg.structure_style_on_pushButton.isChecked():
            value = "'Dip - dip direction'"
        else:
            value = "'Strike (right-hand rule) - dip'"

        # Create default value
        default_value = QgsDefaultValue(value)

        shp_list = self.mynormpath(
            os.path.dirname(os.path.realpath(__file__)) + "/shp.csv"
        )

        shps = pd.read_csv(shp_list, names=["name", "dir_code"])
        shps = shps.set_index("name")
        planes = [
            "Dikes-Sills_PT",
            "Folds_PT",
            "Foliation-cleavage_PT",
            "Bedding-Lava flow-S0_PT",
            "Lithological contacts_PT",
            "Shear zones and faults_PT",
            "Veins_PT",
            "Fractures_PT",
            "contacts_LN",
            "Planar structures_LN",
        ]
        for name, data in shps.iterrows():
            if name in planes:
                layer = QgsProject.instance().mapLayersByName(name)[0]
                # Find 'User' field index
                field_index = layer.fields().indexFromName("Measure")

                # Update default field value
                layer.setDefaultValueDefinition(field_index, default_value)

        QgsProject.instance().write()

        self.iface.messageBar().pushMessage(
            str(value) + " is now the default structural style ",
            level=Qgis.Success,
            duration=15,
        )

    ###############################################################################
    ################       Page 3 : Field Data Management           ###############
    ###############################################################################

    ### Merge Projects ### to modifie with the new architecture of the plugin

    def list_csv_files(directory):
        files = []
        for filename in os.listdir(directory):
            path = os.path.join(directory, filename)
            if os.path.isfile(path) and path.split(".")[-1] == "csv":
                files.append(filename)
        return files

    ### Remove multiple instances of the same feature in current project based on their unique ID (UUID field)

    def removeDuplicates(self):

        project = (
            QgsProject.instance()
        )  # assumes one of the projects is actually open!  Could use copy stored in plugin?

        # set up directory structure and load filename lists

        shp_list = self.mynormpath(
            os.path.dirname(os.path.realpath(__file__)) + "/shp.csv"
        )

        shps = pd.read_csv(shp_list, names=["name", "dir_code"])
        shps = shps.set_index("name")

        # Specify the field name based on which duplicates should be identified
        field_name = "UUID"

        # remove objects with duplicate UUIDs
        for layer in project.mapLayers().values():
            # Check if the layer name matches the target name
            # if layer.name() in shps.index.tolist():
            if (
                layer.name().startswith("Compilation_")
                or layer.name() in shps.index.tolist()
            ):

                # Start editing the layer
                layer.startEditing()

                # Initialize a set to track unique values
                unique_values = set()

                # List to store IDs of features to be deleted
                features_to_delete = []

                # Loop through features in the layer
                for feature in layer.getFeatures():
                    field_value = feature[field_name]

                    # Check if the field value has been encountered before
                    if field_value in unique_values:
                        # If it's a duplicate, mark the feature for deletion
                        features_to_delete.append(feature.id())
                    else:
                        # If it's unique, add the value to the set
                        unique_values.add(field_value)

                # Delete the duplicate features
                if features_to_delete:
                    layer.deleteFeatures(features_to_delete)

                # Commit the changes
                if layer.commitChanges():
                    pass

                # Refresh the layer to see changes
            layer.triggerRepaint()

            self.iface.messageBar().pushMessage(
                "Duplicate UUIDs removed, saved in current project",
                level=Qgis.Success,
                duration=5,
            )

    # get list of csv files in the csv directory on the fly
    def get_csv_list_old(self, path):
        extensions = [".csv"]
        # Get the list of matching files
        file_list = self.FM_Import.find_files_with_extensions(path, extensions)
        names = []
        for file in file_list:
            file_prefix = str(os.path.basename(file)).replace(".csv", "")
            names.append(file_prefix)
        return names

    def get_first_column_text(self, gpkg_path, layer_name):
        """
        Get the first column of text values from a specified layer in a GeoPackage.

        Parameters:
            gpkg_path (str): Path to the GeoPackage file.
            layer_name (str): The name of the layer to extract data from.

        Returns:
            list: A list of text values from the first column, or an empty list if no text column is found.
        """
        import fiona

        try:
            # Open the specified layer in the GeoPackage
            with fiona.open(gpkg_path, layer=layer_name) as layer:
                # Get the schema (field names and types)
                fields = layer.schema["properties"]

                # Find the first text column
                first_text_column = next(
                    (
                        field
                        for field, field_type in fields.items()
                        if field_type.startswith("str")
                    ),
                    None,
                )

                if not first_text_column:
                    print(f"No text column found in layer: {layer_name}")
                    return []

                # Extract values from the first text column
                text_values = [
                    feature["properties"][first_text_column]
                    for feature in layer
                    if feature["properties"][first_text_column] is not None
                ]

                return text_values
        except Exception as e:
            print(f"Error reading layer '{layer_name}' from GeoPackage: {e}")
            return []

    # get list of csv files in the csv directory on the fly
    def get_csv_list(self, gpkg_path):
        import fiona

        """
        Get a list of layer names in a GeoPackage file.

        Parameters:
            gpkg_path (str): Path to the GeoPackage file.

        Returns:
            list: A list of layer names in the GeoPackage.
        """

        try:
            # Open the GeoPackage and retrieve its layer names
            layers = fiona.listlayers(gpkg_path)
            return layers
        except Exception as e:
            print(f"Error reading GeoPackage: {e}")
            return []

    # copy files to new directory checking for duplicates
    def recursive_overwrite(self, src, dest, ignore=None):
        if os.path.isdir(src):
            if not os.path.isdir(dest):
                os.makedirs(dest)
            files = os.listdir(src)
            if ignore is not None:
                ignored = ignore(src, files)
            else:
                ignored = set()
            for f in files:
                if f not in ignored:
                    self.recursive_overwrite(
                        os.path.join(src, f), os.path.join(dest, f), ignore
                    )
        else:
            shutil.copyfile(src, dest)

    def merge_text_tables_remove_duplicates(
        self,
        gpkg1_path,
        layer1_name,
        gpkg2_path,
        layer2_name,
        output_gpkg_path,
        output_layer_name,
    ):
        """
        Merge two text table layers (without geometry) from different GeoPackages into a new GeoPackage, removing duplicates.

        Parameters:
            gpkg1_path (str): Path to the first GeoPackage.
            layer1_name (str): Name of the text table layer in the first GeoPackage.
            gpkg2_path (str): Path to the second GeoPackage.
            layer2_name (str): Name of the text table layer in the second GeoPackage.
            output_gpkg_path (str): Path to the output GeoPackage.
            output_layer_name (str): Name of the output layer.
        """
        import fiona

        try:
            # Open the first layer
            with fiona.open(gpkg1_path, layer=layer1_name) as layer1:
                layer1_schema = layer1.schema
                features1 = list(layer1)

            # Open the second layer
            with fiona.open(gpkg2_path, layer=layer2_name) as layer2:
                # Ensure the schema matches between layers
                if layer1.schema != layer2.schema:
                    raise ValueError("Schema mismatch between layers.")

                features2 = list(layer2)

            # Merge features and remove duplicates
            seen = set()
            unique_features = []

            for feature in features1 + features2:
                # Use properties (attributes) as the unique identifier
                properties = tuple(feature["properties"].items())

                if properties not in seen:
                    seen.add(properties)
                    unique_features.append(feature)

            ## Create a new GeoPackage for the output layer
            # if os.path.exists(output_gpkg_path):
            #    os.remove(output_gpkg_path)  # Overwrite if the file exists

            with fiona.open(
                output_gpkg_path,
                mode="w",
                driver="GPKG",
                layer=output_layer_name,
                schema=layer1_schema,
            ) as output_layer:
                output_layer.writerecords(unique_features)
            # print(output_gpkg_path, output_layer_name)
            # print(f"Successfully merged text table layers into {output_gpkg_path} (layer: {output_layer_name}).")

        except Exception as e:
            print(f"Error merging text table layers: {e}")

    def list_layers_from_gpkg(self, gpkg_path):
        """
        Returns a list of layer names contained in a GeoPackage.

        :param gpkg_path: Path to the GeoPackage file.
        :return: List of layer names.
        """
        layer = QgsVectorLayer(gpkg_path, "temp_layer", "ogr")
        if not layer.isValid():
            print(f"Failed to open GeoPackage: {gpkg_path}")
            return []

        sub_layers = layer.dataProvider().subLayers()
        return [subLayer.split("!!::!!")[1] for subLayer in sub_layers]

    def merge_current_to_existing(self):
        """
        Combines layers from source geopackage with matching 'Compilation_' prefixed layers
        in the target geopackage. Updates target layers with combined data and then clears
        the source layers while preserving their structure.
        """
        shp_list = self.mynormpath(
            os.path.dirname(os.path.realpath(__file__)) + "/shp.csv"
        )

        project = QgsProject.instance()
        proj_file_path = project.fileName()

        head_tail = os.path.split(proj_file_path)
        main_project_path = head_tail[0] + "/"

        shps = pd.read_csv(shp_list, names=["name", "dir_code"])
        shps = shps.set_index("name")

        source_gpkg_path = self.mynormpath(
            main_project_path + self.dir_0 + "CURRENT_MISSION.gpkg"
        )

        # Get list of layers from source geopackage
        source_layers = []
        source_gpkg = QgsVectorLayer(source_gpkg_path, "source_gpkg", "ogr")
        for child in source_gpkg.dataProvider().subLayers():
            layer_name = child.split("!!::!!")[1]  # Get layer name from sublayer string
            source_layers.append(layer_name)

        print(f"Found {len(source_layers)} layers in source geopackage")

        # Process each layer
        for source_layer_name in source_layers:
            if source_layer_name in shps.index.tolist():
                print("Processing source layer:", source_layer_name)
                try:
                    # Get the layers by name
                    source_layer = QgsProject.instance().mapLayersByName(
                        source_layer_name
                    )[0]
                    compilation_layer = QgsProject.instance().mapLayersByName(
                        "Compilation_" + source_layer_name
                    )[0]

                    # Find the maximum FID in the compilation layer
                    max_fid = -1
                    for feat in compilation_layer.getFeatures():
                        fid = feat.id()
                        if fid > max_fid:
                            max_fid = fid

                    # Start new FIDs from max_fid + 1000000 to ensure no conflicts
                    next_fid = max_fid + 1000000

                    # Start editing the compilation layer
                    if not compilation_layer.startEditing():
                        print(f"Failed to start editing {compilation_layer.name()}")
                        continue

                    # Add features one by one with new FIDs
                    features_added = 0
                    errors = []
                    new_features = []  # Collect features before adding them

                    for feature in source_layer.getFeatures():
                        new_feature = QgsFeature()
                        new_feature.setFields(compilation_layer.fields())

                        # Set attributes
                        attrs = {}
                        for field in compilation_layer.fields():
                            field_name = field.name()
                            if field_name.lower() == "fid":
                                attrs[field_name] = next_fid
                            else:
                                try:
                                    attrs[field_name] = feature[field_name]
                                except KeyError:
                                    attrs[field_name] = None

                        new_feature.setAttributes(
                            [
                                attrs[field.name()]
                                for field in compilation_layer.fields()
                            ]
                        )
                        new_feature.setGeometry(feature.geometry())
                        new_features.append(new_feature)
                        next_fid += 1

                    # Add all features at once
                    if compilation_layer.addFeatures(new_features):
                        features_added = len(new_features)
                    else:
                        errors.append("Failed to add features batch")

                    # Commit the changes to compilation layer
                    if compilation_layer.commitChanges():
                        compilation_layer.updateExtents()
                        compilation_layer.triggerRepaint()
                        print(
                            f"Successfully added {features_added} features to {compilation_layer.name()}"
                        )

                        # Now clear the source layer
                        if source_layer.startEditing():
                            # Delete all features while preserving structure
                            feature_ids = [
                                feature.id() for feature in source_layer.getFeatures()
                            ]
                            source_layer.deleteFeatures(feature_ids)

                            if source_layer.commitChanges():
                                print(f"Successfully cleared {source_layer.name()}")
                                source_layer.updateExtents()
                                source_layer.triggerRepaint()
                            else:
                                print(
                                    f"Failed to clear {source_layer.name()}. Errors:",
                                    source_layer.commitErrors(),
                                )
                                source_layer.rollBack()
                        else:
                            print(
                                f"Failed to start editing {source_layer.name()} for clearing"
                            )

                        if errors:
                            print("Errors occurred during merge:")
                            for error in errors:
                                print(f"  {error}")
                    else:
                        print(
                            f"Failed to commit changes to {compilation_layer.name()}. Errors:",
                            compilation_layer.commitErrors(),
                        )
                        compilation_layer.rollBack()

                except IndexError:
                    print(
                        f"Could not find layer {source_layer_name} or its compilation counterpart"
                    )
                except Exception as e:
                    print(f"Error processing {source_layer_name}: {str(e)}")

    def delete_gpkg_layer(self, geopackage_path, layer_name):
        from osgeo import ogr
        import os

        # Open the GeoPackage using OGR
        gpkg_ds = ogr.Open(geopackage_path, 1)  # 1 = Open in update mode

        if gpkg_ds:
            # Execute the DROP TABLE command
            sql = f'DROP TABLE "{layer_name}"'
            gpkg_ds.ExecuteSQL(sql)
            gpkg_ds = None  # Close the connection
            print(
                f"✅ Layer '{layer_name}' successfully removed from {geopackage_path}."
            )
        else:
            print(f"⚠️ Error: Unable to open GeoPackage '{geopackage_path}'!")

    def refresh_layer(self, layer_name):
        layer = QgsProject.instance().mapLayersByName(layer_name)[0]

        if layer:
            # Refresh the layer to update feature count in the browser
            layer.triggerRepaint()
            layer.commitChanges()

            # print(f"Feature count for layer '{layer.name()}' updated.")
        else:
            print("Layer not found.")

    def mergeProjects(self):
        # Takes two WAXI QFIELD Projects and combines them,
        # removing duplicates and saves out the full structure to a new directory

        if (
            self.dlg.lineEdit_11.text()
            and self.dlg.lineEdit_26.text()
            and self.dlg.lineEdit_37.text()
        ):

            project = (
                QgsProject.instance()
            )  # assumes one of the projects is actually open!  Could use copy stored in plugin?

            # set up directory structure and load filename lists

            shp_list = self.mynormpath(
                os.path.dirname(os.path.realpath(__file__)) + "/shp.csv"
            )

            project = QgsProject.instance()
            proj_file_path = project.fileName()

            head_tail = os.path.split(proj_file_path)
            main_project_path = head_tail[0] + "/"

            # self.csvs = self.get_csv_list(main_project_path + self.dir_99 + "/Dictionaries.gpkg")

            shps = pd.read_csv(shp_list, names=["name", "dir_code"])
            shps = shps.set_index("name")
            # csvs = pd.read_csv(csv_list, names=["name"])

            merge_project_path = self.dlg.lineEdit_37.text() + "/"

            head_tail_main = os.path.split(self.dlg.lineEdit_11.text())
            head_tail_sub = os.path.split(self.dlg.lineEdit_26.text())

            main_project_path = head_tail_main[0] + "/"
            sub_project_path = head_tail_sub[0] + "/"

            mainGpkgPath = self.mynormpath(
                main_project_path + self.dir_0 + "CURRENT_MISSION.gpkg"
            )
            subGpkgPath = self.mynormpath(
                sub_project_path + self.dir_0 + "CURRENT_MISSION.gpkg"
            )
            mergeGpkgPath = self.mynormpath(
                merge_project_path + self.dir_0 + "CURRENT_MISSION.gpkg"
            )

            mainCompGpkgPath = self.mynormpath(
                main_project_path + self.dir_1 + "COMPILATION.gpkg"
            )
            subCompGpkgPath = self.mynormpath(
                sub_project_path + self.dir_1 + "COMPILATION.gpkg"
            )
            mergeCompGpkgPath = self.mynormpath(
                merge_project_path + self.dir_1 + "COMPILATION.gpkg"
            )

            # create new directory structures
            dirs = [
                merge_project_path,
                merge_project_path + self.dir_0,
                merge_project_path + self.dir_99,
            ]

            for dirpath in dirs:
                if not os.path.exists(self.mynormpath(dirpath)):
                    os.mkdir(self.mynormpath(dirpath))

            main_path = self.mynormpath(
                main_project_path + self.dir_99 + "/Dictionaries.gpkg"
            )
            sub_path = self.mynormpath(
                sub_project_path + self.dir_99 + "/Dictionaries.gpkg"
            )
            merge_path = self.mynormpath(
                merge_project_path + self.dir_99 + "/Dictionaries.gpkg"
            )
            csvs = self.get_csv_list(main_path)
            csvs = csvs[1:]
            # merge and de-duplicate csv files
            for file in csvs:

                self.merge_text_tables_remove_duplicates(
                    main_path, file, sub_path, file, merge_path, file
                )

            cp_dirs = [
                "1_EXISTING_FIELD_DATABASE",
                "2_GPS-LOCALITIES_OF_INTEREST",
                "3_GEOCHEMISTRY",
                "4_GEOCHRONOLOGY",
                "5_MINING_AND_EXPLORATION",
                "6_GEOLOGY",
                "7_GEOPHYSICS",
                "8_LAND_USE",
                "9_GEOGRAPHY",
                "10_TOPOGRAPHY",
                "11_ORTHOPHOTOGRAPHY-SATELLITE_IMAGERY",
                self.dir_0 + "/DCIM/",
            ]
            for cp_dir in cp_dirs:
                src_path = main_project_path + cp_dir
                dst_path = self.mynormpath(merge_project_path + cp_dir)
                self.safe_copy_tree(src_path, dst_path)
            main_path = main_project_path + self.dir_0 + "/DCIM/"
            src_path = sub_project_path + self.dir_0 + "/DCIM/"
            dst_path = self.mynormpath(merge_project_path + self.dir_0 + "/DCIM/")

            self.recursive_overwrite(main_path, dst_path, ignore=None)
            self.recursive_overwrite(src_path, dst_path, ignore=None)

            src_file = (
                main_project_path + self.dir_0 + "/CURRENT_MISSION+DICTIONARIES.qlr"
            )
            dst_file = (
                merge_project_path + self.dir_0 + "/CURRENT_MISSION+DICTIONARIES.qlr"
            )
            shutil.copyfile(src_file, dst_file)

            proj_name = os.path.basename(self.dlg.lineEdit_11.text())
            shutil.copyfile(
                self.dlg.lineEdit_11.text(),
                merge_project_path + "/" + proj_name,
            )

            in_pref = main_project_path + self.dir_99
            out_pref = merge_project_path + self.dir_99
            copies = [
                [mainGpkgPath, mergeGpkgPath],
                [
                    in_pref + "columns_reference_WAXI4.csv",
                    out_pref + "columns_reference_WAXI4.csv",
                ],
                [
                    in_pref + "columns_types_structures_WAXI4.csv",
                    out_pref + "columns_types_structures_WAXI4.csv",
                ],
                [in_pref + "stereonet.json", out_pref + "stereonet.json"],
                """[in_pref + "Stops_PT_autoinc.qml", out_pref + "Stops_PT_autoinc.qml"],
                [
                    in_pref + "Stops_PT_no_autoinc.qml",
                    out_pref + "Stops_PT_no_autoinc.qml",
                ],"""[
                    in_pref + "Version.txt", out_pref + "Version.txt"
                ],
            ]

            for pairs in copies:
                shutil.copyfile(pairs[0], pairs[1])

            for layer in project.mapLayers().values():
                # Check if the layer name matches the target name
                if layer.name() in shps.index.tolist():

                    main_layer_path = mainGpkgPath + "|layername=" + layer.name()
                    sub_layer_path = subGpkgPath + "|layername=" + layer.name()
                    params = {
                        "LAYERS": [main_layer_path, sub_layer_path],
                        "OUTPUT": "ogr:dbname='"
                        + self.mynormpath(mergeGpkgPath + "' table=\"" + layer.name())
                        + '"',
                    }
                    merged_layers = processing.run("native:mergevectorlayers", params)

            self.iface.messageBar().pushMessage(
                "Projects merged, saved in directory" + merge_project_path,
                level=Qgis.Success,
                duration=5,
            )

            for layer in project.mapLayers().values():
                # Check if the layer name matches the target name
                if layer.name().replace(
                    "Compilation_", ""
                ) in shps.index.tolist() and layer.name().startswith("Compilation_"):

                    main_layer_path = mainCompGpkgPath + "|layername=" + layer.name()
                    sub_layer_path = subCompGpkgPath + "|layername=" + layer.name()
                    params = {
                        "LAYERS": [main_layer_path, sub_layer_path],
                        "OUTPUT": "ogr:dbname='"
                        + self.mynormpath(
                            mergeCompGpkgPath + "' table=\"" + layer.name()
                        )
                        + '"',
                    }
                    merged_layers = processing.run("native:mergevectorlayers", params)

            self.iface.messageBar().pushMessage(
                "Projects merged, saved in directory" + merge_project_path,
                level=Qgis.Success,
                duration=5,
            )

        else:
            self.iface.messageBar().pushMessage(
                "Directory not found", level=Qgis.Warning, duration=45
            )

    ### Export Data ###

    def exportData(self):
        # Combines sets of lithology, structure and zoneal layers into 3 shapefiles

        if os.path.exists(self.mynormpath(self.dlg.lineEdit_7.text())):

            proj = QgsProject.instance()

            for name in self.layers_names:

                layer = proj.mapLayersByName(name)[0]
                caps = layer.dataProvider().capabilities()

                # Get the list of fields in the layer
                existing_fields = [field.name() for field in layer.fields()]

                # Check if 'src_layer' field exists, if not, add it
                if "Layer" not in existing_fields:
                    # Add Fields if the provider supports it
                    if caps & QgsVectorDataProvider.AddAttributes:
                        res = layer.dataProvider().addAttributes(
                            [QgsField("Layer", QVariant.String)]
                        )
                        layer.updateFields()

                src_layer_idx = layer.fields().lookupField("Layer")

                # Start editing mode to modify attributes
                layer.startEditing()
                # Change attribute values
                for f in layer.getFeatures():
                    layer.changeAttributeValue(f.id(), src_layer_idx, name)

                # Commit changes
                layer.commitChanges()

            project = QgsProject.instance()
            proj_file_path = project.fileName()
            # head_tail = os.path.split(proj_file_path)

            file = []
            # merge zone data
            """file.append(
                self.geopackage_file_path + "|layername=Compilation_Fractured zones_PG"
            )"""
            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Deformation zones_PG"
            )
            """file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Cataclastic zones_PG"
            )"""
            file.append(
                self.geopackage_file_path + "|layername=Compilation_Alteration zones_PG"
            )
            file.append(
                self.geopackage_file_path + "|layername=Compilation_Lithology zones_PG"
            )
            newGeopackagePath = self.mynormpath(
                self.dlg.lineEdit_7.text() + "/export.gpkg"
            )

            # first create temp layer and new geopackage
            temp_layer = QgsVectorLayer("Point?crs=EPSG:4326", "temp_layer", "memory")

            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "GPKG"  # Specify the GeoPackage format

            transform_context = QgsCoordinateTransformContext()

            QgsVectorFileWriter.writeAsVectorFormatV3(
                temp_layer, newGeopackagePath, transform_context, options
            )
            newLayer = (
                "ogr:dbname='"
                + newGeopackagePath
                + "' table=\""
                + "zonal_data"
                + '" (geom)'
            )

            # merge shapefiles
            params = {
                "LAYERS": [file[0], file[1], file[2]],
                "OUTPUT": newLayer,
            }

            processing.run("native:mergevectorlayers", params)

            # merge lithology data
            file1 = (
                self.geopackage_file_path
                + "|layername=Compilation_Local lithologies_PT"
            )
            file2 = (
                self.geopackage_file_path
                + "|layername=Compilation_Supergene lithologies_PT"
            )
            file3 = (
                self.geopackage_file_path
                + "|layername=Compilation_Sedimentary lithologies_PT"
            )
            file4 = (
                self.geopackage_file_path
                + "|layername=Compilation_Volcanoclastic lithologies_PT"
            )
            file5 = (
                self.geopackage_file_path
                + "|layername=Compilation_Igneous extrusive lithologies_PT"
            )
            file6 = (
                self.geopackage_file_path
                + "|layername=Compilation_Igneous intrusive lithologies_PT"
            )
            file7 = (
                self.geopackage_file_path
                + "|layername=Compilation_Metamorphic lithologies_PT"
            )

            newLayer = (
                "ogr:dbname='"
                + newGeopackagePath
                + "' table=\""
                + "litho_data"
                + '" (geom)'
            )

            # merge shapefiles
            params = {
                "LAYERS": [file1, file2, file3, file4, file5, file6, file7],
                "OUTPUT": newLayer,
            }

            processing.run("native:mergevectorlayers", params)

            # merge structural data
            file1 = (
                self.geopackage_file_path
                + "|layername=Compilation_Bedding-Lava flow-S0_PT"
            )
            file2 = self.geopackage_file_path + "|layername=Compilation_Dikes-Sills_PT"
            """file3 = (
                self.geopackage_file_path
                + "|layername=Compilation_Fold and crenulation axial planes_PT"
            )"""
            file4 = self.geopackage_file_path + "|layername=Compilation_Folds_PT"
            file5 = (
                self.geopackage_file_path
                + "|layername=Compilation_Foliation-cleavage_PT"
            )
            file6 = self.geopackage_file_path + "|layername=Compilation_Fractures_PT"
            file7 = self.geopackage_file_path + "|layername=Compilation_Lineations_PT"
            file8 = (
                self.geopackage_file_path
                + "|layername=Compilation_Shear zones and faults_PT"
            )
            file9 = self.geopackage_file_path + "|layername=Compilation_Veins_PT"

            newLayer = (
                "ogr:dbname='"
                + newGeopackagePath
                + "' table=\""
                + "structure_data"
                + '" (geom)'
            )

            # merge shapefiles
            params = {
                "LAYERS": [
                    file1,
                    file2,
                    # file3,
                    file4,
                    file5,
                    file6,
                    file7,
                    file8,
                    file9,
                ],
                "OUTPUT": newLayer,
            }

            processing.run("native:mergevectorlayers", params)
            self.iface.messageBar().pushMessage(
                "Layers merged, saved in directory" + self.dlg.lineEdit_7.text(),
                level=Qgis.Success,
                duration=5,
            )

        else:
            self.iface.messageBar().pushMessage(
                "Directory not found: " + self.dlg.lineEdit_7.text(),
                level=Qgis.Warning,
                duration=45,
            )

    def mynormpath(self, path):
        return r"" + os.path.normpath(path).replace("\\", "/")

    def virtualStops(self):
        try:
            distance = self.dlg.lineEdit_53.text()
            from .dbscan import Basic_DBSCAN
            from datetime import datetime

            if not self.dlg.lineEdit_53.text():
                self.iface.messageBar().pushMessage(
                    "Please enter a distance value", level=Qgis.Warning, duration=5
                )
                return

            project = QgsProject.instance()
            file = []
            self.geopackage_file_path = self.mynormpath(self.geopackage_file_path)

            layer_names = [
                "Compilation_Lineations_PT",
                "Compilation_Folds_PT",
                "Compilation_Bedding-Lava flow-S0_PT",
                "Compilation_Foliation-cleavage_PT",
                "Compilation_Shear zones and faults_PT",
                "Compilation_Fractures_PT",
                "Compilation_Veins_PT",
                "Compilation_Dikes-Sills_PT",
                "Compilation_Local lithologies_PT",
                "Compilation_Supergene lithologies_PT",
                "Compilation_Sedimentary lithologies_PT",
                "Compilation_Volcanoclastic lithologies_PT",
                "Compilation_Igneous extrusive lithologies_PT",
                "Compilation_Igneous intrusive lithologies_PT",
                "Compilation_Metamorphic lithologies_PT",
                "Compilation_Lithological contacts_PT",
                "Compilation_Magnetic susceptibility_PT",
            ]

            for layer_name in layer_names:
                file.append(f"{self.geopackage_file_path}|layername={layer_name}")

            print("Starting layer merging process...")

            all_points = []
            all_features = []
            field_names = set()

            # Step 1: Find common fields across all layers
            for i, f in enumerate(file):
                test_layer = QgsVectorLayer(f, f"Layer_{i}", "ogr")
                if not test_layer.isValid():
                    print(f"Warning: Layer {i} is not valid, skipping")
                    continue

                # print(f"Processing layer {i}: {f}")

                layer_fields = set([field.name() for field in test_layer.fields()])
                if i == 0:
                    field_names = layer_fields  # First layer sets the common fields
                else:
                    field_names.intersection_update(
                        layer_fields
                    )  # Keep only common fields

                for feature in test_layer.getFeatures():
                    geom = feature.geometry()
                    if geom is None or geom.isEmpty():
                        print(f"Skipping empty geometry in layer {i}")
                        continue

                    if geom.wkbType() == QgsWkbTypes.Point:
                        point = geom.asPoint()
                        all_points.append([point.x(), point.y()])
                        all_features.append(feature)

            print(f"Total points collected from all layers: {len(all_points)}")
            print(f"Common fields for all layers: {list(field_names)}")

            if not all_points:
                self.iface.messageBar().pushMessage(
                    "No points found", level=Qgis.Warning, duration=45
                )
                return

            import numpy as np

            X = np.array(all_points)

            canvas = self.iface.mapCanvas()
            if canvas.mapUnits() == 6:
                distance = float(distance) / 111139.0
            else:
                distance = float(distance)

            scanner = Basic_DBSCAN(eps=distance, minPts=1)
            clusters = scanner.fit_predict(X)

            print(f"Clusters assigned: {set(clusters)}")

            # Step 2: Create memory layer with only common fields
            merged_layers = QgsVectorLayer(
                "Point?crs=EPSG:4326", "Virtual_Stops", "memory"
            )
            provider = merged_layers.dataProvider()

            # Add only common fields to the new layer
            new_fields = [
                QgsField(field_name, QVariant.String) for field_name in field_names
            ]
            new_fields.append(QgsField("v_stop", QVariant.String))  # Add v_stop field
            provider.addAttributes(new_fields)
            merged_layers.updateFields()

            # Step 3: Insert features dynamically handling missing fields
            merged_layers.startEditing()

            for i, feature in enumerate(all_features):
                new_feature = QgsFeature(
                    merged_layers.fields()
                )  # Ensure correct field structure
                geometry = feature.geometry()

                if geometry is None or geometry.isEmpty():
                    print(f"Skipping feature {i} due to missing geometry.")
                    continue

                new_feature.setGeometry(geometry)  # Ensure geometry is set

                # Extract only common field values dynamically
                feature_attributes = []
                for field_name in field_names:
                    try:
                        field_index = feature.fields().indexFromName(field_name)
                        if field_index != -1 and field_index < len(
                            feature.attributes()
                        ):
                            feature_attributes.append(feature.attributes()[field_index])
                        else:
                            raise IndexError
                    except IndexError:
                        print(
                            f"⚠ Warning: Field '{field_name}' missing for feature {i}, setting to None"
                        )
                        feature_attributes.append(None)

                feature_attributes.append(str(clusters[i]))  # Add v_stop value

                # Debugging: Print the extracted attributes for each feature
                # print(f"Feature {i} attributes: {feature_attributes}")

                new_feature.setAttributes(feature_attributes)

                # Debugging to check if feature is added correctly
                if provider.addFeature(new_feature):
                    pass
                    # print(f"✅ Successfully added feature {i}")
                else:
                    print(f"❌ Failed to add feature {i}")

            merged_layers.startEditing()
            if merged_layers.dataProvider().fieldNameIndex("Virtual_ID") == -1:
                merged_layers.dataProvider().addAttributes(
                    [QgsField("Virtual_ID", QVariant.String)]
                )
                merged_layers.updateFields()

            id_new_col = merged_layers.dataProvider().fieldNameIndex("Virtual_ID")

            for i, feature in enumerate(merged_layers.getFeatures()):
                if clusters[i] > 0:
                    merged_layers.changeAttributeValue(
                        feature.id(), id_new_col, str(clusters[i])
                    )

            print(
                f"Before commit: merged_layers feature count: {merged_layers.featureCount()}"
            )
            merged_layers.commitChanges()
            merged_layers.updateExtents()

            print(
                f"After commit: merged_layers feature count: {merged_layers.featureCount()}"
            )

            if merged_layers.featureCount() == 0:
                print("❌ ERROR: No features were added to the memory layer.")
                return

            output_path = QgsProject.instance().readPath("./") + "/"
            datestamp = datetime.now().strftime("%d-%b-%Y_%H_%M_%S")
            params = {
                "INPUT": merged_layers,
                "OPTIONS": "-update -nln " + "Virtual_Stops_" + datestamp,
                "OUTPUT": output_path + self.dir_0 + "CURRENT_MISSION.gpkg",
            }
            print("params2", params)

            processing.run("gdal:convertformat", params)

            virtual_path = self.mynormpath(
                output_path
                + self.dir_0
                + "/CURRENT_MISSION.gpkg|layername=Virtual_Stops_"
                + datestamp
            )
            self.iface.addVectorLayer(virtual_path, "Virtual_Stops_" + datestamp, "ogr")
            self.iface.messageBar().pushMessage(
                "Virtual Stop layer created", level=Qgis.Success, duration=5
            )

        except Exception as e:
            print(f"General error: {str(e)}")
            self.iface.messageBar().pushMessage(
                f"General error: {str(e)}", level=Qgis.Critical, duration=5
            )

    def virtualStops_old(self):
        distance = self.dlg.lineEdit_53.text()
        from .dbscan import Basic_DBSCAN
        from datetime import datetime

        if self.dlg.lineEdit_53.text():

            # Defines pseudo stop numbers based on proximity
            project = QgsProject.instance()
            proj_file_path = project.fileName()

            file = []
            self.geopackage_file_path = self.mynormpath(self.geopackage_file_path)
            file.append(
                self.geopackage_file_path + "|layername=Compilation_Lineations_PT"
            )
            file.append(self.geopackage_file_path + "|layername=Compilation_Folds_PT")

            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Bedding-Lava flow-S0_PT"
            )
            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Foliation-cleavage_PT"
            )
            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Shear zones and faults_PT"
            )
            file.append(
                self.geopackage_file_path + "|layername=Compilation_Fractures_PT"
            )
            file.append(self.geopackage_file_path + "|layername=Compilation_Veins_PT")
            file.append(
                self.geopackage_file_path + "|layername=Compilation_Dikes-Sills_PT"
            )

            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Local lithologies_PT"
            )
            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Supergene lithologies_PT"
            )
            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Sedimentary lithologies_PT"
            )
            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Volcanoclastic lithologies_PT"
            )
            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Igneous extrusive lithologies_PT"
            )
            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Igneous intrusive lithologies_PT"
            )
            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Metamorphic lithologies_PT"
            )
            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Lithological contacts_PT"
            )

            file.append(
                self.geopackage_file_path
                + "|layername=Compilation_Magnetic susceptibility_PT"
            )

            # Merge two shapefiles
            params = {"LAYERS": [file[0], file[1]], "OUTPUT": "memory:"}

            merged_layers = processing.run("native:mergevectorlayers", params)["OUTPUT"]

            if not merged_layers.isValid():
                print("Processing failed.")
            else:
                print("Processing succeeded.")

            for i, f in enumerate(file):

                if i > 1:  # ignore first two as already merged
                    # merge two shapefiles
                    params = {"LAYERS": [merged_layers, f], "OUTPUT": "memory:"}
                    print("params", params)

                    merged_layers = processing.run("native:mergevectorlayers", params)[
                        "OUTPUT"
                    ]

            points = []
            feats = merged_layers.getFeatures()
            for i, f in enumerate(feats):
                point = f.geometry()
                points.append([point.asPoint().x(), point.asPoint().y()])
            canvas = self.iface.mapCanvas()

            if (
                canvas.mapUnits() == 6
            ):  # if lat/long convert to metres, anything else is assuemd to be metres already (not a good idea)
                distance = float(distance) / 111139.0
            scanner = Basic_DBSCAN(eps=float(distance), minPts=1)
            """
            SIP_MONKEYPATCH_COMPAT_NAME 	0        Meters.
            SIP_MONKEYPATCH_COMPAT_NAME 	1        Kilometers.
            SIP_MONKEYPATCH_COMPAT_NAME 	2        Imperial feet.
            SIP_MONKEYPATCH_COMPAT_NAME 	3        Nautical miles.
            SIP_MONKEYPATCH_COMPAT_NAME 	4        Imperial yards.
            SIP_MONKEYPATCH_COMPAT_NAME 	5        Terrestrial miles.
            SIP_MONKEYPATCH_COMPAT_NAME 	6        Degrees, for planar geographic CRS distance measurements.
            SIP_MONKEYPATCH_COMPAT_NAME 	7        Centimeters.
            SIP_MONKEYPATCH_COMPAT_NAME 	8        Millimeters.
            Inches 	9        Inches (since QGIS 3.32)
            SIP_MONKEYPATCH_COMPAT_NAME 10        Unknown distance unit.
            """
            if len(points) > 0:
                X = np.array(points)
                X[0] = (X[0] - X[:, 0].mean()) / X[:, 0].std()
                X[1] = (X[1] - X[:, 1].mean()) / X[:, 1].std()
                # X = StandardScaler().fit_transform(X)

                clusters = scanner.fit_predict(X)

                merged_layers.startEditing()
                if merged_layers.dataProvider().fieldNameIndex("v_stop") == -1:
                    merged_layers.dataProvider().addAttributes(
                        [QgsField("v_stop", QVariant.String)]
                    )
                    merged_layers.updateFields()

                id_new_col = merged_layers.dataProvider().fieldNameIndex("v_stop")

                for i, feature in enumerate(merged_layers.getFeatures()):
                    if clusters[i] > 0:
                        merged_layers.changeAttributeValue(
                            feature.id(), id_new_col, str(clusters[i])
                        )

                merged_layers.commitChanges()
                if not merged_layers.isValid():
                    print("Layer failed to build!")
                else:
                    QgsProject.instance().addMapLayer(merged_layers, False)
                    output_path = QgsProject.instance().readPath("./") + "/"
                    datestamp = datetime.now().strftime("%d-%b-%Y_%H_%M_%S")
                    params = {
                        "INPUT": merged_layers,
                        "OPTIONS": "-update -nln " + "Virtual_Stops_" + datestamp,
                        "OUTPUT": output_path + self.dir_0 + "/CURRENT_MISSION.gpkg",
                    }
                    print("params2", params)

                    processing.run("gdal:convertformat", params)

                    virtual_path = self.mynormpath(
                        output_path
                        + self.dir_0
                        + "/CURRENT_MISSION.gpkg|layername=Virtual_Stops_"
                        + datestamp
                    )
                    self.iface.addVectorLayer(virtual_path, "", "ogr")
                    self.iface.messageBar().pushMessage(
                        "Virtual Stop layer created", level=Qgis.Success, duration=5
                    )
            else:
                self.iface.messageBar().pushMessage(
                    "No points found", level=Qgis.Warning, duration=45
                )

    def rmvLyr(lyrname):
        qinst = QgsProject.instance()

        qinst.removeMapLayer(qinst.mapLayersByName(lyrname)[0].id())

    ### Stereographic projection settings ###

    def set_stereoConfig(self):

        WAXI_projet_path = os.path.abspath(QgsProject.instance().fileName())
        stereoConfigPath = os.path.join(
            os.path.dirname(WAXI_projet_path), self.dir_99 + "/stereonet.json"
        )
        stereoConfig = {
            "showGtCircles": True,
            "showContours": True,
            "showKinematics": True,
            "linPlanes": True,
            "roseDiagram": True,
        }

        if os.path.exists(stereoConfigPath):
            with open(stereoConfigPath, "r") as json_file:
                stereoConfig = json.load(json_file)

        stereoConfig = {
            "showGtCircles": self.dlg.gtCircles_checkBox.isChecked(),
            "showContours": self.dlg.contours_checkBox.isChecked(),
            "showKinematics": self.dlg.kinematics_checkBox.isChecked(),
            "linPlanes": self.dlg.linPlanes_checkBox.isChecked(),
            "roseDiagram": self.dlg.rose_checkBox.isChecked(),
        }

        with open(stereoConfigPath, "w") as outfile:
            json.dump(stereoConfig, outfile, indent=4)

    def set_qmapsConfig(self):
        project = QgsProject.instance()
        proj_file_path = project.fileName()
        head_tail = os.path.split(proj_file_path)

        qmapConfigPath = head_tail[0] + "/" + self.dir_99 + "/qmap.json"
        """no_auto_filename = head_tail[0] + "/" + self.dir_99 + "/Stops_PT_no_autoinc.qml"
        auto_filename = head_tail[0] + "/" + self.dir_99 + "Stops_PT_autoinc.qml""" ""
        layer = project.mapLayersByName("Sampling_PT")[0]

        if os.path.exists(qmapConfigPath):
            with open(qmapConfigPath, "r") as json_file:
                qmapConfig = json.load(json_file)
        else:
            qmapConfig = {
                "autoInc": True,
            }

        """if qmapConfig["autoInc"]:
            self.dlg.autoinc_on_pushButton.setChecked(True)
            self.dlg.autoinc_off_pushButton.setChecked(False)
            self.apply_qml_style(layer,auto_filename)
        else:
            self.apply_qml_style(layer,no_auto_filename)
            self.dlg.autoinc_on_pushButton.setChecked(False)
            self.dlg.autoinc_off_pushButton.setChecked(True)"""

        with open(qmapConfigPath, "w") as outfile:
            json.dump(qmapConfig, outfile, indent=4)

    ### Merge 2 layers old version###

    def merge_2_layers_(self):

        project = QgsProject.instance()
        proj_file_path = project.fileName()
        head_tail = os.path.split(proj_file_path)

        layer1 = QgsProject.instance().mapLayersByName(
            str(self.dlg.comboBox_merge1_2.currentText())
        )[0]
        layer2 = QgsProject.instance().mapLayersByName(
            str(self.dlg.comboBox_merge2_2.currentText())
        )[0]

        field_name = "fid"
        field_index = layer1.fields().indexOf(field_name)
        if field_index != -1:
            # Delete the field using the field index
            if layer1.dataProvider().deleteAttributes([field_index]):
                # print(f"Field '{field_name}' removed successfully.")
                pass
            else:
                print(f"Failed to remove field '{field_name}'.")

        # Run the merge algorithm
        merged = processing.run(
            "qgis:mergevectorlayers",
            {
                "LAYERS": [layer1, layer2],
                "CRS": layer2.crs(),  # Change the CRS as needed
                "OUTPUT": "ogr:dbname='"
                + self.geopackage_file_path
                + "' table=\""
                + layer2.name()
                + '" (geom)',  # Output to geopackage
            },
        )

        # remove duplicate rows
        params = {
            "FIELDS": ["Date", "User", "xcoord", "ycoord"],
            "INPUT": merged,
            "OUTPUT": "ogr:dbname='"
            + self.geopackage_file_path
            + "' table=\""
            + layer2.name()
            + '" (geom)',
        }

        # processing.run("native:removeduplicatesbyattribute", params)['OUTPUT']

    def merge_2_layers(self):
        layer1 = QgsProject.instance().mapLayersByName(
            str(self.dlg.comboBox_merge1_2.currentText())
        )[0]
        layer2 = QgsProject.instance().mapLayersByName(
            str(self.dlg.comboBox_merge2_2.currentText())
        )[0]

        if layer1 != layer2:

            columns_layer1 = [field.name() for field in layer1.fields()]
            columns_layer2 = [field.name() for field in layer2.fields()]

            ## Loop on first layer entities

            for feature1 in layer1.getFeatures():
                # Creation of a new entity for the second layer
                new_feature = QgsFeature()

                # Copy geometry
                new_feature.setGeometry(feature1.geometry())

                # Copy attributes
                new_feature.setAttributes(feature1.attributes())

                # Add entity to second layer
                layer2.dataProvider().addFeatures([new_feature])

            # extra code to handle storage of original data as dict in json field
            if not layer2.isEditable():
                layer2.startEditing()
            for feature in layer2.getFeatures():

                if feature["UUID"] in self.sheetHashUUID:
                    new_text = self.sheetHashUUID[feature["UUID"]][0]

                    feature["Existing databases - raw data"] = new_text

                # Update the feature in the layer
                layer2.updateFeature(feature)

            # extra code to handle Lineations_PT
            if not layer2.isEditable():
                layer2.startEditing()
            # for feature in layer2.getFeatures():
            #    if "Lineations_PT" in self.dlg.comboBox_merge1_2.currentText():
            #        if feature["Measure"] == "Vertical plane":
            #            print("found it")
            # print(feature["Existing databases - raw data"][" DIP "])
            # Refinishing the second layer
            layer2.updateFields()
            layer2.commitChanges()
            layer2.triggerRepaint()

            # Removing the first layer
            QgsProject.instance().removeMapLayer(layer1.id())

    # Delete contents of a geopackage layer
    def drop_layer_contents(self, gpkg_path, layer_name):

        # Load the layer from the GeoPackage
        layer = QgsVectorLayer(f"{gpkg_path}|layername={layer_name}", layer_name, "ogr")

        # Check if the layer loaded successfully
        if not layer.isValid():
            print(f"Error: Failed to load layer '{layer_name}' from '{gpkg_path}'.")
        else:
            # Start an editing session
            if not layer.isEditable():
                layer.startEditing()

            # Get all feature IDs in the layer
            feature_ids = [feature.id() for feature in layer.getFeatures()]

            # Delete all features
            res = layer.dataProvider().deleteFeatures(feature_ids)

            if res:
                # Commit changes to save deletions
                layer.commitChanges()
            else:
                # Rollback if deletion failed
                layer.rollback()
                print(f"Error: Failed to delete features from layer '{layer_name}'.")

    # code to deisplay feature attirbutes and field names
    def print_feature_details(self, feature):
        # Print the feature ID
        # print(f"Feature ID: {feature.id()}")

        # Print attribute values
        attributes = feature.attributes()
        # print("Attributes:")
        fields = feature.fields()
        for index, attribute in enumerate(attributes):
            field_name = fields[index].name()  # Correct way to get field name
            # print(f"  {field_name}: {attribute}")

        # Print geometry as WKT (Well-Known Text)
        geometry = feature.geometry()
        if not geometry.isEmpty():
            pass
            # print(f"Geometry (WKT): {geometry.asWkt()}")
        else:
            print("Feature has no geometry")

    ### Update the source path of pictures in Photographs_PT and Sampling_PT layers ###

    def update_source_photo(self):  # ADD

        new_source_path = str(self.dlg.lineEdit_14.text())

        if os.path.exists(self.mynormpath(new_source_path)):

            layer_photographs_PT = QgsProject.instance().mapLayersByName(
                "Photographs_PT"
            )[0]
            layer_sampling_PT = QgsProject.instance().mapLayersByName("Sampling_PT")[0]
            source_field_index_photo = layer_photographs_PT.fields().indexFromName(
                "Source"
            )
            source_field_index_sampling = layer_sampling_PT.fields().indexFromName(
                "Source"
            )

            ## Option 1
            if self.dlg.option1_ckeckbox.isChecked():

                layer_photographs_PT.startEditing()

                for feature in layer_photographs_PT.getFeatures():
                    feature.setAttribute(source_field_index_photo, new_source_path)
                    layer_photographs_PT.updateFeature(feature)

                layer_photographs_PT.commitChanges()

                layer_sampling_PT.startEditing()

                for feature in layer_sampling_PT.getFeatures():
                    feature.setAttribute(source_field_index_sampling, new_source_path)
                    layer_sampling_PT.updateFeature(feature)

                layer_sampling_PT.commitChanges()

            ## Option 2
            if self.dlg.option2_ckeckbox.isChecked():

                # Create default value
                new_source_path_default = "'" + str(new_source_path) + "'"
                default_value = QgsDefaultValue(new_source_path_default)

                # Update default field value
                layer_photographs_PT.setDefaultValueDefinition(
                    source_field_index_photo, default_value
                )
                QgsProject.instance().write()

                # Update default field value
                layer_sampling_PT.setDefaultValueDefinition(
                    source_field_index_sampling, default_value
                )
                QgsProject.instance().write()

            self.iface.messageBar().pushMessage(
                (new_source_path + " is now the default directory for pictures"),
                level=Qgis.Success,
                duration=15,
            )

        else:
            self.iface.messageBar().pushMessage(
                "The path doesn't exist", level=Qgis.Warning, duration=45
            )

    def get_value_default(self, layer, field):  # ADD
        field_index = layer.fields().indexFromName(str(field))
        value = layer.defaultValueDefinition(field_index)
        defaut_value = value.expression()

        return defaut_value

    ### Save a new CURRENT_MISSION+DICTIONARIES.qlr file ###
    def save_template_style(self):
        """
        Save the group tree structure and all layer styles to a QLR file.

        Parameters:
            group_name (str): The name of the group to start with (e.g., "FIELD DATA").
            output_qlr_path (str): Path to save the QLR file.
        """
        # Get the root of the layer tree
        root = QgsProject.instance().layerTreeRoot()
        group_name = "FIELD DATA"
        # Find the target group
        target_group = None
        for child in root.children():
            if isinstance(child, QgsLayerTreeGroup) and child.name().startswith(
                group_name
            ):
                target_group = child
                break

        if not target_group:
            raise ValueError(f"Group '{group_name}' not found in the project.")

        # Ensure all layers in the group are valid and have styles
        for node in target_group.findLayers():
            layer = node.layer()
            if not layer.isValid():
                pass
                # print(f"Warning: Layer {layer.name()} is not valid and will be skipped.")
            else:
                print(f"Including layer: {layer.name()} with styles.")

        # Save the group with its hierarchy and styles
        # Save the layers to a QLR file
        error = QgsLayerDefinition.exportLayerDefinition(
            self.mynormpath(
                self.dlg.lineEdit_18.text() + "/CURRENT_MISSION+DICTIONARIES.qlr"
            ),
            [target_group],
        )

    def save_template_stylex(self):  # ADD

        if os.path.exists(self.mynormpath(self.dlg.lineEdit_18.text())):

            # Retrieve project layer tree
            arbre_layers = QgsProject.instance().layerTreeRoot()

            # Search for "FIELD DATA" group
            groupe_field_data = None
            for enfant in arbre_layers.children():
                if enfant.name() == "FIELD DATA" and isinstance(
                    enfant, QgsLayerTreeGroup
                ):
                    groupe_field_data = enfant
                    break

            # Create an XML structure for the layer tree
            xml_root = ET.Element("qlr")
            layer_tree_group = ET.SubElement(xml_root, "layer-tree-group")
            layer_tree_group.set("expanded", "1")
            layer_tree_group.set("checked", "Qt::Checked")
            layer_tree_group.set("groupLayer", "")
            layer_tree_group.set("name", "")

            custom_properties = ET.SubElement(layer_tree_group, "customproperties")
            option = ET.SubElement(custom_properties, "Option")

            if groupe_field_data:
                for child in groupe_field_data.children():
                    self.build_layer_tree_xml(child, layer_tree_group)

                # Save XML to a file
                chemin_qlr = self.mynormpath(self.dlg.lineEdit_18.text())
                chemin_complet = os.path.join(
                    chemin_qlr, "CURRENT_MISSION+DICTIONARIES.qlr"
                )
                xml_tree = ET.ElementTree(xml_root)
                xml_tree.write(chemin_complet, encoding="utf-8", xml_declaration=True)

            self.iface.messageBar().pushMessage(
                (
                    "A new CURRENT_MISSION+DICTIONARIES.qlr file was saved in "
                    + chemin_qlr
                ),
                level=Qgis.Success,
                duration=15,
            )

    # Builds the XML structure of the layer tree recursively
    def build_layer_tree_xml(self, layer, parent_element):  # ADD

        # If it's a group :
        if isinstance(layer, QgsLayerTreeGroup):
            group_element = ET.SubElement(parent_element, "layer-tree-group")
            group_element.set("expanded", "1")
            group_element.set("checked", "Qt::Checked")
            group_element.set("groupLayer", "")
            group_element.set("name", layer.name())
            custom_properties = ET.SubElement(group_element, "customproperties")
            option = ET.SubElement(custom_properties, "Option")
            for child in layer.children():
                self.build_layer_tree_xml(child, group_element)

        # If it's a layer :
        elif isinstance(layer, QgsLayerTreeLayer):
            layer_element = ET.SubElement(parent_element, "layer-tree-layer")
            layer_element.set("providerKey", "ogr")
            layer_element.set("expanded", "1")
            layer_element.set("checked", "Qt::Checked")
            layer_element.set("id", layer.layerId())
            layer_element.set("patch_size", "-1,-1")
            layer_element.set("legend_split_behavior", "0")
            layer_element.set("name", layer.name())
            layer_element.set("source", layer.layer().source())
            layer_element.set("legend_exp", "")
            custom_properties = ET.SubElement(layer_element, "customproperties")
            option = ET.SubElement(custom_properties, "Option")

    ###############################################################################
    ###                              Reset windows                              ###
    ###############################################################################

    def resetWindow_import_data(self):

        self.dlg.lineEdit_13.clear()
        self.dlg.tableWidget1.setRowCount(0)
        self.dlg.tableWidget2.setRowCount(0)
        self.dlg.tableWidget3.setRowCount(0)

    def resetWindow_fieldwork_preparation(self):
        self.dlg.lineEdit_8.clear()
        self.dlg.lineEdit_3.clear()
        self.dlg.lineEdit_38.clear()
        self.dlg.lineEdit_9.clear()
        self.dlg.lineEdit_10.clear()
        self.dlg.lineEdit_39.clear()

    def resetWindow_data_management(self):
        self.dlg.lineEdit_11.clear()
        self.dlg.lineEdit_26.clear()
        self.dlg.lineEdit_37.clear()
        self.dlg.lineEdit_7.clear()
        self.dlg.lineEdit_53.clear()

    ###############################################################################
    #########      Connecting Pushbuttons to LineEdits content        #############
    ###############################################################################

    def select_dst_directory(self):
        filename = QFileDialog.getExistingDirectory(None, "Select Folder")

        self.dlg.lineEdit_3.setText(filename)

    def select_directory(self, widget, prompt):
        filename = QFileDialog.getExistingDirectory(None, prompt)

        widget.setText(filename)

    def select_main_project(self):
        filename, _filter = QFileDialog.getOpenFileName(
            None, "Select Main Project File"
        )

        self.dlg.lineEdit_11.setText(filename)

    def select_sub_project(self):
        filename, _filter = QFileDialog.getOpenFileName(None, "Select Sub-Project File")

        self.dlg.lineEdit_26.setText(filename)

    def select_merged_directory(self):
        filename = QFileDialog.getExistingDirectory(
            None, "Select Destination Merged Folder"
        )

        self.dlg.lineEdit_37.setText(filename)

    def import_FM_Project(self):
        projectDirectoryPath = QFileDialog.getExistingDirectory(
            None, "Select FM Project Folder"
        )

        if os.path.exists(projectDirectoryPath + "/main.db"):
            self.dlg.lineEdit_FM_project_path.setText(projectDirectoryPath)
            self.FM_Import.import_FM_data(self.basePath, projectDirectoryPath)

            self.iface.messageBar().pushMessage(
                "SUCCESS: FeldMove Project Imported",
                level=Qgis.Success,
                duration=30,
            )
        else:
            if projectDirectoryPath != "":
                self.iface.messageBar().pushMessage(
                    "Error: FM Project Path Incorrect",
                    level=Qgis.Critical,
                    duration=15,
                )

    def select_file_to_import(self):
        filename, _filter = QFileDialog.getOpenFileName(None, "Select Import layer")

        self.dlg.lineEdit_13.setText(filename)
        if filename:
            self.click_import_data()

    def select_export_directory(self):
        filename = QFileDialog.getExistingDirectory(None, "Select Export Folder")

        self.dlg.lineEdit_7.setText(filename)

    def select_file_source_path_photo(self):  # ADD
        filename = QFileDialog.getExistingDirectory(
            None, "Select source path of your field pictures"
        )

        self.dlg.lineEdit_14.setText(filename)

    def select_file_export_template_style(self):  # ADD
        filename = QFileDialog.getExistingDirectory(
            None, "Select export path of your new project style template"
        )

        self.dlg.lineEdit_18.setText(filename)

    def select_clip_poly(self):
        filename, _filter = QFileDialog.getOpenFileName(None, "Select Clip Polygon")

        self.dlg.lineEdit_8.setText(filename)

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&GEOL_QMAPS"), action)
            self.iface.removeToolBarIcon(action)

    def update_combobox_delete(self):

        self.dlg.comboBox_delete.clear()

        list_combobox_delete = self.get_first_column_text(
            self.dictionaries_path, self.dlg.comboBox.currentText()
        )

        list_combobox_delete = [str(item) for item in list_combobox_delete]

        self.dlg.comboBox_delete.addItems(list_combobox_delete)

    def sorted_csv_combobBox(self):
        self.dlg.comboBox.clear()
        self.csv_layer_list = []
        for name in self.csvs:
            self.csv_layer_list.append(name)
        self.csv_layer_list.sort()
        self.dlg.comboBox.addItems(self.csv_layer_list)

    def fill_ComboBox(self):
        self.dlg.comboBox_merge1_2.clear()
        self.dlg.comboBox_merge2_2.clear()

        # List of the QGIS layers
        layers = QgsProject.instance().mapLayers()

        for layerId, layer in layers.items():
            if (
                isinstance(layer, QgsVectorLayer)
                and not layer.dataProvider().dataSourceUri().lower().endswith(".csv")
                and layer.name() != "African borders_PG"
                and "_PT" in layer.name()
                and not "Compilation_" in layer.name()
                and not layer.name() in self.layers_names_all
            ):
                self.dlg.comboBox_merge1_2.addItem(layer.name(), layerId)
            elif (
                isinstance(layer, QgsVectorLayer)
                and not layer.dataProvider().dataSourceUri().lower().endswith(".csv")
                and layer.name() != "African borders_PG"
                and "_PT" in layer.name()
                and "Compilation_" in layer.name()
            ):
                self.dlg.comboBox_merge2_2.addItem(layer.name(), layerId)

    def fill_ComboBox_layers_user(self):  # ADD
        self.dlg.comboBox_layers_user.clear()

        # List of the QGIS layers
        layers = QgsProject.instance().mapLayers()

        for layerId, layer in layers.items():

            # Select all non CSV layers of the QGIS project
            if isinstance(layer, QgsVectorLayer) and layer.name() in self.layers_names:
                self.dlg.comboBox_layers_user.addItem(layer.name(), layerId)

    def update_ComboBox(self):
        self.fill_ComboBox()
        self.fill_ComboBox_layers_user()  # ADD

    ###############################################################################
    ########                 Tooltips (just for information)           ############
    ###############################################################################

    def define_tips(self):
        Value_tooltip = "<p>Value of Item to be stored in csv File selected from List Name dropdown menu.</p>"
        Description_tooltip = "<p>Additional info for Item to be stored in csv File selected from List Name dropdown menu.</p>"
        Clip_Polygon_tooltip = "<p>Path to clipping polygon shapefile- Leave blank if you want to use the current QGIS Canvas rectangle.</p>"
        Clip_path_tooltip = "<p>Path to new clipped QGIS project directory.</p>"
        Export_path_tooltip = "<p>Path to directory to store combined layers.</p>"
        Proj_name_tooltip = "<p>Name of Project, e.g. Username & date.</p>"
        Proj_region_tooltip = "<p>Region project applies to e.g. Sefwi Belt.</p>"
        Merge_main_tooltip = "<p>Path to directory of global QGIS Project.</p>"
        Merge_sub_tooltip = "<p>Path to directory of local QGIS Project.</p>"
        Merge_output_tooltip = "<p>Path to directory of newly merged QGIS Project.</p>"
        Csv_list_tooltip = "Select CSV file to add item to"
        Epsilon_tooltip = "The radius of the circle to be created around each data point to check the density (in metres)"
        """Auto_on = (
            "Turn on autoincrementing of Stop Number behaviour when a new Stop is added"
        )
        Auto_off = "Turn off autoincrementing of Stop Number behaviour when a new Stop is added""" ""

        Clip_tooltip = "Provide an output path (and optional clipping polygon) \nto clip the all WAXI QFIELD layers of current project, retaining directory structure. \nIf no polygon is defined, it will clip to the current Canvas (field of view) of the open project"
        Add_item_tooltip = "Chose the CSV file you want to add to, and define the \nValue & Description for a new field that will appear in the dropdown menus in QFIELD"
        Export_tooltip = "Provide an output path to combine similar layers into \none of three shapefiles (structure polygons, structure points and lithologies)"
        Update_tooltip = "Provide new Name and Region info for project"
        Merge_tooltip = "Provide paths to the global QGIS project, \nthe local one you have been working on and the output directory that\n will store the merged projects, with duplicates removed."
        Virtualstop_tooltip = "Combine all point layers to get virtual Stop IDS"
        """Autoincrement_tooltip = (
            "Toggle autoincrementing of Stop Number behaviour when a new Stop is added"
        )"""

        gtCircles_tooltip = (
            "Select Checkbox to switch to Great Circle Display for Stereonet Plugin"
        )
        contours_tooltip = "Select Checkbox to add Contour Display for Stereonet Plugin"
        kinematics_tooltip = "Select Checkbox to add kinematics for Lineation Display for Stereonet Plugin"
        linPlanes_tooltip = "Select Checkbox to add Associated Great Circles to Lineation Display for Stereonet Plugin"
        rose_tooltip = "Select Checkbox to display rose diagram instead of stereoplot in Stereonet Plugin"
        stereonet_tooltip = (
            "Select Checkbox to control Display behaviour for Stereonet Plugin"
        )
        FieldMove_Import_tooltip = "Select a directory with a FieldMove project and the csv files will be converted to shapefiles, \nthe photos imported to the project, the maps loaded as temporary files and the lithologies added to Local Lithologies"

        # Titles
        self.dlg.groupBox_4.setToolTip(Clip_tooltip)
        self.dlg.label_37.setToolTip(Add_item_tooltip)
        self.dlg.groupBox_10.setToolTip(Export_tooltip)
        self.dlg.groupBox_6.setToolTip(Update_tooltip)
        self.dlg.groupBox_11.setToolTip(Virtualstop_tooltip)
        """self.dlg.groupBox_7.setToolTip(Autoincrement_tooltip)"""

        # Project Parameters
        self.dlg.projName_pushButton.setToolTip("Update project name")
        self.dlg.merge_pushButton.setToolTip("Merge projects")
        self.dlg.merge_pushButton_2.setToolTip("Remove Duplicate UUIDs")
        self.dlg.merge_layers_pushButton_2.setToolTip("Merge two QGIS layers")
        self.dlg.clip_pushButton.setToolTip("Clip to current canvas")
        self.dlg.lineEdit_9.setToolTip(Proj_name_tooltip)
        self.dlg.lineEdit_10.setToolTip(Proj_region_tooltip)

        # CSV
        self.dlg.csv_pushButton.setToolTip("Add new item to CSV file")
        self.dlg.csv_pushButton_2.setToolTip("Delete an item from CSV file")

        # Stop
        """self.dlg.autoinc_pushButton.setToolTip("Toggle Auto-Increment of Stop numbers")"""
        self.dlg.virtual_pushButton.setToolTip("Create virtual stops")

        # Import Data
        self.dlg.lineEdit_13.setToolTip("Select the file you want to load")

        self.dlg.pushButton_11.setToolTip("Undo previous edits")
        self.dlg.pushButton_9.setToolTip("All columns name are suitable for you")

        self.dlg.pushButton_12.setToolTip("Undo previous edits")
        self.dlg.pushButton_10.setToolTip("All lithologies are suitable for you")

        self.dlg.pushButton_14.setToolTip("Import processed data into QGIS")
        self.dlg.pushButton_14.clicked.connect(
            lambda: self.Generate_Output_QGIS_Layers()
        )

        self.dlg.pushButton_13.setToolTip("Reset this window")
        self.dlg.pushButton_19.setToolTip("Reset this window")
        self.dlg.pushButton_22.setToolTip("Reset this window")

        self.dlg.pushButton_FM_project_select.setToolTip(FieldMove_Import_tooltip)

        # Export Data
        self.dlg.export_pushButton.setToolTip("Export layers")

        # Stereo
        self.dlg.stereonet_pushButton.setToolTip("Update setting of stereonet display")

        # Help
        # self.dlg.pushButton_33.setToolTip("Click here to access to WAXI website")
        # self.dlg.pushButton_30.setToolTip("Click here to access to AMIRA website")
        # self.dlg.pushButton_32.setToolTip("Click here to access to CET website")
        # self.dlg.pushButton_31.setToolTip("Click here to access to the WAXI Zenodo page")

        # self.dlg.pushButton_35.setToolTip("Click here to access to the WAXI publications")
        # self.dlg.pushButton_36.setToolTip("Click here to access to the WAXI theses")

        # RadioButtons
        """self.dlg.autoinc_on_pushButton.setToolTip(Auto_on)
        self.dlg.autoinc_off_pushButton.setToolTip(Auto_off)"""

        # LineEdit
        self.dlg.lineEdit_38.setToolTip(Value_tooltip)

        self.dlg.lineEdit_8.setToolTip(Clip_Polygon_tooltip)
        self.dlg.pushButton_6.setToolTip(Clip_Polygon_tooltip)

        self.dlg.lineEdit_3.setToolTip(Clip_path_tooltip)
        self.dlg.pushButton.setToolTip(Clip_path_tooltip)

        self.dlg.lineEdit_7.setToolTip(Export_path_tooltip)
        self.dlg.pushButton_5.setToolTip(Export_path_tooltip)

        self.dlg.lineEdit_11.setToolTip(Merge_main_tooltip)
        self.dlg.pushButton_29.setToolTip(Merge_main_tooltip)

        self.dlg.lineEdit_26.setToolTip(Merge_sub_tooltip)
        self.dlg.pushButton_20.setToolTip(Merge_sub_tooltip)

        self.dlg.lineEdit_37.setToolTip(Merge_output_tooltip)
        self.dlg.pushButton_27.setToolTip(Merge_output_tooltip)

        self.dlg.lineEdit_53.setToolTip(Epsilon_tooltip)

        self.dlg.gtCircles_checkBox.setToolTip(gtCircles_tooltip)
        self.dlg.contours_checkBox.setToolTip(contours_tooltip)
        self.dlg.kinematics_checkBox.setToolTip(kinematics_tooltip)
        self.dlg.linPlanes_checkBox.setToolTip(linPlanes_tooltip)
        self.dlg.rose_checkBox.setToolTip(rose_tooltip)

    ###############################################################################
    ####################                   RUN                   ##################
    ###############################################################################
    def use_exif_azimuth(self):
        dec = ""
        layer_name = "Photographs_PT"
        layer = QgsProject.instance().mapLayersByName(layer_name)[0]
        if not layer.isValid():
            print(f"Error: Layer '{layer_name}' not found or invalid.")
        else:

            # Start an edit session
            if not layer.isEditable():
                layer.startEditing()

            # Loop through all features in the layer
            for feature in layer.getFeatures():
                # Get the feature ID
                feature_id = feature.id()
                # print("feature_id",feature_id)
                # Extract values from "Photographs" and "Date" fields
                date = feature["Date"]
                date = date.split("/")

                day = int(date[2].split(" ")[0])
                month = int(date[1])
                year = int(date[0])
                date = datetime(year, month, day)

                # Extract latitude and longitude from the feature's geometry
                geometry = feature.geometry()
                if geometry.isEmpty():
                    print(f"Feature ID {feature_id} has no geometry.")
                    continue

                # Get the point geometry as lat/lon (assuming the layer has point geometry)
                if geometry.type() == QgsWkbTypes.PointGeometry:
                    lat, lon = geometry.asPoint().y(), geometry.asPoint().x()
                else:
                    print(f"Feature ID {feature_id} does not have point geometry.")
                    continue

                lon = 0.0
                lat = 5.0
                date = datetime(2020, 12, 12)
                # calculate IGRF compnents and  convert to Inc, Dec, Int
                Be, Bn, Bu = igrf(lon, lat, 0, date)  # returns east, north, up
                (self.RTE_P_inc, self.RTE_P_dec) = get_inclination_declination(
                    Be, Bn, Bu, degrees=True
                )

                inc = self.RTE_P_inc.item()
                dec = self.RTE_P_dec.item()

                field_name = "Azimut"
                # Update the "Azimuth" field with the new value
                manipulated_value = feature[field_name] + dec
                field_index = layer.fields().indexFromName("Azimut")
                if field_index == -1:
                    print(f"Field '{field_name}' not found in layer '{layer.name()}'")
                    return

                # Iterate through features and update the field value
                for feature in layer.getFeatures():
                    feature[field_index] = manipulated_value  # Update the field value
                    layer.updateFeature(
                        feature
                    )  # Save the updated feature to the layer

                # Commit changes
                if not layer.commitChanges():
                    print(f"Failed to commit changes to layer '{layer.name()}'")

                self.iface.messageBar().pushMessage(
                    "Photo orientation updated to account for declination {}".format(
                        round(dec, 2)
                    ),
                    level=Qgis.Success,
                    duration=15,
                )
